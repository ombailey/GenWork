{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoize = memoize;\nexports.memoizeCompare = memoizeCompare;\nexports.maxArgumentCount = maxArgumentCount;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _lruQueue = require(\"./lruQueue.js\");\n\n// function utils\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {Object} [options]\n * @param {function(args: Array): string} [options.hasher]\n *    A custom hash builder. Is JSON.stringify by default.\n * @param {number | undefined} [options.limit]\n *    Maximum number of values that may be cached. Undefined indicates\n *    unlimited (default)\n * @return {function}                       Returns the memoized function\n */\nfunction memoize(fn) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    hasher = _ref.hasher,\n    limit = _ref.limit;\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\n  hasher = hasher == null ? JSON.stringify : hasher;\n  return function memoize() {\n    if ((0, _typeof2[\"default\"])(memoize.cache) !== 'object') {\n      memoize.cache = {\n        values: new Map(),\n        lru: (0, _lruQueue.lruQueue)(limit || Number.POSITIVE_INFINITY)\n      };\n    }\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    var hash = hasher(args);\n    if (memoize.cache.values.has(hash)) {\n      memoize.cache.lru.hit(hash);\n      return memoize.cache.values.get(hash);\n    }\n    var newVal = fn.apply(fn, args);\n    memoize.cache.values.set(hash, newVal);\n    memoize.cache.values[\"delete\"](memoize.cache.lru.hit(hash));\n    return newVal;\n  };\n}\n/**\n * Memoize a given function by caching all results and the arguments,\n * and comparing against the arguments of previous results before\n * executing again.\n * This is less performant than `memoize` which calculates a hash,\n * which is very fast to compare. Use `memoizeCompare` only when it is\n * not possible to create a unique serializable hash from the function\n * arguments.\n * The isEqual function must compare two sets of arguments\n * and return true when equal (can be a deep equality check for example).\n * @param {function} fn\n * @param {function(a: *, b: *) : boolean} isEqual\n * @returns {function}\n */\n\nfunction memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n  memoize.cache = [];\n  return memoize;\n}\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\nfunction maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","memoize","memoizeCompare","maxArgumentCount","_typeof2","_lruQueue","fn","_ref","arguments","length","undefined","hasher","limit","Number","POSITIVE_INFINITY","JSON","stringify","cache","values","Map","lru","lruQueue","args","i","hash","has","hit","get","newVal","apply","set","isEqual","c","cached","res","unshift","keys","signatures","reduce","signature","count","match","Math","max"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/utils/function.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoize = memoize;\nexports.memoizeCompare = memoizeCompare;\nexports.maxArgumentCount = maxArgumentCount;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _lruQueue = require(\"./lruQueue.js\");\n\n// function utils\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {Object} [options]\n * @param {function(args: Array): string} [options.hasher]\n *    A custom hash builder. Is JSON.stringify by default.\n * @param {number | undefined} [options.limit]\n *    Maximum number of values that may be cached. Undefined indicates\n *    unlimited (default)\n * @return {function}                       Returns the memoized function\n */\nfunction memoize(fn) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      hasher = _ref.hasher,\n      limit = _ref.limit;\n\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\n  hasher = hasher == null ? JSON.stringify : hasher;\n  return function memoize() {\n    if ((0, _typeof2[\"default\"])(memoize.cache) !== 'object') {\n      memoize.cache = {\n        values: new Map(),\n        lru: (0, _lruQueue.lruQueue)(limit || Number.POSITIVE_INFINITY)\n      };\n    }\n\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var hash = hasher(args);\n\n    if (memoize.cache.values.has(hash)) {\n      memoize.cache.lru.hit(hash);\n      return memoize.cache.values.get(hash);\n    }\n\n    var newVal = fn.apply(fn, args);\n    memoize.cache.values.set(hash, newVal);\n    memoize.cache.values[\"delete\"](memoize.cache.lru.hit(hash));\n    return newVal;\n  };\n}\n/**\n * Memoize a given function by caching all results and the arguments,\n * and comparing against the arguments of previous results before\n * executing again.\n * This is less performant than `memoize` which calculates a hash,\n * which is very fast to compare. Use `memoizeCompare` only when it is\n * not possible to create a unique serializable hash from the function\n * arguments.\n * The isEqual function must compare two sets of arguments\n * and return true when equal (can be a deep equality check for example).\n * @param {function} fn\n * @param {function(a: *, b: *) : boolean} isEqual\n * @returns {function}\n */\n\n\nfunction memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n\n  memoize.cache = [];\n  return memoize;\n}\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\n\nfunction maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}