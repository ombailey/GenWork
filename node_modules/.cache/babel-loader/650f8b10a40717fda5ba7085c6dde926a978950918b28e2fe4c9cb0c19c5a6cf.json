{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar dummy_encoder_1 = __importDefault(require(\"../transformers/encoders/dummy.encoder\"));\nvar mathjs_1 = require(\"mathjs\");\nvar tensorflowlib_1 = __importDefault(require(\"../shared/tensorflowlib\"));\nvar defaults_1 = require(\"../shared/defaults\");\nvar groupby_1 = __importDefault(require(\"../aggregators/groupby\"));\nvar errors_1 = __importDefault(require(\"../shared/errors\"));\nvar indexing_1 = require(\"./indexing\");\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar generic_1 = __importDefault(require(\"./generic\"));\nvar table_1 = require(\"table\");\nvar series_1 = __importDefault(require(\"./series\"));\nvar plotting_1 = require(\"../../danfojs-base/plotting\");\nvar utils = new utils_1.default();\n/**\n * Two-dimensional ndarray with axis labels.\n * The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index.\n * Operations between DataFrame (+, -, /, , *) align values based on their associated index valuesâ€“ they need not be the same length.\n * @param data 2D Array, JSON, Tensor, Block of data.\n * @param options.index Array of numeric or string names for subseting array. If not specified, indexes are auto generated.\n * @param options.columns Array of column names. If not specified, column names are auto generated.\n * @param options.dtypes Array of data types for each the column. If not specified, dtypes are/is inferred.\n * @param options.config General configuration object for extending or setting NDframe behavior.\n */\nvar DataFrame = /** @class */function (_super) {\n  __extends(DataFrame, _super);\n  function DataFrame(data, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = this;\n    var index = options.index,\n      columns = options.columns,\n      dtypes = options.dtypes,\n      config = options.config;\n    _this = _super.call(this, {\n      data: data,\n      index: index,\n      columns: columns,\n      dtypes: dtypes,\n      config: config,\n      isSeries: false\n    }) || this;\n    _this.$setInternalColumnDataProperty();\n    return _this;\n  }\n  /**\n   * Maps all column names to their corresponding data, and return them as Series objects.\n   * This makes column subsetting works. E.g this can work ==> `df[\"col1\"]`\n   * @param column Optional, a single column name to map\n   */\n  DataFrame.prototype.$setInternalColumnDataProperty = function (column) {\n    var self = this;\n    if (column && typeof column === \"string\") {\n      Object.defineProperty(self, column, {\n        get: function () {\n          return self.$getColumnData(column);\n        },\n        set: function (arr) {\n          self.$setColumnData(column, arr);\n        }\n      });\n    } else {\n      var columns = this.columns;\n      var _loop_1 = function (i) {\n        var column_1 = columns[i];\n        Object.defineProperty(this_1, column_1, {\n          get: function () {\n            return self.$getColumnData(column_1);\n          },\n          set: function (arr) {\n            self.$setColumnData(column_1, arr);\n          }\n        });\n      };\n      var this_1 = this;\n      for (var i = 0; i < columns.length; i++) {\n        _loop_1(i);\n      }\n    }\n  };\n  /**\n   * Returns the column data from the DataFrame by column name.\n   * @param column column name to get the column data\n   * @param returnSeries Whether to return the data in series format or not. Defaults to true\n   */\n  DataFrame.prototype.$getColumnData = function (column, returnSeries) {\n    if (returnSeries === void 0) {\n      returnSeries = true;\n    }\n    var columnIndex = this.columns.indexOf(column);\n    if (columnIndex == -1) {\n      errors_1.default.throwColumnNotFoundError(this);\n    }\n    var dtypes = [this.$dtypes[columnIndex]];\n    var index = __spreadArray([], this.$index, true);\n    var columns = [column];\n    var config = __assign({}, this.$config);\n    if (this.$config.isLowMemoryMode) {\n      var data = [];\n      for (var i = 0; i < this.values.length; i++) {\n        var row = this.values[i];\n        data.push(row[columnIndex]);\n      }\n      if (returnSeries) {\n        return new series_1.default(data, {\n          dtypes: dtypes,\n          index: index,\n          columns: columns,\n          config: config\n        });\n      } else {\n        return data;\n      }\n    } else {\n      var data = this.$dataIncolumnFormat[columnIndex];\n      if (returnSeries) {\n        return new series_1.default(data, {\n          dtypes: dtypes,\n          index: index,\n          columns: columns,\n          config: config\n        });\n      } else {\n        return data;\n      }\n    }\n  };\n  /**\n   * Updates the internal column data via column name.\n   * @param column The name of the column to update.\n   * @param arr The new column data\n   */\n  DataFrame.prototype.$setColumnData = function (column, arr) {\n    var columnIndex = this.$columns.indexOf(column);\n    if (columnIndex == -1) {\n      throw new Error(\"ParamError: column \" + column + \" not found in \" + this.$columns + \". If you need to add a new column, use the df.addColumn method. \");\n    }\n    var colunmValuesToAdd;\n    if (arr instanceof series_1.default) {\n      colunmValuesToAdd = arr.values;\n    } else if (Array.isArray(arr)) {\n      colunmValuesToAdd = arr;\n    } else {\n      throw new Error(\"ParamError: specified value not supported. It must either be an Array or a Series of the same length\");\n    }\n    if (colunmValuesToAdd.length !== this.shape[0]) {\n      errors_1.default.throwColumnLengthError(this, colunmValuesToAdd.length);\n    }\n    if (this.$config.isLowMemoryMode) {\n      //Update row ($data) array\n      for (var i = 0; i < this.$data.length; i++) {\n        this.$data[i][columnIndex] = colunmValuesToAdd[i];\n      }\n      //Update the dtypes\n      this.$dtypes[columnIndex] = utils.inferDtype(colunmValuesToAdd)[0];\n    } else {\n      //Update row ($data) array\n      for (var i = 0; i < this.values.length; i++) {\n        this.$data[i][columnIndex] = colunmValuesToAdd[i];\n      }\n      //Update column ($dataIncolumnFormat) array since it's available in object\n      this.$dataIncolumnFormat[columnIndex] = arr;\n      //Update the dtypes\n      this.$dtypes[columnIndex] = utils.inferDtype(colunmValuesToAdd)[0];\n    }\n  };\n  /**\n   * Return data with missing values removed from a specified axis\n   * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n  */\n  DataFrame.prototype.$getDataByAxisWithMissingValuesRemoved = function (axis) {\n    var oldValues = this.$getDataArraysByAxis(axis);\n    var cleanValues = [];\n    for (var i = 0; i < oldValues.length; i++) {\n      var values = oldValues[i];\n      cleanValues.push(utils.removeMissingValuesFromArray(values));\n    }\n    return cleanValues;\n  };\n  /**\n   * Return data aligned to the specified axis. Transposes the array if needed.\n   * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n  */\n  DataFrame.prototype.$getDataArraysByAxis = function (axis) {\n    if (axis === 1) {\n      return this.values;\n    } else {\n      var dfValues = void 0;\n      if (this.config.isLowMemoryMode) {\n        dfValues = utils.transposeArray(this.values);\n      } else {\n        dfValues = this.$dataIncolumnFormat;\n      }\n      return dfValues;\n    }\n  };\n  /*\n  * checks if DataFrame is compactible for arithmetic operation\n  * compatible Dataframe must have only numerical dtypes\n  **/\n  DataFrame.prototype.$frameIsNotCompactibleForArithmeticOperation = function () {\n    var dtypes = this.dtypes;\n    var str = function (element) {\n      return element == \"string\";\n    };\n    return dtypes.some(str);\n  };\n  /**\n   * Return Tensors in the right axis for math operations.\n   * @param other DataFrame or Series or number or array\n   * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n   * */\n  DataFrame.prototype.$getTensorsForArithmeticOperationByAxis = function (other, axis) {\n    if (typeof other === \"number\") {\n      return [this.tensor, tensorflowlib_1.default.scalar(other)];\n    } else if (other instanceof DataFrame) {\n      return [this.tensor, other.tensor];\n    } else if (other instanceof series_1.default) {\n      if (axis === 0) {\n        return [this.tensor, tensorflowlib_1.default.tensor2d(other.values, [other.shape[0], 1])];\n      } else {\n        return [this.tensor, tensorflowlib_1.default.tensor2d(other.values, [other.shape[0], 1]).transpose()];\n      }\n    } else if (Array.isArray(other)) {\n      if (axis === 0) {\n        return [this.tensor, tensorflowlib_1.default.tensor2d(other, [other.length, 1])];\n      } else {\n        return [this.tensor, tensorflowlib_1.default.tensor2d(other, [other.length, 1]).transpose()];\n      }\n    } else {\n      throw new Error(\"ParamError: Invalid type for other parameter. other must be one of Series, DataFrame or number.\");\n    }\n  };\n  /**\n   * Returns the dtype for a given column name\n   * @param column\n   */\n  DataFrame.prototype.$getColumnDtype = function (column) {\n    var columnIndex = this.columns.indexOf(column);\n    if (columnIndex === -1) {\n      throw Error(\"ColumnNameError: Column \\\"\" + column + \"\\\" does not exist\");\n    }\n    return this.dtypes[columnIndex];\n  };\n  DataFrame.prototype.$logicalOps = function (tensors, operation) {\n    var newValues = [];\n    switch (operation) {\n      case 'gt':\n        newValues = tensors[0].greater(tensors[1]).arraySync();\n        break;\n      case 'lt':\n        newValues = tensors[0].less(tensors[1]).arraySync();\n        break;\n      case 'ge':\n        newValues = tensors[0].greaterEqual(tensors[1]).arraySync();\n        break;\n      case 'le':\n        newValues = tensors[0].lessEqual(tensors[1]).arraySync();\n        break;\n      case 'eq':\n        newValues = tensors[0].equal(tensors[1]).arraySync();\n        break;\n      case 'ne':\n        newValues = tensors[0].notEqual(tensors[1]).arraySync();\n        break;\n    }\n    var newData = utils.mapIntegersToBooleans(newValues, 2);\n    return new DataFrame(newData, {\n      index: __spreadArray([], this.index, true),\n      columns: __spreadArray([], this.columns, true),\n      dtypes: __spreadArray([], this.dtypes, true),\n      config: __assign({}, this.config)\n    });\n  };\n  DataFrame.prototype.$MathOps = function (tensors, operation, inplace) {\n    var tensorResult;\n    switch (operation) {\n      case 'add':\n        tensorResult = tensors[0].add(tensors[1]);\n        break;\n      case 'sub':\n        tensorResult = tensors[0].sub(tensors[1]);\n        break;\n      case 'pow':\n        tensorResult = tensors[0].pow(tensors[1]);\n        break;\n      case 'div':\n        tensorResult = tensors[0].div(tensors[1]);\n        break;\n      case 'divNoNan':\n        tensorResult = tensors[0].divNoNan(tensors[1]);\n        break;\n      case 'mul':\n        tensorResult = tensors[0].mul(tensors[1]);\n        break;\n      case 'mod':\n        tensorResult = tensors[0].mod(tensors[1]);\n        break;\n    }\n    if (inplace) {\n      var newData = tensorResult === null || tensorResult === void 0 ? void 0 : tensorResult.arraySync();\n      this.$setValues(newData);\n    } else {\n      return new DataFrame(tensorResult, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  /**\n  * Purely integer-location based indexing for selection by position.\n  * ``.iloc`` is primarily integer position based (from ``0`` to\n  * ``length-1`` of the axis), but may also be used with a boolean array.\n  *\n  * @param rows Array of row indexes\n  * @param columns Array of column indexes\n  *\n  * Allowed inputs are in rows and columns params are:\n  *\n  * - An array of single integer, e.g. ``[5]``.\n  * - A list or array of integers, e.g. ``[4, 3, 0]``.\n  * - A slice array string with ints, e.g. ``[\"1:7\"]``.\n  * - A boolean array.\n  * - A ``callable`` function with one argument (the calling Series or\n  * DataFrame) and that returns valid output for indexing (one of the above).\n  * This is useful in method chains, when you don't have a reference to the\n  * calling object, but would like to base your selection on some value.\n  *\n  * ``.iloc`` will raise ``IndexError`` if a requested indexer is\n  * out-of-bounds.\n  *\n  * @example\n  * ```\n  * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n  * const df2 = df.iloc({ rows: [1], columns: [\"A\"] })\n  * ```\n  */\n  DataFrame.prototype.iloc = function (_a) {\n    var rows = _a.rows,\n      columns = _a.columns;\n    return (0, indexing_1._iloc)({\n      ndFrame: this,\n      rows: rows,\n      columns: columns\n    });\n  };\n  /**\n   * Access a group of rows and columns by label(s) or a boolean array.\n   * ``loc`` is primarily label based, but may also be used with a boolean array.\n   *\n   * @param rows Array of row indexes\n   * @param columns Array of column indexes\n   *\n   * Allowed inputs are:\n   *\n   * - A single label, e.g. ``[\"5\"]`` or ``['a']``, (note that ``5`` is interpreted as a\n   *   *label* of the index, and **never** as an integer position along the index).\n   *\n   * - A list or array of labels, e.g. ``['a', 'b', 'c']``.\n   *\n   * - A slice object with labels, e.g. ``[\"a:f\"]``. Note that start and the stop are included\n   *\n   * - A boolean array of the same length as the axis being sliced,\n   * e.g. ``[True, False, True]``.\n   *\n   * - A ``callable`` function with one argument (the calling Series or\n   * DataFrame) and that returns valid output for indexing (one of the above)\n  * @example\n  * ```\n  * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n  * const df2 = df.loc({ rows: [1], columns: [\"A\"] })\n  * ```\n  */\n  DataFrame.prototype.loc = function (_a) {\n    var rows = _a.rows,\n      columns = _a.columns;\n    return (0, indexing_1._loc)({\n      ndFrame: this,\n      rows: rows,\n      columns: columns\n    });\n  };\n  /**\n   * Prints DataFrame to console as a formatted grid of row and columns.\n  */\n  DataFrame.prototype.toString = function () {\n    var maxRow = this.config.getMaxRow;\n    var maxColToDisplayInConsole = this.config.getTableMaxColInConsole;\n    // let data;\n    var dataArr = [];\n    var colLen = this.columns.length;\n    var header = [];\n    if (colLen > maxColToDisplayInConsole) {\n      //truncate displayed columns to fit in the console\n      var firstFourcolNames = this.columns.slice(0, 4);\n      var lastThreecolNames = this.columns.slice(colLen - 3);\n      //join columns with truncate ellipse in the middle\n      header = __spreadArray(__spreadArray(__spreadArray([\"\"], firstFourcolNames, true), [\"...\"], false), lastThreecolNames, true);\n      var subIdx = void 0;\n      var firstHalfValues = void 0;\n      var lastHalfValueS = void 0;\n      if (this.values.length > maxRow) {\n        //slice Object to show [max_rows]\n        var dfSubset1 = this.iloc({\n          rows: [\"0:\" + maxRow],\n          columns: [\"0:4\"]\n        });\n        var dfSubset2 = this.iloc({\n          rows: [\"0:\" + maxRow],\n          columns: [colLen - 3 + \":\"]\n        });\n        subIdx = this.index.slice(0, maxRow);\n        firstHalfValues = dfSubset1.values;\n        lastHalfValueS = dfSubset2.values;\n      } else {\n        var dfSubset1 = this.iloc({\n          columns: [\"0:4\"]\n        });\n        var dfSubset2 = this.iloc({\n          columns: [colLen - 3 + \":\"]\n        });\n        subIdx = this.index.slice(0, maxRow);\n        firstHalfValues = dfSubset1.values;\n        lastHalfValueS = dfSubset2.values;\n      }\n      // merge subset \n      for (var i = 0; i < subIdx.length; i++) {\n        var idx = subIdx[i];\n        var row = __spreadArray(__spreadArray(__spreadArray([idx], firstHalfValues[i], true), [\"...\"], false), lastHalfValueS[i], true);\n        dataArr.push(row);\n      }\n    } else {\n      //display all columns\n      header = __spreadArray([\"\"], this.columns, true);\n      var subIdx = void 0;\n      var values = void 0;\n      if (this.values.length > maxRow) {\n        //slice Object to show a max of [max_rows]\n        var data = this.iloc({\n          rows: [\"0:\" + maxRow]\n        });\n        subIdx = data.index;\n        values = data.values;\n      } else {\n        values = this.values;\n        subIdx = this.index;\n      }\n      // merge subset \n      for (var i = 0; i < subIdx.length; i++) {\n        var idx = subIdx[i];\n        var row = __spreadArray([idx], values[i], true);\n        dataArr.push(row);\n      }\n    }\n    var columnsConfig = {};\n    columnsConfig[0] = {\n      width: 10\n    }; //set column width for index column\n    for (var index = 1; index < header.length; index++) {\n      columnsConfig[index] = {\n        width: 17,\n        truncate: 16\n      };\n    }\n    var tableData = __spreadArray([header], dataArr, true); //Adds the column names to values before printing\n    return (0, table_1.table)(tableData, __assign({\n      columns: columnsConfig\n    }, this.config.getTableDisplayConfig));\n  };\n  /**\n    * Returns the first n values in a DataFrame\n    * @param rows The number of rows to return\n    * @example\n    * ```\n    * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n    * const df2 = df.head(1)\n    * ```\n  */\n  DataFrame.prototype.head = function (rows) {\n    if (rows === void 0) {\n      rows = 5;\n    }\n    if (rows <= 0) {\n      throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n    }\n    if (this.shape[0] <= rows) {\n      return this.copy();\n    }\n    if (this.shape[0] - rows < 0) {\n      throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n    }\n    return this.iloc({\n      rows: [\"0:\" + rows]\n    });\n  };\n  /**\n    * Returns the last n values in a DataFrame\n    * @param rows The number of rows to return\n    * @example\n    * ```\n    * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n    * const df2 = df.tail(1)\n    * ```\n  */\n  DataFrame.prototype.tail = function (rows) {\n    if (rows === void 0) {\n      rows = 5;\n    }\n    if (rows <= 0) {\n      throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n    }\n    if (this.shape[0] <= rows) {\n      return this.copy();\n    }\n    if (this.shape[0] - rows < 0) {\n      throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n    }\n    rows = this.shape[0] - rows;\n    return this.iloc({\n      rows: [rows + \":\"]\n    });\n  };\n  /**\n   * Gets n number of random rows in a dataframe. Sample is reproducible if seed is provided.\n   * @param num The number of rows to return. Default to 5.\n   * @param options.seed An integer specifying the random seed that will be used to create the distribution.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n   * const df2 = await df.sample(1)\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n   * const df2 = await df.sample(1, { seed: 1 })\n   * ```\n  */\n  DataFrame.prototype.sample = function (num, options) {\n    if (num === void 0) {\n      num = 5;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var seed, shuffledIndex, df;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            seed = __assign({\n              seed: 1\n            }, options).seed;\n            if (num > this.shape[0]) {\n              throw new Error(\"ParamError: Sample size cannot be bigger than number of rows\");\n            }\n            if (num <= 0) {\n              throw new Error(\"ParamError: Sample size cannot be less than 1\");\n            }\n            return [4 /*yield*/, tensorflowlib_1.default.data.array(this.index).shuffle(num, \"\" + seed).take(num).toArray()];\n          case 1:\n            shuffledIndex = _a.sent();\n            df = this.iloc({\n              rows: shuffledIndex\n            });\n            return [2 /*return*/, df];\n        }\n      });\n    });\n  };\n  DataFrame.prototype.add = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: add operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"add\", inplace);\n  };\n  DataFrame.prototype.sub = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: sub operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"sub\", inplace);\n  };\n  DataFrame.prototype.mul = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: mul operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"mul\", inplace);\n  };\n  DataFrame.prototype.div = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: div operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"div\", inplace);\n  };\n  DataFrame.prototype.divNoNan = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: div operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"divNoNan\", inplace);\n  };\n  DataFrame.prototype.pow = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: pow operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"pow\", inplace);\n  };\n  DataFrame.prototype.mod = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: mod operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$MathOps(tensors, \"mod\", inplace);\n  };\n  /**\n   * Return mean of DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the mean column-wise, if 1, row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n   * df.mean().print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n   * df.mean({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.mean = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: mean operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      return arr.reduce(function (a, b) {\n        return a + b;\n      }, 0) / arr.length;\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return median of DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the median column-wise, if 1, row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n   * df.median().print()\n   * ```\n  */\n  DataFrame.prototype.median = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: median operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      return (0, mathjs_1.median)(arr);\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return mode of DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the mode column-wise, if 1, row-wise. Defaults to 1\n   * @param options.keep If there are more than one modes, returns the mode at position [keep]. Defaults to 0\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n   * df.mode().print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n   * df.mode({ keep: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.mode = function (options) {\n    var _a = __assign({\n        axis: 1,\n        keep: 0\n      }, options),\n      axis = _a.axis,\n      keep = _a.keep;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: mode operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      var tempMode = (0, mathjs_1.mode)(arr);\n      if (tempMode.length === 1) {\n        return tempMode[0];\n      } else {\n        return tempMode[keep];\n      }\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return minimum of values in a DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the minimum value column-wise, if 1, row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.min().print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.min({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.min = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: min operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      var smallestValue = arr[0];\n      for (var i = 0; i < arr.length; i++) {\n        smallestValue = smallestValue < arr[i] ? smallestValue : arr[i];\n      }\n      return smallestValue;\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return maximum of values in a DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the maximum column-wise, if 1, row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.max().print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.max({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.max = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: max operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      var biggestValue = arr[0];\n      for (var i = 0; i < arr.length; i++) {\n        biggestValue = biggestValue > arr[i] ? biggestValue : arr[i];\n      }\n      return biggestValue;\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return standard deviation of values in a DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the standard deviation column-wise, if 1, row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.std().print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.std({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.std = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: std operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      return (0, mathjs_1.std)(arr);\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return variance of values in a DataFrame across specified axis.\n   * @param options.axis 0 or 1. If 0, compute the variance column-wise, if 1, add row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.var().print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.var({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.var = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: var operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      return (0, mathjs_1.variance)(arr);\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Get Less than of dataframe and other, element-wise (binary operator lt).\n   * @param other DataFrame, Series, Array or Scalar number to compare with\n   * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.lt(2).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.lt([2, 3], { axis: 0 }).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = new Series([2, 3])\n   * df.lt(sf, { axis: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.lt = function (other, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: lt operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$logicalOps(tensors, \"lt\");\n  };\n  /**\n   * Returns \"greater than\" of dataframe and other.\n   * @param other DataFrame, Series, Array or Scalar number to compare with\n   * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.gt(2).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.gt([2, 3], { axis: 0 }).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = new Series([2, 3])\n   * df.gt(sf, { axis: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.gt = function (other, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: gt operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$logicalOps(tensors, \"gt\");\n  };\n  /**\n   * Returns \"equals to\" of dataframe and other.\n   * @param other DataFrame, Series, Array or Scalar number to compare with\n   * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.eq(2).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.eq([2, 3], { axis: 0 }).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = new Series([2, 3])\n   * df.eq(sf, { axis: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.eq = function (other, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: eq operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$logicalOps(tensors, \"eq\");\n  };\n  /**\n   * Returns \"not equal to\" of dataframe and other.\n   * @param other DataFrame, Series, Array or Scalar number to compare with\n   * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.ne(2).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.ne([2, 3], { axis: 0 }).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = new Series([2, 3])\n   * df.ne(sf, { axis: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.ne = function (other, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: ne operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$logicalOps(tensors, \"ne\");\n  };\n  /**\n  * Returns \"less than or equal to\" of dataframe and other.\n  * @param other DataFrame, Series, Array or Scalar number to compare with\n  * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.le(2).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.le([2, 3], { axis: 0 }).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = new Series([2, 3])\n   * df.le(sf, { axis: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.le = function (other, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: le operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$logicalOps(tensors, \"le\");\n  };\n  /**\n  * Returns \"greater than or equal to\" between dataframe and other.\n  * @param other DataFrame, Series, Array or Scalar number to compare with\n  * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.ge(2).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.ge([2, 3], { axis: 0 }).print()\n   * ```\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = new Series([2, 3])\n   * df.ge(sf, { axis: 1 }).print()\n   * ```\n  */\n  DataFrame.prototype.ge = function (other, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: ge operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n    return this.$logicalOps(tensors, \"ge\");\n  };\n  /**\n   * Return number of non-null elements in a Series\n   * @param options.axis 0 or 1. If 0, count column-wise, if 1, add row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.count().print()\n   * ```\n   *\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.count({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.count = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var resultArr = newData.map(function (arr) {\n      return arr.length;\n    });\n    if (axis === 0) {\n      return new series_1.default(resultArr, {\n        index: this.columns\n      });\n    } else {\n      return new series_1.default(resultArr, {\n        index: this.index\n      });\n    }\n  };\n  /**\n   * Return the sum of values across an axis.\n   * @param options.axis 0 or 1. If 0, count column-wise, if 1, add row-wise. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.sum().print()\n   * ```\n   *\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.sum({ axis: 0 }).print()\n   * ```\n  */\n  DataFrame.prototype.sum = function (options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var result = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var sumArr = result.map(function (innerArr) {\n      return innerArr.reduce(function (a, b) {\n        return Number(a) + Number(b);\n      }, 0);\n    });\n    if (axis === 0) {\n      return new series_1.default(sumArr, {\n        index: __spreadArray([], this.columns, true)\n      });\n    } else {\n      return new series_1.default(sumArr, {\n        index: __spreadArray([], this.index, true)\n      });\n    }\n  };\n  DataFrame.prototype.pctChange = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: pctChange operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    if (other === 0) {\n      return this;\n    }\n    if (typeof other === \"number\") {\n      var origDF = this.copy();\n      if (axis === 0) {\n        origDF = origDF.T;\n      }\n      var originalTensor = origDF.tensor.clone();\n      var unit = new Array(originalTensor.shape[originalTensor.rank - 1]).fill(NaN);\n      var pctArray = originalTensor.arraySync();\n      if (other > 0) {\n        for (var i = 0; i < other; i++) {\n          pctArray.unshift(unit);\n          pctArray.pop();\n        }\n      } else if (other < 0) {\n        for (var i = 0; i > other; i--) {\n          pctArray.push(unit);\n          pctArray.shift();\n        }\n      }\n      var pctTensor = tensorflowlib_1.default.tensor2d(pctArray, originalTensor.shape);\n      var pctDF = this.$MathOps([originalTensor, pctTensor], \"divNoNan\", inplace).sub(1);\n      if (axis === 0) {\n        return pctDF.T;\n      }\n      return pctDF;\n    }\n    if (other instanceof DataFrame || other instanceof series_1.default) {\n      var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n      var pctDF = this.$MathOps(tensors, \"divNoNan\", inplace).sub(1);\n      return pctDF;\n    }\n  };\n  DataFrame.prototype.diff = function (other, options) {\n    var _a = __assign({\n        inplace: false,\n        axis: 1\n      }, options),\n      inplace = _a.inplace,\n      axis = _a.axis;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: diff operation is not supported for string dtypes\");\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    if (other === 0) {\n      return this;\n    }\n    if (typeof other === \"number\") {\n      var origDF = this.copy();\n      if (axis === 0) {\n        origDF = origDF.T;\n      }\n      var originalTensor = origDF.tensor.clone();\n      var unit = new Array(originalTensor.shape[originalTensor.rank - 1]).fill(NaN);\n      var diffArray = originalTensor.arraySync();\n      if (other > 0) {\n        for (var i = 0; i < other; i++) {\n          diffArray.unshift(unit);\n          diffArray.pop();\n        }\n      } else if (other < 0) {\n        for (var i = 0; i > other; i--) {\n          diffArray.push(unit);\n          diffArray.shift();\n        }\n      }\n      var diffTensor = tensorflowlib_1.default.tensor2d(diffArray, originalTensor.shape);\n      var diffDF = this.$MathOps([originalTensor, diffTensor], \"sub\", inplace);\n      if (axis === 0) {\n        return diffDF.T;\n      }\n      return diffDF;\n    }\n    if (other instanceof DataFrame || other instanceof series_1.default) {\n      var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n      return this.$MathOps(tensors, \"sub\", inplace);\n    }\n  };\n  DataFrame.prototype.abs = function (options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    var newData = this.values.map(function (arr) {\n      return arr.map(function (val) {\n        return Math.abs(val);\n      });\n    });\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  DataFrame.prototype.round = function (dp, options) {\n    if (dp === void 0) {\n      dp = 1;\n    }\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n      throw Error(\"TypeError: round operation is not supported for string dtypes\");\n    }\n    if (typeof dp !== \"number\") {\n      throw Error(\"ParamError: dp must be a number\");\n    }\n    var newData = utils.round(this.values, dp, false);\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  DataFrame.prototype.cumProd = function (options) {\n    var _a = __assign({\n        axis: 1,\n        inplace: false\n      }, options),\n      axis = _a.axis,\n      inplace = _a.inplace;\n    return this.cumOps(\"prod\", axis, inplace);\n  };\n  DataFrame.prototype.cumSum = function (options) {\n    var _a = __assign({\n        axis: 1,\n        inplace: false\n      }, options),\n      axis = _a.axis,\n      inplace = _a.inplace;\n    return this.cumOps(\"sum\", axis, inplace);\n  };\n  DataFrame.prototype.cumMin = function (options) {\n    var _a = __assign({\n        axis: 1,\n        inplace: false\n      }, options),\n      axis = _a.axis,\n      inplace = _a.inplace;\n    return this.cumOps(\"min\", axis, inplace);\n  };\n  DataFrame.prototype.cumMax = function (options) {\n    var _a = __assign({\n        axis: 1,\n        inplace: false\n      }, options),\n      axis = _a.axis,\n      inplace = _a.inplace;\n    return this.cumOps(\"max\", axis, inplace);\n  };\n  DataFrame.prototype.cumOps = function (ops, axis, inplace) {\n    if (this.dtypes.includes(\"string\")) errors_1.default.throwStringDtypeOperationError(ops);\n    var result = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var newData = result.map(function (sData) {\n      var tempval = sData[0];\n      var data = [tempval];\n      for (var i = 1; i < sData.length; i++) {\n        var currVal = sData[i];\n        switch (ops) {\n          case \"max\":\n            if (currVal > tempval) {\n              data.push(currVal);\n              tempval = currVal;\n            } else {\n              data.push(tempval);\n            }\n            break;\n          case \"min\":\n            if (currVal < tempval) {\n              data.push(currVal);\n              tempval = currVal;\n            } else {\n              data.push(tempval);\n            }\n            break;\n          case \"sum\":\n            tempval = tempval + currVal;\n            data.push(tempval);\n            break;\n          case \"prod\":\n            tempval = tempval * currVal;\n            data.push(tempval);\n            break;\n        }\n      }\n      return data;\n    });\n    if (axis === 0) {\n      newData = utils.transposeArray(newData);\n    }\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  /**\n   * Generate descriptive statistics for all numeric columns.\n   * Descriptive statistics include those that summarize the central tendency,\n   * dispersion and shape of a datasetâ€™s distribution, excluding NaN values.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.describe().print()\n   * ```\n   */\n  DataFrame.prototype.describe = function () {\n    var _this = this;\n    var numericColumnNames = this.columns.filter(function (name) {\n      return _this.$getColumnDtype(name) !== \"string\";\n    });\n    var index = [\"count\", \"mean\", \"std\", \"min\", \"median\", \"max\", \"variance\"];\n    var statsObject = {};\n    for (var i = 0; i < numericColumnNames.length; i++) {\n      var colName = numericColumnNames[i];\n      var $count = this.$getColumnData(colName).count();\n      var $mean = (0, mathjs_1.mean)(this.$getColumnData(colName, false));\n      var $std = (0, mathjs_1.std)(this.$getColumnData(colName, false));\n      var $min = this.$getColumnData(colName).min();\n      var $median = (0, mathjs_1.median)(this.$getColumnData(colName, false));\n      var $max = this.$getColumnData(colName).max();\n      var $variance = (0, mathjs_1.variance)(this.$getColumnData(colName, false));\n      var stats = [$count, $mean, $std, $min, $median, $max, $variance];\n      statsObject[colName] = stats;\n    }\n    var df = new DataFrame(statsObject, {\n      index: index\n    });\n    return df;\n  };\n  DataFrame.prototype.dropNa = function (options) {\n    var _a = __assign({\n        axis: 1,\n        inplace: false\n      }, options),\n      axis = _a.axis,\n      inplace = _a.inplace;\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: Axis must be 0 or 1\");\n    }\n    var newIndex = [];\n    if (axis == 1) {\n      var newData = [];\n      var dfValues = this.values;\n      for (var i = 0; i < dfValues.length; i++) {\n        var values = dfValues[i];\n        //@ts-ignore\n        if (!values.includes(NaN) && !values.includes(undefined) && !values.includes(null)) {\n          newData.push(values);\n          newIndex.push(this.index[i]);\n        }\n      }\n      if (inplace) {\n        this.$setValues(newData, false);\n        this.$setIndex(newIndex);\n      } else {\n        return new DataFrame(newData, {\n          index: newIndex,\n          columns: __spreadArray([], this.columns, true),\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n      }\n    } else {\n      var newColumnNames = [];\n      var newDtypes = [];\n      var dfValues = [];\n      if (this.config.isLowMemoryMode) {\n        dfValues = utils.transposeArray(this.values);\n      } else {\n        dfValues = this.$dataIncolumnFormat;\n      }\n      var tempColArr = [];\n      for (var i = 0; i < dfValues.length; i++) {\n        var values = dfValues[i];\n        if (!values.includes(NaN)) {\n          tempColArr.push(values);\n          newColumnNames.push(this.columns[i]);\n          newDtypes.push(this.dtypes[i]);\n        }\n      }\n      var newData = utils.transposeArray(tempColArr);\n      if (inplace) {\n        this.$setValues(newData, false, false);\n        this.$setColumnNames(newColumnNames);\n        this.$setDtypes(newDtypes);\n      } else {\n        return new DataFrame(newData, {\n          index: __spreadArray([], this.index, true),\n          columns: newColumnNames,\n          dtypes: newDtypes,\n          config: __assign({}, this.config)\n        });\n      }\n    }\n  };\n  DataFrame.prototype.addColumn = function (column, values, options) {\n    var _a = __assign({\n        inplace: false,\n        atIndex: this.columns.length\n      }, options),\n      inplace = _a.inplace,\n      atIndex = _a.atIndex;\n    if (typeof atIndex === \"string\") {\n      if (!this.columns.includes(atIndex)) {\n        throw new Error(atIndex + \" not a column\");\n      }\n      atIndex = this.columns.indexOf(atIndex);\n    }\n    if (!column) {\n      throw new Error(\"ParamError: column must be specified\");\n    }\n    if (!values) {\n      throw new Error(\"ParamError: values must be specified\");\n    }\n    var columnIndex = this.$columns.indexOf(column);\n    if (columnIndex === -1) {\n      var colunmValuesToAdd = void 0;\n      if (values instanceof series_1.default) {\n        colunmValuesToAdd = values.values;\n      } else if (Array.isArray(values)) {\n        colunmValuesToAdd = values;\n      } else {\n        throw new Error(\"ParamError: specified value not supported. It must either be an Array or a Series of the same length\");\n      }\n      if (colunmValuesToAdd.length !== this.shape[0]) {\n        errors_1.default.throwColumnLengthError(this, colunmValuesToAdd.length);\n      }\n      var newData = [];\n      var oldValues = this.$data;\n      for (var i = 0; i < oldValues.length; i++) {\n        var innerArr = __spreadArray([], oldValues[i], true);\n        innerArr.splice(atIndex, 0, colunmValuesToAdd[i]);\n        newData.push(innerArr);\n      }\n      if (inplace) {\n        this.$setValues(newData, true, false);\n        var columns = __spreadArray([], this.columns, true);\n        columns.splice(atIndex, 0, column);\n        this.$setColumnNames(columns);\n        this.$setInternalColumnDataProperty(column);\n      } else {\n        var columns = __spreadArray([], this.columns, true);\n        columns.splice(atIndex, 0, column);\n        var df = new DataFrame(newData, {\n          index: __spreadArray([], this.index, true),\n          columns: columns,\n          dtypes: __spreadArray(__spreadArray([], this.dtypes, true), [utils.inferDtype(colunmValuesToAdd)[0]], false),\n          config: __assign({}, this.$config)\n        });\n        return df;\n      }\n    } else {\n      this.$setColumnData(column, values);\n    }\n  };\n  /**\n   * Makes a deep copy of a DataFrame.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const df2 = df.copy()\n   * df2.print()\n   * ```\n   */\n  DataFrame.prototype.copy = function () {\n    var df = new DataFrame(__spreadArray([], this.$data, true), {\n      columns: __spreadArray([], this.columns, true),\n      index: __spreadArray([], this.index, true),\n      dtypes: __spreadArray([], this.dtypes, true),\n      config: __assign({}, this.$config)\n    });\n    return df;\n  };\n  /**\n   * Return a boolean, same-sized object indicating where elements are empty (NaN, undefined, null).\n   * NaN, undefined and null values gets mapped to true, and everything else gets mapped to false.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.isNa().print()\n   * ```\n  */\n  DataFrame.prototype.isNa = function () {\n    var newData = [];\n    for (var i = 0; i < this.values.length; i++) {\n      var valueArr = this.values[i];\n      var tempData = valueArr.map(function (value) {\n        if (utils.isEmpty(value)) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n      newData.push(tempData);\n    }\n    var df = new DataFrame(newData, {\n      index: __spreadArray([], this.index, true),\n      columns: __spreadArray([], this.columns, true),\n      config: __assign({}, this.config)\n    });\n    return df;\n  };\n  DataFrame.prototype.fillNa = function (values, options) {\n    var _this = this;\n    var _a = __assign({\n        inplace: false\n      }, options),\n      columns = _a.columns,\n      inplace = _a.inplace;\n    if (!values && typeof values !== \"boolean\" && typeof values !== \"number\" && typeof values !== \"string\") {\n      throw Error('ParamError: value must be specified');\n    }\n    if (Array.isArray(values)) {\n      if (!Array.isArray(columns)) {\n        throw Error('ParamError: value is an array, hence columns must also be an array of same length');\n      }\n      if (values.length !== columns.length) {\n        throw Error('ParamError: specified column and values must have the same length');\n      }\n      columns.forEach(function (col) {\n        if (!_this.columns.includes(col)) {\n          throw Error(\"ValueError: Specified column \\\"\" + col + \"\\\" must be one of \" + _this.columns);\n        }\n      });\n    }\n    var newData = [];\n    var oldValues = __spreadArray([], this.values, true);\n    if (!columns) {\n      var _loop_2 = function (i) {\n        var valueArr = __spreadArray([], oldValues[i], true);\n        var tempArr = valueArr.map(function (innerVal) {\n          if (utils.isEmpty(innerVal)) {\n            var replaceWith = Array.isArray(values) ? values[i] : values;\n            return replaceWith;\n          } else {\n            return innerVal;\n          }\n        });\n        newData.push(tempArr);\n      };\n      //Fill all columns\n      for (var i = 0; i < oldValues.length; i++) {\n        _loop_2(i);\n      }\n    } else {\n      //Fill specific columns\n      var tempData = __spreadArray([], this.values, true);\n      for (var i = 0; i < tempData.length; i++) {\n        var valueArr = tempData[i];\n        for (var i_1 = 0; i_1 < columns.length; i_1++) {\n          //B\n          var columnIndex = this.columns.indexOf(columns[i_1]);\n          var replaceWith = Array.isArray(values) ? values[i_1] : values;\n          valueArr[columnIndex] = utils.isEmpty(valueArr[columnIndex]) ? replaceWith : valueArr[columnIndex];\n        }\n        newData.push(valueArr);\n      }\n    }\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      var df = new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n      return df;\n    }\n  };\n  DataFrame.prototype.drop = function (options) {\n    var _a = __assign({\n        inplace: false\n      }, options),\n      columns = _a.columns,\n      index = _a.index,\n      inplace = _a.inplace;\n    if (!columns && !index) {\n      throw Error('ParamError: Must specify one of columns or index');\n    }\n    if (columns && index) {\n      throw Error('ParamError: Can only specify one of columns or index');\n    }\n    if (columns) {\n      var columnIndices = [];\n      if (typeof columns === \"string\") {\n        columnIndices.push(this.columns.indexOf(columns));\n      } else if (Array.isArray(columns)) {\n        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n          var column = columns_1[_i];\n          if (this.columns.indexOf(column) === -1) {\n            throw Error(\"ParamError: specified column \\\"\" + column + \"\\\" not found in columns\");\n          }\n          columnIndices.push(this.columns.indexOf(column));\n        }\n      } else {\n        throw Error('ParamError: columns must be an array of column names or a string of column name');\n      }\n      var newRowData = [];\n      var newColumnNames = [];\n      var newDtypes = [];\n      for (var i = 0; i < this.values.length; i++) {\n        var tempInnerArr = [];\n        var innerArr = this.values[i];\n        for (var j = 0; j < innerArr.length; j++) {\n          if (!columnIndices.includes(j)) {\n            tempInnerArr.push(innerArr[j]);\n          }\n        }\n        newRowData.push(tempInnerArr);\n      }\n      for (var i = 0; i < this.columns.length; i++) {\n        var element = this.columns[i];\n        if (!columns.includes(element)) {\n          newColumnNames.push(element);\n          newDtypes.push(this.dtypes[i]);\n        }\n      }\n      if (inplace) {\n        this.$setValues(newRowData, true, false);\n        this.$setColumnNames(newColumnNames);\n      } else {\n        var df = new DataFrame(newRowData, {\n          index: __spreadArray([], this.index, true),\n          columns: newColumnNames,\n          dtypes: newDtypes,\n          config: __assign({}, this.config)\n        });\n        return df;\n      }\n    }\n    if (index) {\n      var rowIndices = [];\n      if (typeof index === \"string\" || typeof index === \"number\" || typeof index === \"boolean\") {\n        rowIndices.push(this.index.indexOf(index));\n      } else if (Array.isArray(index)) {\n        for (var _b = 0, index_1 = index; _b < index_1.length; _b++) {\n          var indx = index_1[_b];\n          if (this.index.indexOf(indx) === -1) {\n            throw Error(\"ParamError: specified index \\\"\" + indx + \"\\\" not found in indices\");\n          }\n          rowIndices.push(this.index.indexOf(indx));\n        }\n      } else {\n        throw Error('ParamError: index must be an array of indices or a scalar index');\n      }\n      var newRowData = [];\n      var newIndex = [];\n      for (var i = 0; i < this.values.length; i++) {\n        var innerArr = this.values[i];\n        if (!rowIndices.includes(i)) {\n          newRowData.push(innerArr);\n        }\n      }\n      for (var i = 0; i < this.index.length; i++) {\n        var indx = this.index[i];\n        if (!index.includes(indx)) {\n          newIndex.push(indx);\n        }\n      }\n      if (inplace) {\n        this.$setValues(newRowData, false);\n        this.$setIndex(newIndex);\n      } else {\n        var df = new DataFrame(newRowData, {\n          index: newIndex,\n          columns: __spreadArray([], this.columns, true),\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n        return df;\n      }\n    }\n  };\n  DataFrame.prototype.sortValues = function (column, options) {\n    var _a = __assign({\n        ascending: true,\n        inplace: false\n      }, options),\n      ascending = _a.ascending,\n      inplace = _a.inplace;\n    if (!column) {\n      throw Error(\"ParamError: must specify a column to sort by\");\n    }\n    if (this.columns.indexOf(column) === -1) {\n      throw Error(\"ParamError: specified column \\\"\" + column + \"\\\" not found in columns\");\n    }\n    var columnValues = this.$getColumnData(column, false);\n    var index = __spreadArray([], this.index, true);\n    var objToSort = columnValues.map(function (value, i) {\n      return {\n        index: index[i],\n        value: value\n      };\n    });\n    var sortedObjectArr = utils.sortObj(objToSort, ascending);\n    var sortedIndex = sortedObjectArr.map(function (obj) {\n      return obj.index;\n    });\n    var newDf = (0, indexing_1._loc)({\n      ndFrame: this,\n      rows: sortedIndex\n    });\n    if (inplace) {\n      this.$setValues(newDf.values);\n      this.$setIndex(newDf.index);\n    } else {\n      return newDf;\n    }\n  };\n  DataFrame.prototype.setIndex = function (options) {\n    var _a = __assign({\n        drop: false,\n        inplace: false\n      }, options),\n      index = _a.index,\n      column = _a.column,\n      drop = _a.drop,\n      inplace = _a.inplace;\n    if (!index && !column) {\n      throw new Error(\"ParamError: must specify either index or column\");\n    }\n    var newIndex = [];\n    if (index) {\n      if (!Array.isArray(index)) {\n        throw Error(\"ParamError: index must be an array\");\n      }\n      if (index.length !== this.values.length) {\n        throw Error(\"ParamError: index must be the same length as the number of rows\");\n      }\n      newIndex = index;\n    }\n    if (column) {\n      if (this.columns.indexOf(column) === -1) {\n        throw Error(\"ParamError: column not found in column names\");\n      }\n      newIndex = this.$getColumnData(column, false);\n    }\n    if (drop) {\n      var dfDropped = this.drop({\n        columns: [column]\n      });\n      var newData = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.values;\n      var newColumns = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.columns;\n      var newDtypes = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.dtypes;\n      if (inplace) {\n        this.$setValues(newData, true, false);\n        this.$setIndex(newIndex);\n        this.$setColumnNames(newColumns);\n      } else {\n        var df = new DataFrame(newData, {\n          index: newIndex,\n          columns: newColumns,\n          dtypes: newDtypes,\n          config: __assign({}, this.config)\n        });\n        return df;\n      }\n    } else {\n      if (inplace) {\n        this.$setIndex(newIndex);\n      } else {\n        var df = new DataFrame(this.values, {\n          index: newIndex,\n          columns: __spreadArray([], this.columns, true),\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n        return df;\n      }\n    }\n  };\n  DataFrame.prototype.resetIndex = function (options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    if (inplace) {\n      this.$resetIndex();\n    } else {\n      var df = new DataFrame(this.values, {\n        index: this.index.map(function (_, i) {\n          return i;\n        }),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n      return df;\n    }\n  };\n  /**\n   * Apply a function along an axis of the DataFrame. To apply a function element-wise, use `applyMap`.\n   * Objects passed to the function are Series values whose\n   * index is either the DataFrameâ€™s index (axis=0) or the DataFrameâ€™s columns (axis=1)\n   * @param callable Function to apply to each column or row.\n   * @param options.axis 0 or 1. If 0, apply \"callable\" column-wise, else apply row-wise\n   *\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const df2 = df.apply(Math.sqrt, { axis: 0 })\n   * df2.print()\n   * ```\n  */\n  DataFrame.prototype.apply = function (callable, options) {\n    var axis = __assign({\n      axis: 1\n    }, options).axis;\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: axis must be 0 or 1\");\n    }\n    var valuesForFunc = this.$getDataByAxisWithMissingValuesRemoved(axis);\n    var result = valuesForFunc.map(function (row) {\n      return callable(row);\n    });\n    if (axis === 0) {\n      if (utils.is1DArray(result)) {\n        return new series_1.default(result, {\n          index: __spreadArray([], this.columns, true)\n        });\n      } else {\n        return new DataFrame(result, {\n          index: __spreadArray([], this.columns, true),\n          columns: __spreadArray([], this.columns, true),\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n      }\n    } else {\n      if (utils.is1DArray(result)) {\n        return new series_1.default(result, {\n          index: __spreadArray([], this.index, true)\n        });\n      } else {\n        return new DataFrame(result, {\n          index: __spreadArray([], this.index, true),\n          columns: __spreadArray([], this.columns, true),\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n      }\n    }\n  };\n  DataFrame.prototype.applyMap = function (callable, options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    var newData = this.values.map(function (row) {\n      var tempData = row.map(function (val) {\n        return callable(val);\n      });\n      return tempData;\n    });\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  /**\n   * Returns the specified column data as a Series object.\n   * @param column The name of the column to return\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * const sf = df.column('A')\n   * sf.print()\n   * ```\n   *\n  */\n  DataFrame.prototype.column = function (column) {\n    return this.$getColumnData(column);\n  };\n  /**\n   * Return a subset of the DataFrame based on the column dtypes.\n   * @param include An array of dtypes or strings to be included.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C']})\n   * const df2 = df.selectDtypes(['float32'])\n   * df2.print()\n   * ```\n   *\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C']})\n   * const df2 = df.selectDtypes(['float32', 'int32'])\n   * df2.print()\n   * ```\n   *\n  */\n  DataFrame.prototype.selectDtypes = function (include) {\n    var supportedDtypes = [\"float32\", \"int32\", \"string\", \"boolean\", 'undefined'];\n    if (Array.isArray(include) === false) {\n      throw Error(\"ParamError: include must be an array\");\n    }\n    include.forEach(function (dtype) {\n      if (supportedDtypes.indexOf(dtype) === -1) {\n        throw Error(\"ParamError: include must be an array of valid dtypes\");\n      }\n    });\n    var newColumnNames = [];\n    for (var i = 0; i < this.dtypes.length; i++) {\n      if (include.includes(this.dtypes[i])) {\n        newColumnNames.push(this.columns[i]);\n      }\n    }\n    return this.loc({\n      columns: newColumnNames\n    });\n  };\n  DataFrame.prototype.transpose = function (options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    var newData = utils.transposeArray(this.values);\n    var newColNames = __spreadArray([], this.index.map(function (i) {\n      return i.toString();\n    }), true);\n    if (inplace) {\n      this.$setValues(newData, false, false);\n      this.$setIndex(__spreadArray([], this.columns, true));\n      this.$setColumnNames(newColNames);\n    } else {\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.columns, true),\n        columns: newColNames,\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  Object.defineProperty(DataFrame.prototype, \"T\", {\n    /**\n     * Returns the Transpose of the DataFrame. Similar to `transpose`.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const df2 = df.T()\n     * df2.print()\n     * ```\n    **/\n    get: function () {\n      var newData = utils.transposeArray(this.values);\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.columns, true),\n        columns: __spreadArray([], this.index.map(function (i) {\n          return i.toString();\n        }), true),\n        config: __assign({}, this.config)\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DataFrame.prototype.replace = function (oldValue, newValue, options) {\n    var _this = this;\n    var _a = __assign({\n        inplace: false\n      }, options),\n      columns = _a.columns,\n      inplace = _a.inplace;\n    if (!oldValue && typeof oldValue !== 'boolean') {\n      throw Error(\"Params Error: Must specify param 'oldValue' to replace\");\n    }\n    if (!newValue && typeof newValue !== 'boolean') {\n      throw Error(\"Params Error: Must specify param 'newValue' to replace with\");\n    }\n    var newData = [];\n    if (columns) {\n      if (!Array.isArray(columns)) {\n        throw Error(\"Params Error: column must be an array of column(s)\");\n      }\n      var columnIndex_1 = [];\n      columns.forEach(function (column) {\n        var _indx = _this.columns.indexOf(column);\n        if (_indx === -1) {\n          throw Error(\"Params Error: column not found in columns\");\n        }\n        columnIndex_1.push(_indx);\n      });\n      newData = this.values.map(function (_a) {\n        var row = _a.slice(0);\n        for (var _i = 0, columnIndex_2 = columnIndex_1; _i < columnIndex_2.length; _i++) {\n          var colIndx = columnIndex_2[_i];\n          if (row[colIndx] === oldValue) {\n            row[colIndx] = newValue;\n          }\n        }\n        return row;\n      });\n    } else {\n      newData = this.values.map(function (_a) {\n        var row = _a.slice(0);\n        return row.map(function (cell) {\n          if (cell === oldValue) {\n            return newValue;\n          } else {\n            return cell;\n          }\n        });\n      });\n    }\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  DataFrame.prototype.asType = function (column, dtype, options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    var columnIndex = this.columns.indexOf(column);\n    if (columnIndex === -1) {\n      throw Error(\"Params Error: column not found in columns\");\n    }\n    if (!defaults_1.DATA_TYPES.includes(dtype)) {\n      throw Error(\"dtype \" + dtype + \" not supported. dtype must be one of \" + defaults_1.DATA_TYPES);\n    }\n    var data = this.values;\n    var newData = data.map(function (row) {\n      if (dtype === \"float32\") {\n        row[columnIndex] = Number(row[columnIndex]);\n        return row;\n      } else if (dtype === \"int32\") {\n        row[columnIndex] = parseInt(row[columnIndex]);\n        return row;\n      } else if (dtype === \"string\") {\n        row[columnIndex] = row[columnIndex].toString();\n        return row;\n      } else if (dtype === \"boolean\") {\n        row[columnIndex] = Boolean(row[columnIndex]);\n        return row;\n      }\n    });\n    if (inplace) {\n      this.$setValues(newData);\n    } else {\n      var newDtypes = __spreadArray([], this.dtypes, true);\n      newDtypes[columnIndex] = dtype;\n      return new DataFrame(newData, {\n        index: __spreadArray([], this.index, true),\n        columns: __spreadArray([], this.columns, true),\n        dtypes: newDtypes,\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  /**\n   * Return the number of unique elements in a column, across the specified axis.\n   * To get the values use `.unique()` instead.\n   * @param axis The axis to count unique elements across. Defaults to 1\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4], [1, 2], [5, 6]], { columns: ['A', 'B'] })\n   * df.nunique().print()\n   * ```\n   *\n  */\n  DataFrame.prototype.nUnique = function (axis) {\n    if (axis === void 0) {\n      axis = 1;\n    }\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: axis must be 0 or 1\");\n    }\n    var data = this.$getDataArraysByAxis(axis);\n    var newData = data.map(function (row) {\n      return new Set(row).size;\n    });\n    if (axis === 0) {\n      return new series_1.default(newData, {\n        index: __spreadArray([], this.columns, true),\n        dtypes: [\"int32\"]\n      });\n    } else {\n      return new series_1.default(newData, {\n        index: __spreadArray([], this.index, true),\n        dtypes: [\"int32\"]\n      });\n    }\n  };\n  DataFrame.prototype.rename = function (mapper, options) {\n    var _a = __assign({\n        axis: 1,\n        inplace: false\n      }, options),\n      axis = _a.axis,\n      inplace = _a.inplace;\n    if ([0, 1].indexOf(axis) === -1) {\n      throw Error(\"ParamError: axis must be 0 or 1\");\n    }\n    if (axis === 1) {\n      var colsAdded_2 = [];\n      var newColumns = this.columns.map(function (col) {\n        if (mapper[col] !== undefined) {\n          var newCol = \"\" + mapper[col];\n          colsAdded_2.push(newCol);\n          return newCol;\n        } else {\n          return col;\n        }\n      });\n      if (inplace) {\n        this.$setColumnNames(newColumns);\n        for (var _i = 0, colsAdded_1 = colsAdded_2; _i < colsAdded_1.length; _i++) {\n          var col = colsAdded_1[_i];\n          this.$setInternalColumnDataProperty(col);\n        }\n      } else {\n        return new DataFrame(__spreadArray([], this.values, true), {\n          index: __spreadArray([], this.index, true),\n          columns: newColumns,\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n      }\n    } else {\n      var newIndex = this.index.map(function (col) {\n        if (mapper[col] !== undefined) {\n          return mapper[col];\n        } else {\n          return col;\n        }\n      });\n      if (inplace) {\n        this.$setIndex(newIndex);\n      } else {\n        return new DataFrame(__spreadArray([], this.values, true), {\n          index: newIndex,\n          columns: __spreadArray([], this.columns, true),\n          dtypes: __spreadArray([], this.dtypes, true),\n          config: __assign({}, this.config)\n        });\n      }\n    }\n  };\n  DataFrame.prototype.sortIndex = function (options) {\n    var _this = this;\n    var _a = __assign({\n        ascending: true,\n        inplace: false\n      }, options),\n      ascending = _a.ascending,\n      inplace = _a.inplace;\n    var indexPosition = utils.range(0, this.index.length - 1);\n    var index = __spreadArray([], this.index, true);\n    var objToSort = index.map(function (idx, i) {\n      return {\n        index: indexPosition[i],\n        value: idx\n      };\n    });\n    var sortedObjectArr = utils.sortObj(objToSort, ascending);\n    var sortedIndex = sortedObjectArr.map(function (obj) {\n      return obj.index;\n    });\n    var newData = sortedIndex.map(function (i) {\n      return _this.values[i];\n    });\n    sortedIndex = sortedIndex.map(function (i) {\n      return index[i];\n    });\n    if (inplace) {\n      this.$setValues(newData);\n      this.$setIndex(sortedIndex);\n    } else {\n      return new DataFrame(newData, {\n        index: sortedIndex,\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  DataFrame.prototype.append = function (newValues, index, options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    if (!newValues) {\n      throw Error(\"ParamError: newValues must be a Series, DataFrame or Array\");\n    }\n    if (!index) {\n      throw Error(\"ParamError: index must be specified\");\n    }\n    var rowsToAdd = [];\n    if (newValues instanceof series_1.default) {\n      if (newValues.values.length !== this.shape[1]) {\n        throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n      }\n      rowsToAdd = [newValues.values];\n    } else if (newValues instanceof DataFrame) {\n      if (newValues.shape[1] !== this.shape[1]) {\n        throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n      }\n      rowsToAdd = newValues.values;\n    } else if (Array.isArray(newValues)) {\n      if (utils.is1DArray(newValues)) {\n        rowsToAdd = [newValues];\n      } else {\n        rowsToAdd = newValues;\n      }\n      if (rowsToAdd[0].length !== this.shape[1]) {\n        throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n      }\n    } else {\n      throw Error(\"ValueError: newValues must be a Series, DataFrame or Array\");\n    }\n    var indexInArrFormat = [];\n    if (!Array.isArray(index)) {\n      indexInArrFormat = [index];\n    } else {\n      indexInArrFormat = index;\n    }\n    if (rowsToAdd.length !== indexInArrFormat.length) {\n      throw Error(\"ParamError: index must contain the same number of values as newValues\");\n    }\n    var newData = __spreadArray([], this.values, true);\n    var newIndex = __spreadArray([], this.index, true);\n    rowsToAdd.forEach(function (row, i) {\n      newData.push(row);\n      newIndex.push(indexInArrFormat[i]);\n    });\n    if (inplace) {\n      this.$setValues(newData);\n      this.$setIndex(newIndex);\n    } else {\n      return new DataFrame(newData, {\n        index: newIndex,\n        columns: __spreadArray([], this.columns, true),\n        dtypes: __spreadArray([], this.dtypes, true),\n        config: __assign({}, this.config)\n      });\n    }\n  };\n  DataFrame.prototype.query = function (condition, options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    if (!condition) {\n      throw new Error(\"ParamError: condition must be specified\");\n    }\n    var result = (0, indexing_1._iloc)({\n      ndFrame: this,\n      rows: condition\n    });\n    if (inplace) {\n      this.$setValues(result.values, false, false);\n      this.$setIndex(result.index);\n    } else {\n      return result;\n    }\n  };\n  Object.defineProperty(DataFrame.prototype, \"ctypes\", {\n    /**\n     * Returns the data types for each column as a Series.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C'] })\n     * df.ctypes().print()\n     * ```\n     */\n    get: function () {\n      return new series_1.default(this.dtypes, {\n        index: this.columns\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DataFrame.prototype.getDummies = function (options) {\n    var inplace = __assign({\n      inplace: false\n    }, options).inplace;\n    var encodedDF = (0, dummy_encoder_1.default)(this, options);\n    if (inplace) {\n      this.$setValues(encodedDF.values, false, false);\n      this.$setColumnNames(encodedDF.columns);\n    } else {\n      return encodedDF;\n    }\n  };\n  /**\n   * Groupby\n   * @params col a list of column\n   * @returns Groupby\n   * @example\n   * let data = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 20, 30, 40 ], [ 39, 89, 78 ] ];\n   * let cols = [ \"A\", \"B\", \"C\" ];\n   * let df = new dfd.DataFrame(data, { columns: cols });\n   * let groupDf = df.groupby([ \"A\" ]);\n   */\n  DataFrame.prototype.groupby = function (col) {\n    var columns = this.columns;\n    var colIndex = col.map(function (val) {\n      return columns.indexOf(val);\n    });\n    var colDtype = this.dtypes;\n    return new groupby_1.default(col, this.values, columns, colDtype, colIndex).group();\n  };\n  /**\n   * Access a single value for a row/column pair by integer position.\n   * Similar to {@link iloc}, in that both provide integer-based lookups.\n   * Use iat if you only need to get or set a single value in a DataFrame.\n   * @param row Row index of the value to access.\n   * @param column Column index of the value to access.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.iat(0, 0) // 1\n   * df.iat(0, 1) // 2\n   * df.iat(1, 0) // 3\n   * ```\n  */\n  DataFrame.prototype.iat = function (row, column) {\n    if (typeof row === 'string' || typeof column === 'string') {\n      throw new Error('ParamError: row and column index must be an integer. Use .at to get a row or column by label.');\n    }\n    return this.values[row][column];\n  };\n  /**\n   * Access a single value for a row/column label pair.\n   * Similar to {@link loc}, in that both provide label-based lookups.\n   * Use at if you only need to get or set a single value in a DataFrame.\n   * @param row Row index of the value to access.\n   * @param column Column label of the value to access.\n   * @example\n   * ```\n   * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n   * df.at(0,'A') // 1\n   * df.at(1, 'A') // 3\n   * df.at(1, 'B') // 4\n   * ```\n  */\n  DataFrame.prototype.at = function (row, column) {\n    if (typeof column !== 'string') {\n      throw new Error('ParamError: column index must be a string. Use .iat to get a row or column by index.');\n    }\n    return this.values[this.index.indexOf(row)][this.columns.indexOf(column)];\n  };\n  /**\n   * Exposes functions for creating charts from a DataFrame.\n   * Charts are created using the Plotly.js library, so all Plotly's configuration parameters are available.\n   * @param divId name of the HTML Div to render the chart in.\n  */\n  DataFrame.prototype.plot = function (divId) {\n    //TODO: Add support for check plot library to use. So we can support other plot library like d3, vega, etc\n    if (utils.isBrowserEnv()) {\n      var plt = new plotting_1.PlotlyLib(this, divId);\n      return plt;\n    } else {\n      throw new Error(\"Not supported in NodeJS\");\n    }\n  };\n  return DataFrame;\n}(generic_1.default);\nexports.default = DataFrame;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","Symbol","iterator","v","op","pop","push","__spreadArray","to","from","pack","l","ar","slice","concat","__importDefault","mod","__esModule","defineProperty","exports","dummy_encoder_1","require","mathjs_1","tensorflowlib_1","defaults_1","groupby_1","errors_1","indexing_1","utils_1","generic_1","table_1","series_1","plotting_1","utils","default","DataFrame","_super","data","options","_this","index","columns","dtypes","config","isSeries","$setInternalColumnDataProperty","column","self","get","$getColumnData","set","arr","$setColumnData","_loop_1","column_1","this_1","returnSeries","columnIndex","indexOf","throwColumnNotFoundError","$dtypes","$index","$config","isLowMemoryMode","values","row","$dataIncolumnFormat","$columns","Error","colunmValuesToAdd","isArray","shape","throwColumnLengthError","$data","inferDtype","$getDataByAxisWithMissingValuesRemoved","axis","oldValues","$getDataArraysByAxis","cleanValues","removeMissingValuesFromArray","dfValues","transposeArray","$frameIsNotCompactibleForArithmeticOperation","str","element","some","$getTensorsForArithmeticOperationByAxis","other","tensor","scalar","tensor2d","transpose","$getColumnDtype","$logicalOps","tensors","operation","newValues","greater","arraySync","less","greaterEqual","lessEqual","equal","notEqual","newData","mapIntegersToBooleans","$MathOps","inplace","tensorResult","add","sub","pow","div","divNoNan","mul","$setValues","iloc","_a","rows","_iloc","ndFrame","loc","_loc","toString","maxRow","getMaxRow","maxColToDisplayInConsole","getTableMaxColInConsole","dataArr","colLen","header","firstFourcolNames","lastThreecolNames","subIdx","firstHalfValues","lastHalfValueS","dfSubset1","dfSubset2","idx","columnsConfig","width","truncate","tableData","table","getTableDisplayConfig","head","copy","tail","sample","num","seed","shuffledIndex","df","array","shuffle","take","toArray","mean","resultArr","map","reduce","a","median","mode","keep","tempMode","min","smallestValue","max","biggestValue","std","var","variance","lt","gt","eq","ne","le","ge","count","sum","sumArr","innerArr","Number","pctChange","origDF","T","originalTensor","clone","unit","rank","fill","NaN","pctArray","unshift","shift","pctTensor","pctDF","diff","diffArray","diffTensor","diffDF","abs","val","Math","round","dp","cumProd","cumOps","cumSum","cumMin","cumMax","includes","throwStringDtypeOperationError","sData","tempval","currVal","describe","numericColumnNames","filter","name","statsObject","colName","$count","$mean","$std","$min","$median","$max","$variance","stats","dropNa","newIndex","undefined","$setIndex","newColumnNames","newDtypes","tempColArr","$setColumnNames","$setDtypes","addColumn","atIndex","splice","isNa","valueArr","tempData","isEmpty","fillNa","forEach","col","_loop_2","tempArr","innerVal","replaceWith","i_1","drop","columnIndices","_i","columns_1","newRowData","tempInnerArr","j","rowIndices","_b","index_1","indx","sortValues","ascending","columnValues","objToSort","sortedObjectArr","sortObj","sortedIndex","obj","newDf","setIndex","dfDropped","newColumns","resetIndex","$resetIndex","callable","valuesForFunc","is1DArray","applyMap","selectDtypes","include","supportedDtypes","dtype","newColNames","enumerable","configurable","replace","oldValue","newValue","columnIndex_1","_indx","columnIndex_2","colIndx","cell","asType","DATA_TYPES","parseInt","Boolean","nUnique","Set","size","rename","mapper","colsAdded_2","newCol","colsAdded_1","sortIndex","indexPosition","range","append","rowsToAdd","indexInArrFormat","query","condition","getDummies","encodedDF","groupby","colIndex","colDtype","group","iat","at","plot","divId","isBrowserEnv","plt","PlotlyLib"],"sources":["/Users/omarbailey/node_modules/danfojs/dist/danfojs-base/core/frame.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar dummy_encoder_1 = __importDefault(require(\"../transformers/encoders/dummy.encoder\"));\nvar mathjs_1 = require(\"mathjs\");\nvar tensorflowlib_1 = __importDefault(require(\"../shared/tensorflowlib\"));\nvar defaults_1 = require(\"../shared/defaults\");\nvar groupby_1 = __importDefault(require(\"../aggregators/groupby\"));\nvar errors_1 = __importDefault(require(\"../shared/errors\"));\nvar indexing_1 = require(\"./indexing\");\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar generic_1 = __importDefault(require(\"./generic\"));\nvar table_1 = require(\"table\");\nvar series_1 = __importDefault(require(\"./series\"));\nvar plotting_1 = require(\"../../danfojs-base/plotting\");\nvar utils = new utils_1.default();\n/**\n * Two-dimensional ndarray with axis labels.\n * The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index.\n * Operations between DataFrame (+, -, /, , *) align values based on their associated index valuesâ€“ they need not be the same length.\n * @param data 2D Array, JSON, Tensor, Block of data.\n * @param options.index Array of numeric or string names for subseting array. If not specified, indexes are auto generated.\n * @param options.columns Array of column names. If not specified, column names are auto generated.\n * @param options.dtypes Array of data types for each the column. If not specified, dtypes are/is inferred.\n * @param options.config General configuration object for extending or setting NDframe behavior.\n */\nvar DataFrame = /** @class */ (function (_super) {\n    __extends(DataFrame, _super);\n    function DataFrame(data, options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        var index = options.index, columns = options.columns, dtypes = options.dtypes, config = options.config;\n        _this = _super.call(this, { data: data, index: index, columns: columns, dtypes: dtypes, config: config, isSeries: false }) || this;\n        _this.$setInternalColumnDataProperty();\n        return _this;\n    }\n    /**\n     * Maps all column names to their corresponding data, and return them as Series objects.\n     * This makes column subsetting works. E.g this can work ==> `df[\"col1\"]`\n     * @param column Optional, a single column name to map\n     */\n    DataFrame.prototype.$setInternalColumnDataProperty = function (column) {\n        var self = this;\n        if (column && typeof column === \"string\") {\n            Object.defineProperty(self, column, {\n                get: function () {\n                    return self.$getColumnData(column);\n                },\n                set: function (arr) {\n                    self.$setColumnData(column, arr);\n                }\n            });\n        }\n        else {\n            var columns = this.columns;\n            var _loop_1 = function (i) {\n                var column_1 = columns[i];\n                Object.defineProperty(this_1, column_1, {\n                    get: function () {\n                        return self.$getColumnData(column_1);\n                    },\n                    set: function (arr) {\n                        self.$setColumnData(column_1, arr);\n                    }\n                });\n            };\n            var this_1 = this;\n            for (var i = 0; i < columns.length; i++) {\n                _loop_1(i);\n            }\n        }\n    };\n    /**\n     * Returns the column data from the DataFrame by column name.\n     * @param column column name to get the column data\n     * @param returnSeries Whether to return the data in series format or not. Defaults to true\n     */\n    DataFrame.prototype.$getColumnData = function (column, returnSeries) {\n        if (returnSeries === void 0) { returnSeries = true; }\n        var columnIndex = this.columns.indexOf(column);\n        if (columnIndex == -1) {\n            errors_1.default.throwColumnNotFoundError(this);\n        }\n        var dtypes = [this.$dtypes[columnIndex]];\n        var index = __spreadArray([], this.$index, true);\n        var columns = [column];\n        var config = __assign({}, this.$config);\n        if (this.$config.isLowMemoryMode) {\n            var data = [];\n            for (var i = 0; i < this.values.length; i++) {\n                var row = this.values[i];\n                data.push(row[columnIndex]);\n            }\n            if (returnSeries) {\n                return new series_1.default(data, {\n                    dtypes: dtypes,\n                    index: index,\n                    columns: columns,\n                    config: config\n                });\n            }\n            else {\n                return data;\n            }\n        }\n        else {\n            var data = this.$dataIncolumnFormat[columnIndex];\n            if (returnSeries) {\n                return new series_1.default(data, {\n                    dtypes: dtypes,\n                    index: index,\n                    columns: columns,\n                    config: config\n                });\n            }\n            else {\n                return data;\n            }\n        }\n    };\n    /**\n     * Updates the internal column data via column name.\n     * @param column The name of the column to update.\n     * @param arr The new column data\n     */\n    DataFrame.prototype.$setColumnData = function (column, arr) {\n        var columnIndex = this.$columns.indexOf(column);\n        if (columnIndex == -1) {\n            throw new Error(\"ParamError: column \" + column + \" not found in \" + this.$columns + \". If you need to add a new column, use the df.addColumn method. \");\n        }\n        var colunmValuesToAdd;\n        if (arr instanceof series_1.default) {\n            colunmValuesToAdd = arr.values;\n        }\n        else if (Array.isArray(arr)) {\n            colunmValuesToAdd = arr;\n        }\n        else {\n            throw new Error(\"ParamError: specified value not supported. It must either be an Array or a Series of the same length\");\n        }\n        if (colunmValuesToAdd.length !== this.shape[0]) {\n            errors_1.default.throwColumnLengthError(this, colunmValuesToAdd.length);\n        }\n        if (this.$config.isLowMemoryMode) {\n            //Update row ($data) array\n            for (var i = 0; i < this.$data.length; i++) {\n                this.$data[i][columnIndex] = colunmValuesToAdd[i];\n            }\n            //Update the dtypes\n            this.$dtypes[columnIndex] = utils.inferDtype(colunmValuesToAdd)[0];\n        }\n        else {\n            //Update row ($data) array\n            for (var i = 0; i < this.values.length; i++) {\n                this.$data[i][columnIndex] = colunmValuesToAdd[i];\n            }\n            //Update column ($dataIncolumnFormat) array since it's available in object\n            this.$dataIncolumnFormat[columnIndex] = arr;\n            //Update the dtypes\n            this.$dtypes[columnIndex] = utils.inferDtype(colunmValuesToAdd)[0];\n        }\n    };\n    /**\n     * Return data with missing values removed from a specified axis\n     * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n    */\n    DataFrame.prototype.$getDataByAxisWithMissingValuesRemoved = function (axis) {\n        var oldValues = this.$getDataArraysByAxis(axis);\n        var cleanValues = [];\n        for (var i = 0; i < oldValues.length; i++) {\n            var values = oldValues[i];\n            cleanValues.push(utils.removeMissingValuesFromArray(values));\n        }\n        return cleanValues;\n    };\n    /**\n     * Return data aligned to the specified axis. Transposes the array if needed.\n     * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n    */\n    DataFrame.prototype.$getDataArraysByAxis = function (axis) {\n        if (axis === 1) {\n            return this.values;\n        }\n        else {\n            var dfValues = void 0;\n            if (this.config.isLowMemoryMode) {\n                dfValues = utils.transposeArray(this.values);\n            }\n            else {\n                dfValues = this.$dataIncolumnFormat;\n            }\n            return dfValues;\n        }\n    };\n    /*\n    * checks if DataFrame is compactible for arithmetic operation\n    * compatible Dataframe must have only numerical dtypes\n    **/\n    DataFrame.prototype.$frameIsNotCompactibleForArithmeticOperation = function () {\n        var dtypes = this.dtypes;\n        var str = function (element) { return element == \"string\"; };\n        return dtypes.some(str);\n    };\n    /**\n     * Return Tensors in the right axis for math operations.\n     * @param other DataFrame or Series or number or array\n     * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n     * */\n    DataFrame.prototype.$getTensorsForArithmeticOperationByAxis = function (other, axis) {\n        if (typeof other === \"number\") {\n            return [this.tensor, tensorflowlib_1.default.scalar(other)];\n        }\n        else if (other instanceof DataFrame) {\n            return [this.tensor, other.tensor];\n        }\n        else if (other instanceof series_1.default) {\n            if (axis === 0) {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other.values, [other.shape[0], 1])];\n            }\n            else {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other.values, [other.shape[0], 1]).transpose()];\n            }\n        }\n        else if (Array.isArray(other)) {\n            if (axis === 0) {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other, [other.length, 1])];\n            }\n            else {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other, [other.length, 1]).transpose()];\n            }\n        }\n        else {\n            throw new Error(\"ParamError: Invalid type for other parameter. other must be one of Series, DataFrame or number.\");\n        }\n    };\n    /**\n     * Returns the dtype for a given column name\n     * @param column\n     */\n    DataFrame.prototype.$getColumnDtype = function (column) {\n        var columnIndex = this.columns.indexOf(column);\n        if (columnIndex === -1) {\n            throw Error(\"ColumnNameError: Column \\\"\" + column + \"\\\" does not exist\");\n        }\n        return this.dtypes[columnIndex];\n    };\n    DataFrame.prototype.$logicalOps = function (tensors, operation) {\n        var newValues = [];\n        switch (operation) {\n            case 'gt':\n                newValues = tensors[0].greater(tensors[1]).arraySync();\n                break;\n            case 'lt':\n                newValues = tensors[0].less(tensors[1]).arraySync();\n                break;\n            case 'ge':\n                newValues = tensors[0].greaterEqual(tensors[1]).arraySync();\n                break;\n            case 'le':\n                newValues = tensors[0].lessEqual(tensors[1]).arraySync();\n                break;\n            case 'eq':\n                newValues = tensors[0].equal(tensors[1]).arraySync();\n                break;\n            case 'ne':\n                newValues = tensors[0].notEqual(tensors[1]).arraySync();\n                break;\n        }\n        var newData = utils.mapIntegersToBooleans(newValues, 2);\n        return new DataFrame(newData, {\n            index: __spreadArray([], this.index, true),\n            columns: __spreadArray([], this.columns, true),\n            dtypes: __spreadArray([], this.dtypes, true),\n            config: __assign({}, this.config)\n        });\n    };\n    DataFrame.prototype.$MathOps = function (tensors, operation, inplace) {\n        var tensorResult;\n        switch (operation) {\n            case 'add':\n                tensorResult = tensors[0].add(tensors[1]);\n                break;\n            case 'sub':\n                tensorResult = tensors[0].sub(tensors[1]);\n                break;\n            case 'pow':\n                tensorResult = tensors[0].pow(tensors[1]);\n                break;\n            case 'div':\n                tensorResult = tensors[0].div(tensors[1]);\n                break;\n            case 'divNoNan':\n                tensorResult = tensors[0].divNoNan(tensors[1]);\n                break;\n            case 'mul':\n                tensorResult = tensors[0].mul(tensors[1]);\n                break;\n            case 'mod':\n                tensorResult = tensors[0].mod(tensors[1]);\n                break;\n        }\n        if (inplace) {\n            var newData = tensorResult === null || tensorResult === void 0 ? void 0 : tensorResult.arraySync();\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(tensorResult, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n    * Purely integer-location based indexing for selection by position.\n    * ``.iloc`` is primarily integer position based (from ``0`` to\n    * ``length-1`` of the axis), but may also be used with a boolean array.\n    *\n    * @param rows Array of row indexes\n    * @param columns Array of column indexes\n    *\n    * Allowed inputs are in rows and columns params are:\n    *\n    * - An array of single integer, e.g. ``[5]``.\n    * - A list or array of integers, e.g. ``[4, 3, 0]``.\n    * - A slice array string with ints, e.g. ``[\"1:7\"]``.\n    * - A boolean array.\n    * - A ``callable`` function with one argument (the calling Series or\n    * DataFrame) and that returns valid output for indexing (one of the above).\n    * This is useful in method chains, when you don't have a reference to the\n    * calling object, but would like to base your selection on some value.\n    *\n    * ``.iloc`` will raise ``IndexError`` if a requested indexer is\n    * out-of-bounds.\n    *\n    * @example\n    * ```\n    * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n    * const df2 = df.iloc({ rows: [1], columns: [\"A\"] })\n    * ```\n    */\n    DataFrame.prototype.iloc = function (_a) {\n        var rows = _a.rows, columns = _a.columns;\n        return (0, indexing_1._iloc)({ ndFrame: this, rows: rows, columns: columns });\n    };\n    /**\n     * Access a group of rows and columns by label(s) or a boolean array.\n     * ``loc`` is primarily label based, but may also be used with a boolean array.\n     *\n     * @param rows Array of row indexes\n     * @param columns Array of column indexes\n     *\n     * Allowed inputs are:\n     *\n     * - A single label, e.g. ``[\"5\"]`` or ``['a']``, (note that ``5`` is interpreted as a\n     *   *label* of the index, and **never** as an integer position along the index).\n     *\n     * - A list or array of labels, e.g. ``['a', 'b', 'c']``.\n     *\n     * - A slice object with labels, e.g. ``[\"a:f\"]``. Note that start and the stop are included\n     *\n     * - A boolean array of the same length as the axis being sliced,\n     * e.g. ``[True, False, True]``.\n     *\n     * - A ``callable`` function with one argument (the calling Series or\n     * DataFrame) and that returns valid output for indexing (one of the above)\n    * @example\n    * ```\n    * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n    * const df2 = df.loc({ rows: [1], columns: [\"A\"] })\n    * ```\n    */\n    DataFrame.prototype.loc = function (_a) {\n        var rows = _a.rows, columns = _a.columns;\n        return (0, indexing_1._loc)({ ndFrame: this, rows: rows, columns: columns });\n    };\n    /**\n     * Prints DataFrame to console as a formatted grid of row and columns.\n    */\n    DataFrame.prototype.toString = function () {\n        var maxRow = this.config.getMaxRow;\n        var maxColToDisplayInConsole = this.config.getTableMaxColInConsole;\n        // let data;\n        var dataArr = [];\n        var colLen = this.columns.length;\n        var header = [];\n        if (colLen > maxColToDisplayInConsole) {\n            //truncate displayed columns to fit in the console\n            var firstFourcolNames = this.columns.slice(0, 4);\n            var lastThreecolNames = this.columns.slice(colLen - 3);\n            //join columns with truncate ellipse in the middle\n            header = __spreadArray(__spreadArray(__spreadArray([\"\"], firstFourcolNames, true), [\"...\"], false), lastThreecolNames, true);\n            var subIdx = void 0;\n            var firstHalfValues = void 0;\n            var lastHalfValueS = void 0;\n            if (this.values.length > maxRow) {\n                //slice Object to show [max_rows]\n                var dfSubset1 = this.iloc({\n                    rows: [\"0:\" + maxRow],\n                    columns: [\"0:4\"]\n                });\n                var dfSubset2 = this.iloc({\n                    rows: [\"0:\" + maxRow],\n                    columns: [colLen - 3 + \":\"]\n                });\n                subIdx = this.index.slice(0, maxRow);\n                firstHalfValues = dfSubset1.values;\n                lastHalfValueS = dfSubset2.values;\n            }\n            else {\n                var dfSubset1 = this.iloc({ columns: [\"0:4\"] });\n                var dfSubset2 = this.iloc({ columns: [colLen - 3 + \":\"] });\n                subIdx = this.index.slice(0, maxRow);\n                firstHalfValues = dfSubset1.values;\n                lastHalfValueS = dfSubset2.values;\n            }\n            // merge subset \n            for (var i = 0; i < subIdx.length; i++) {\n                var idx = subIdx[i];\n                var row = __spreadArray(__spreadArray(__spreadArray([idx], firstHalfValues[i], true), [\"...\"], false), lastHalfValueS[i], true);\n                dataArr.push(row);\n            }\n        }\n        else {\n            //display all columns\n            header = __spreadArray([\"\"], this.columns, true);\n            var subIdx = void 0;\n            var values = void 0;\n            if (this.values.length > maxRow) {\n                //slice Object to show a max of [max_rows]\n                var data = this.iloc({ rows: [\"0:\" + maxRow] });\n                subIdx = data.index;\n                values = data.values;\n            }\n            else {\n                values = this.values;\n                subIdx = this.index;\n            }\n            // merge subset \n            for (var i = 0; i < subIdx.length; i++) {\n                var idx = subIdx[i];\n                var row = __spreadArray([idx], values[i], true);\n                dataArr.push(row);\n            }\n        }\n        var columnsConfig = {};\n        columnsConfig[0] = { width: 10 }; //set column width for index column\n        for (var index = 1; index < header.length; index++) {\n            columnsConfig[index] = { width: 17, truncate: 16 };\n        }\n        var tableData = __spreadArray([header], dataArr, true); //Adds the column names to values before printing\n        return (0, table_1.table)(tableData, __assign({ columns: columnsConfig }, this.config.getTableDisplayConfig));\n    };\n    /**\n      * Returns the first n values in a DataFrame\n      * @param rows The number of rows to return\n      * @example\n      * ```\n      * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n      * const df2 = df.head(1)\n      * ```\n    */\n    DataFrame.prototype.head = function (rows) {\n        if (rows === void 0) { rows = 5; }\n        if (rows <= 0) {\n            throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n        }\n        if (this.shape[0] <= rows) {\n            return this.copy();\n        }\n        if (this.shape[0] - rows < 0) {\n            throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n        }\n        return this.iloc({ rows: [\"0:\" + rows] });\n    };\n    /**\n      * Returns the last n values in a DataFrame\n      * @param rows The number of rows to return\n      * @example\n      * ```\n      * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n      * const df2 = df.tail(1)\n      * ```\n    */\n    DataFrame.prototype.tail = function (rows) {\n        if (rows === void 0) { rows = 5; }\n        if (rows <= 0) {\n            throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n        }\n        if (this.shape[0] <= rows) {\n            return this.copy();\n        }\n        if (this.shape[0] - rows < 0) {\n            throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n        }\n        rows = this.shape[0] - rows;\n        return this.iloc({ rows: [rows + \":\"] });\n    };\n    /**\n     * Gets n number of random rows in a dataframe. Sample is reproducible if seed is provided.\n     * @param num The number of rows to return. Default to 5.\n     * @param options.seed An integer specifying the random seed that will be used to create the distribution.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * const df2 = await df.sample(1)\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * const df2 = await df.sample(1, { seed: 1 })\n     * ```\n    */\n    DataFrame.prototype.sample = function (num, options) {\n        if (num === void 0) { num = 5; }\n        return __awaiter(this, void 0, void 0, function () {\n            var seed, shuffledIndex, df;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        seed = __assign({ seed: 1 }, options).seed;\n                        if (num > this.shape[0]) {\n                            throw new Error(\"ParamError: Sample size cannot be bigger than number of rows\");\n                        }\n                        if (num <= 0) {\n                            throw new Error(\"ParamError: Sample size cannot be less than 1\");\n                        }\n                        return [4 /*yield*/, tensorflowlib_1.default.data.array(this.index).shuffle(num, \"\" + seed).take(num).toArray()];\n                    case 1:\n                        shuffledIndex = _a.sent();\n                        df = this.iloc({ rows: shuffledIndex });\n                        return [2 /*return*/, df];\n                }\n            });\n        });\n    };\n    DataFrame.prototype.add = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: add operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"add\", inplace);\n    };\n    DataFrame.prototype.sub = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: sub operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"sub\", inplace);\n    };\n    DataFrame.prototype.mul = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mul operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"mul\", inplace);\n    };\n    DataFrame.prototype.div = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: div operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"div\", inplace);\n    };\n    DataFrame.prototype.divNoNan = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: div operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"divNoNan\", inplace);\n    };\n    DataFrame.prototype.pow = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: pow operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"pow\", inplace);\n    };\n    DataFrame.prototype.mod = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mod operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"mod\", inplace);\n    };\n    /**\n     * Return mean of DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the mean column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * df.mean().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * df.mean({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.mean = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mean operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return arr.reduce(function (a, b) { return a + b; }, 0) / arr.length; });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return median of DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the median column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n     * df.median().print()\n     * ```\n    */\n    DataFrame.prototype.median = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: median operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return (0, mathjs_1.median)(arr); });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return mode of DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the mode column-wise, if 1, row-wise. Defaults to 1\n     * @param options.keep If there are more than one modes, returns the mode at position [keep]. Defaults to 0\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n     * df.mode().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n     * df.mode({ keep: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.mode = function (options) {\n        var _a = __assign({ axis: 1, keep: 0 }, options), axis = _a.axis, keep = _a.keep;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mode operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) {\n            var tempMode = (0, mathjs_1.mode)(arr);\n            if (tempMode.length === 1) {\n                return tempMode[0];\n            }\n            else {\n                return tempMode[keep];\n            }\n        });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return minimum of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the minimum value column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.min().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.min({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.min = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: min operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) {\n            var smallestValue = arr[0];\n            for (var i = 0; i < arr.length; i++) {\n                smallestValue = smallestValue < arr[i] ? smallestValue : arr[i];\n            }\n            return smallestValue;\n        });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return maximum of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the maximum column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.max().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.max({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.max = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: max operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) {\n            var biggestValue = arr[0];\n            for (var i = 0; i < arr.length; i++) {\n                biggestValue = biggestValue > arr[i] ? biggestValue : arr[i];\n            }\n            return biggestValue;\n        });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return standard deviation of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the standard deviation column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.std().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.std({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.std = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: std operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return (0, mathjs_1.std)(arr); });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return variance of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the variance column-wise, if 1, add row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.var().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.var({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.var = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: var operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return (0, mathjs_1.variance)(arr); });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Get Less than of dataframe and other, element-wise (binary operator lt).\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.lt(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.lt([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.lt(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.lt = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: lt operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"lt\");\n    };\n    /**\n     * Returns \"greater than\" of dataframe and other.\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.gt(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.gt([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.gt(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.gt = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: gt operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"gt\");\n    };\n    /**\n     * Returns \"equals to\" of dataframe and other.\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.eq(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.eq([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.eq(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.eq = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: eq operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"eq\");\n    };\n    /**\n     * Returns \"not equal to\" of dataframe and other.\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ne(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ne([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.ne(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.ne = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: ne operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"ne\");\n    };\n    /**\n    * Returns \"less than or equal to\" of dataframe and other.\n    * @param other DataFrame, Series, Array or Scalar number to compare with\n    * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.le(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.le([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.le(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.le = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: le operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"le\");\n    };\n    /**\n    * Returns \"greater than or equal to\" between dataframe and other.\n    * @param other DataFrame, Series, Array or Scalar number to compare with\n    * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ge(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ge([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.ge(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.ge = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: ge operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"ge\");\n    };\n    /**\n     * Return number of non-null elements in a Series\n     * @param options.axis 0 or 1. If 0, count column-wise, if 1, add row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.count().print()\n     * ```\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.count({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.count = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return arr.length; });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return the sum of values across an axis.\n     * @param options.axis 0 or 1. If 0, count column-wise, if 1, add row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.sum().print()\n     * ```\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.sum({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.sum = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var result = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var sumArr = result.map(function (innerArr) {\n            return innerArr.reduce(function (a, b) { return Number(a) + Number(b); }, 0);\n        });\n        if (axis === 0) {\n            return new series_1.default(sumArr, {\n                index: __spreadArray([], this.columns, true)\n            });\n        }\n        else {\n            return new series_1.default(sumArr, {\n                index: __spreadArray([], this.index, true)\n            });\n        }\n    };\n    DataFrame.prototype.pctChange = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: pctChange operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        if (other === 0) {\n            return this;\n        }\n        if (typeof other === \"number\") {\n            var origDF = this.copy();\n            if (axis === 0) {\n                origDF = origDF.T;\n            }\n            var originalTensor = origDF.tensor.clone();\n            var unit = new Array(originalTensor.shape[originalTensor.rank - 1]).fill(NaN);\n            var pctArray = originalTensor.arraySync();\n            if (other > 0) {\n                for (var i = 0; i < other; i++) {\n                    pctArray.unshift(unit);\n                    pctArray.pop();\n                }\n            }\n            else if (other < 0) {\n                for (var i = 0; i > other; i--) {\n                    pctArray.push(unit);\n                    pctArray.shift();\n                }\n            }\n            var pctTensor = tensorflowlib_1.default.tensor2d(pctArray, originalTensor.shape);\n            var pctDF = this.$MathOps([originalTensor, pctTensor], \"divNoNan\", inplace).sub(1);\n            if (axis === 0) {\n                return pctDF.T;\n            }\n            return pctDF;\n        }\n        if (other instanceof DataFrame || other instanceof series_1.default) {\n            var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n            var pctDF = this.$MathOps(tensors, \"divNoNan\", inplace).sub(1);\n            return pctDF;\n        }\n    };\n    DataFrame.prototype.diff = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: diff operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        if (other === 0) {\n            return this;\n        }\n        if (typeof other === \"number\") {\n            var origDF = this.copy();\n            if (axis === 0) {\n                origDF = origDF.T;\n            }\n            var originalTensor = origDF.tensor.clone();\n            var unit = new Array(originalTensor.shape[originalTensor.rank - 1]).fill(NaN);\n            var diffArray = originalTensor.arraySync();\n            if (other > 0) {\n                for (var i = 0; i < other; i++) {\n                    diffArray.unshift(unit);\n                    diffArray.pop();\n                }\n            }\n            else if (other < 0) {\n                for (var i = 0; i > other; i--) {\n                    diffArray.push(unit);\n                    diffArray.shift();\n                }\n            }\n            var diffTensor = tensorflowlib_1.default.tensor2d(diffArray, originalTensor.shape);\n            var diffDF = this.$MathOps([originalTensor, diffTensor], \"sub\", inplace);\n            if (axis === 0) {\n                return diffDF.T;\n            }\n            return diffDF;\n        }\n        if (other instanceof DataFrame || other instanceof series_1.default) {\n            var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n            return this.$MathOps(tensors, \"sub\", inplace);\n        }\n    };\n    DataFrame.prototype.abs = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newData = this.values.map(function (arr) { return arr.map(function (val) { return Math.abs(val); }); });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.round = function (dp, options) {\n        if (dp === void 0) { dp = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: round operation is not supported for string dtypes\");\n        }\n        if (typeof dp !== \"number\") {\n            throw Error(\"ParamError: dp must be a number\");\n        }\n        var newData = utils.round(this.values, dp, false);\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.cumProd = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"prod\", axis, inplace);\n    };\n    DataFrame.prototype.cumSum = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"sum\", axis, inplace);\n    };\n    DataFrame.prototype.cumMin = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"min\", axis, inplace);\n    };\n    DataFrame.prototype.cumMax = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"max\", axis, inplace);\n    };\n    DataFrame.prototype.cumOps = function (ops, axis, inplace) {\n        if (this.dtypes.includes(\"string\"))\n            errors_1.default.throwStringDtypeOperationError(ops);\n        var result = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var newData = result.map(function (sData) {\n            var tempval = sData[0];\n            var data = [tempval];\n            for (var i = 1; i < sData.length; i++) {\n                var currVal = sData[i];\n                switch (ops) {\n                    case \"max\":\n                        if (currVal > tempval) {\n                            data.push(currVal);\n                            tempval = currVal;\n                        }\n                        else {\n                            data.push(tempval);\n                        }\n                        break;\n                    case \"min\":\n                        if (currVal < tempval) {\n                            data.push(currVal);\n                            tempval = currVal;\n                        }\n                        else {\n                            data.push(tempval);\n                        }\n                        break;\n                    case \"sum\":\n                        tempval = tempval + currVal;\n                        data.push(tempval);\n                        break;\n                    case \"prod\":\n                        tempval = tempval * currVal;\n                        data.push(tempval);\n                        break;\n                }\n            }\n            return data;\n        });\n        if (axis === 0) {\n            newData = utils.transposeArray(newData);\n        }\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n     * Generate descriptive statistics for all numeric columns.\n     * Descriptive statistics include those that summarize the central tendency,\n     * dispersion and shape of a datasetâ€™s distribution, excluding NaN values.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.describe().print()\n     * ```\n     */\n    DataFrame.prototype.describe = function () {\n        var _this = this;\n        var numericColumnNames = this.columns.filter(function (name) { return _this.$getColumnDtype(name) !== \"string\"; });\n        var index = [\"count\", \"mean\", \"std\", \"min\", \"median\", \"max\", \"variance\"];\n        var statsObject = {};\n        for (var i = 0; i < numericColumnNames.length; i++) {\n            var colName = numericColumnNames[i];\n            var $count = this.$getColumnData(colName).count();\n            var $mean = (0, mathjs_1.mean)(this.$getColumnData(colName, false));\n            var $std = (0, mathjs_1.std)(this.$getColumnData(colName, false));\n            var $min = this.$getColumnData(colName).min();\n            var $median = (0, mathjs_1.median)(this.$getColumnData(colName, false));\n            var $max = this.$getColumnData(colName).max();\n            var $variance = (0, mathjs_1.variance)(this.$getColumnData(colName, false));\n            var stats = [$count, $mean, $std, $min, $median, $max, $variance];\n            statsObject[colName] = stats;\n        }\n        var df = new DataFrame(statsObject, { index: index });\n        return df;\n    };\n    DataFrame.prototype.dropNa = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newIndex = [];\n        if (axis == 1) {\n            var newData = [];\n            var dfValues = this.values;\n            for (var i = 0; i < dfValues.length; i++) {\n                var values = dfValues[i];\n                //@ts-ignore\n                if (!values.includes(NaN) && !values.includes(undefined) && !values.includes(null)) {\n                    newData.push(values);\n                    newIndex.push(this.index[i]);\n                }\n            }\n            if (inplace) {\n                this.$setValues(newData, false);\n                this.$setIndex(newIndex);\n            }\n            else {\n                return new DataFrame(newData, {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n        else {\n            var newColumnNames = [];\n            var newDtypes = [];\n            var dfValues = [];\n            if (this.config.isLowMemoryMode) {\n                dfValues = utils.transposeArray(this.values);\n            }\n            else {\n                dfValues = this.$dataIncolumnFormat;\n            }\n            var tempColArr = [];\n            for (var i = 0; i < dfValues.length; i++) {\n                var values = dfValues[i];\n                if (!values.includes(NaN)) {\n                    tempColArr.push(values);\n                    newColumnNames.push(this.columns[i]);\n                    newDtypes.push(this.dtypes[i]);\n                }\n            }\n            var newData = utils.transposeArray(tempColArr);\n            if (inplace) {\n                this.$setValues(newData, false, false);\n                this.$setColumnNames(newColumnNames);\n                this.$setDtypes(newDtypes);\n            }\n            else {\n                return new DataFrame(newData, {\n                    index: __spreadArray([], this.index, true),\n                    columns: newColumnNames,\n                    dtypes: newDtypes,\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n    };\n    DataFrame.prototype.addColumn = function (column, values, options) {\n        var _a = __assign({ inplace: false, atIndex: this.columns.length }, options), inplace = _a.inplace, atIndex = _a.atIndex;\n        if (typeof atIndex === \"string\") {\n            if (!(this.columns.includes(atIndex))) {\n                throw new Error(atIndex + \" not a column\");\n            }\n            atIndex = this.columns.indexOf(atIndex);\n        }\n        if (!column) {\n            throw new Error(\"ParamError: column must be specified\");\n        }\n        if (!values) {\n            throw new Error(\"ParamError: values must be specified\");\n        }\n        var columnIndex = this.$columns.indexOf(column);\n        if (columnIndex === -1) {\n            var colunmValuesToAdd = void 0;\n            if (values instanceof series_1.default) {\n                colunmValuesToAdd = values.values;\n            }\n            else if (Array.isArray(values)) {\n                colunmValuesToAdd = values;\n            }\n            else {\n                throw new Error(\"ParamError: specified value not supported. It must either be an Array or a Series of the same length\");\n            }\n            if (colunmValuesToAdd.length !== this.shape[0]) {\n                errors_1.default.throwColumnLengthError(this, colunmValuesToAdd.length);\n            }\n            var newData = [];\n            var oldValues = this.$data;\n            for (var i = 0; i < oldValues.length; i++) {\n                var innerArr = __spreadArray([], oldValues[i], true);\n                innerArr.splice(atIndex, 0, colunmValuesToAdd[i]);\n                newData.push(innerArr);\n            }\n            if (inplace) {\n                this.$setValues(newData, true, false);\n                var columns = __spreadArray([], this.columns, true);\n                columns.splice(atIndex, 0, column);\n                this.$setColumnNames(columns);\n                this.$setInternalColumnDataProperty(column);\n            }\n            else {\n                var columns = __spreadArray([], this.columns, true);\n                columns.splice(atIndex, 0, column);\n                var df = new DataFrame(newData, {\n                    index: __spreadArray([], this.index, true),\n                    columns: columns,\n                    dtypes: __spreadArray(__spreadArray([], this.dtypes, true), [utils.inferDtype(colunmValuesToAdd)[0]], false),\n                    config: __assign({}, this.$config)\n                });\n                return df;\n            }\n        }\n        else {\n            this.$setColumnData(column, values);\n        }\n    };\n    /**\n     * Makes a deep copy of a DataFrame.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const df2 = df.copy()\n     * df2.print()\n     * ```\n     */\n    DataFrame.prototype.copy = function () {\n        var df = new DataFrame(__spreadArray([], this.$data, true), {\n            columns: __spreadArray([], this.columns, true),\n            index: __spreadArray([], this.index, true),\n            dtypes: __spreadArray([], this.dtypes, true),\n            config: __assign({}, this.$config)\n        });\n        return df;\n    };\n    /**\n     * Return a boolean, same-sized object indicating where elements are empty (NaN, undefined, null).\n     * NaN, undefined and null values gets mapped to true, and everything else gets mapped to false.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.isNa().print()\n     * ```\n    */\n    DataFrame.prototype.isNa = function () {\n        var newData = [];\n        for (var i = 0; i < this.values.length; i++) {\n            var valueArr = this.values[i];\n            var tempData = valueArr.map(function (value) {\n                if (utils.isEmpty(value)) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            });\n            newData.push(tempData);\n        }\n        var df = new DataFrame(newData, {\n            index: __spreadArray([], this.index, true),\n            columns: __spreadArray([], this.columns, true),\n            config: __assign({}, this.config)\n        });\n        return df;\n    };\n    DataFrame.prototype.fillNa = function (values, options) {\n        var _this = this;\n        var _a = __assign({ inplace: false }, options), columns = _a.columns, inplace = _a.inplace;\n        if (!values && typeof values !== \"boolean\" && typeof values !== \"number\" && typeof values !== \"string\") {\n            throw Error('ParamError: value must be specified');\n        }\n        if (Array.isArray(values)) {\n            if (!Array.isArray(columns)) {\n                throw Error('ParamError: value is an array, hence columns must also be an array of same length');\n            }\n            if (values.length !== columns.length) {\n                throw Error('ParamError: specified column and values must have the same length');\n            }\n            columns.forEach(function (col) {\n                if (!_this.columns.includes(col)) {\n                    throw Error(\"ValueError: Specified column \\\"\" + col + \"\\\" must be one of \" + _this.columns);\n                }\n            });\n        }\n        var newData = [];\n        var oldValues = __spreadArray([], this.values, true);\n        if (!columns) {\n            var _loop_2 = function (i) {\n                var valueArr = __spreadArray([], oldValues[i], true);\n                var tempArr = valueArr.map(function (innerVal) {\n                    if (utils.isEmpty(innerVal)) {\n                        var replaceWith = Array.isArray(values) ? values[i] : values;\n                        return replaceWith;\n                    }\n                    else {\n                        return innerVal;\n                    }\n                });\n                newData.push(tempArr);\n            };\n            //Fill all columns\n            for (var i = 0; i < oldValues.length; i++) {\n                _loop_2(i);\n            }\n        }\n        else {\n            //Fill specific columns\n            var tempData = __spreadArray([], this.values, true);\n            for (var i = 0; i < tempData.length; i++) {\n                var valueArr = tempData[i];\n                for (var i_1 = 0; i_1 < columns.length; i_1++) { //B\n                    var columnIndex = this.columns.indexOf(columns[i_1]);\n                    var replaceWith = Array.isArray(values) ? values[i_1] : values;\n                    valueArr[columnIndex] = utils.isEmpty(valueArr[columnIndex]) ? replaceWith : valueArr[columnIndex];\n                }\n                newData.push(valueArr);\n            }\n        }\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            var df = new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n            return df;\n        }\n    };\n    DataFrame.prototype.drop = function (options) {\n        var _a = __assign({ inplace: false }, options), columns = _a.columns, index = _a.index, inplace = _a.inplace;\n        if (!columns && !index) {\n            throw Error('ParamError: Must specify one of columns or index');\n        }\n        if (columns && index) {\n            throw Error('ParamError: Can only specify one of columns or index');\n        }\n        if (columns) {\n            var columnIndices = [];\n            if (typeof columns === \"string\") {\n                columnIndices.push(this.columns.indexOf(columns));\n            }\n            else if (Array.isArray(columns)) {\n                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                    var column = columns_1[_i];\n                    if (this.columns.indexOf(column) === -1) {\n                        throw Error(\"ParamError: specified column \\\"\" + column + \"\\\" not found in columns\");\n                    }\n                    columnIndices.push(this.columns.indexOf(column));\n                }\n            }\n            else {\n                throw Error('ParamError: columns must be an array of column names or a string of column name');\n            }\n            var newRowData = [];\n            var newColumnNames = [];\n            var newDtypes = [];\n            for (var i = 0; i < this.values.length; i++) {\n                var tempInnerArr = [];\n                var innerArr = this.values[i];\n                for (var j = 0; j < innerArr.length; j++) {\n                    if (!(columnIndices.includes(j))) {\n                        tempInnerArr.push(innerArr[j]);\n                    }\n                }\n                newRowData.push(tempInnerArr);\n            }\n            for (var i = 0; i < this.columns.length; i++) {\n                var element = this.columns[i];\n                if (!(columns.includes(element))) {\n                    newColumnNames.push(element);\n                    newDtypes.push(this.dtypes[i]);\n                }\n            }\n            if (inplace) {\n                this.$setValues(newRowData, true, false);\n                this.$setColumnNames(newColumnNames);\n            }\n            else {\n                var df = new DataFrame(newRowData, {\n                    index: __spreadArray([], this.index, true),\n                    columns: newColumnNames,\n                    dtypes: newDtypes,\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n        if (index) {\n            var rowIndices = [];\n            if (typeof index === \"string\" || typeof index === \"number\" || typeof index === \"boolean\") {\n                rowIndices.push(this.index.indexOf(index));\n            }\n            else if (Array.isArray(index)) {\n                for (var _b = 0, index_1 = index; _b < index_1.length; _b++) {\n                    var indx = index_1[_b];\n                    if (this.index.indexOf(indx) === -1) {\n                        throw Error(\"ParamError: specified index \\\"\" + indx + \"\\\" not found in indices\");\n                    }\n                    rowIndices.push(this.index.indexOf(indx));\n                }\n            }\n            else {\n                throw Error('ParamError: index must be an array of indices or a scalar index');\n            }\n            var newRowData = [];\n            var newIndex = [];\n            for (var i = 0; i < this.values.length; i++) {\n                var innerArr = this.values[i];\n                if (!(rowIndices.includes(i))) {\n                    newRowData.push(innerArr);\n                }\n            }\n            for (var i = 0; i < this.index.length; i++) {\n                var indx = this.index[i];\n                if (!(index.includes(indx))) {\n                    newIndex.push(indx);\n                }\n            }\n            if (inplace) {\n                this.$setValues(newRowData, false);\n                this.$setIndex(newIndex);\n            }\n            else {\n                var df = new DataFrame(newRowData, {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n    };\n    DataFrame.prototype.sortValues = function (column, options) {\n        var _a = __assign({ ascending: true, inplace: false }, options), ascending = _a.ascending, inplace = _a.inplace;\n        if (!column) {\n            throw Error(\"ParamError: must specify a column to sort by\");\n        }\n        if (this.columns.indexOf(column) === -1) {\n            throw Error(\"ParamError: specified column \\\"\" + column + \"\\\" not found in columns\");\n        }\n        var columnValues = this.$getColumnData(column, false);\n        var index = __spreadArray([], this.index, true);\n        var objToSort = columnValues.map(function (value, i) {\n            return { index: index[i], value: value };\n        });\n        var sortedObjectArr = utils.sortObj(objToSort, ascending);\n        var sortedIndex = sortedObjectArr.map(function (obj) { return obj.index; });\n        var newDf = (0, indexing_1._loc)({ ndFrame: this, rows: sortedIndex });\n        if (inplace) {\n            this.$setValues(newDf.values);\n            this.$setIndex(newDf.index);\n        }\n        else {\n            return newDf;\n        }\n    };\n    DataFrame.prototype.setIndex = function (options) {\n        var _a = __assign({ drop: false, inplace: false }, options), index = _a.index, column = _a.column, drop = _a.drop, inplace = _a.inplace;\n        if (!index && !column) {\n            throw new Error(\"ParamError: must specify either index or column\");\n        }\n        var newIndex = [];\n        if (index) {\n            if (!Array.isArray(index)) {\n                throw Error(\"ParamError: index must be an array\");\n            }\n            if (index.length !== this.values.length) {\n                throw Error(\"ParamError: index must be the same length as the number of rows\");\n            }\n            newIndex = index;\n        }\n        if (column) {\n            if (this.columns.indexOf(column) === -1) {\n                throw Error(\"ParamError: column not found in column names\");\n            }\n            newIndex = this.$getColumnData(column, false);\n        }\n        if (drop) {\n            var dfDropped = this.drop({ columns: [column] });\n            var newData = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.values;\n            var newColumns = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.columns;\n            var newDtypes = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.dtypes;\n            if (inplace) {\n                this.$setValues(newData, true, false);\n                this.$setIndex(newIndex);\n                this.$setColumnNames(newColumns);\n            }\n            else {\n                var df = new DataFrame(newData, {\n                    index: newIndex,\n                    columns: newColumns,\n                    dtypes: newDtypes,\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n        else {\n            if (inplace) {\n                this.$setIndex(newIndex);\n            }\n            else {\n                var df = new DataFrame(this.values, {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n    };\n    DataFrame.prototype.resetIndex = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (inplace) {\n            this.$resetIndex();\n        }\n        else {\n            var df = new DataFrame(this.values, {\n                index: this.index.map(function (_, i) { return i; }),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n            return df;\n        }\n    };\n    /**\n     * Apply a function along an axis of the DataFrame. To apply a function element-wise, use `applyMap`.\n     * Objects passed to the function are Series values whose\n     * index is either the DataFrameâ€™s index (axis=0) or the DataFrameâ€™s columns (axis=1)\n     * @param callable Function to apply to each column or row.\n     * @param options.axis 0 or 1. If 0, apply \"callable\" column-wise, else apply row-wise\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const df2 = df.apply(Math.sqrt, { axis: 0 })\n     * df2.print()\n     * ```\n    */\n    DataFrame.prototype.apply = function (callable, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: axis must be 0 or 1\");\n        }\n        var valuesForFunc = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var result = valuesForFunc.map(function (row) {\n            return callable(row);\n        });\n        if (axis === 0) {\n            if (utils.is1DArray(result)) {\n                return new series_1.default(result, {\n                    index: __spreadArray([], this.columns, true)\n                });\n            }\n            else {\n                return new DataFrame(result, {\n                    index: __spreadArray([], this.columns, true),\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n        else {\n            if (utils.is1DArray(result)) {\n                return new series_1.default(result, {\n                    index: __spreadArray([], this.index, true)\n                });\n            }\n            else {\n                return new DataFrame(result, {\n                    index: __spreadArray([], this.index, true),\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n    };\n    DataFrame.prototype.applyMap = function (callable, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newData = this.values.map(function (row) {\n            var tempData = row.map(function (val) {\n                return callable(val);\n            });\n            return tempData;\n        });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n     * Returns the specified column data as a Series object.\n     * @param column The name of the column to return\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = df.column('A')\n     * sf.print()\n     * ```\n     *\n    */\n    DataFrame.prototype.column = function (column) {\n        return this.$getColumnData(column);\n    };\n    /**\n     * Return a subset of the DataFrame based on the column dtypes.\n     * @param include An array of dtypes or strings to be included.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C']})\n     * const df2 = df.selectDtypes(['float32'])\n     * df2.print()\n     * ```\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C']})\n     * const df2 = df.selectDtypes(['float32', 'int32'])\n     * df2.print()\n     * ```\n     *\n    */\n    DataFrame.prototype.selectDtypes = function (include) {\n        var supportedDtypes = [\"float32\", \"int32\", \"string\", \"boolean\", 'undefined'];\n        if (Array.isArray(include) === false) {\n            throw Error(\"ParamError: include must be an array\");\n        }\n        include.forEach(function (dtype) {\n            if (supportedDtypes.indexOf(dtype) === -1) {\n                throw Error(\"ParamError: include must be an array of valid dtypes\");\n            }\n        });\n        var newColumnNames = [];\n        for (var i = 0; i < this.dtypes.length; i++) {\n            if (include.includes(this.dtypes[i])) {\n                newColumnNames.push(this.columns[i]);\n            }\n        }\n        return this.loc({ columns: newColumnNames });\n    };\n    DataFrame.prototype.transpose = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newData = utils.transposeArray(this.values);\n        var newColNames = __spreadArray([], this.index.map(function (i) { return i.toString(); }), true);\n        if (inplace) {\n            this.$setValues(newData, false, false);\n            this.$setIndex(__spreadArray([], this.columns, true));\n            this.$setColumnNames(newColNames);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.columns, true),\n                columns: newColNames,\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    Object.defineProperty(DataFrame.prototype, \"T\", {\n        /**\n         * Returns the Transpose of the DataFrame. Similar to `transpose`.\n         * @example\n         * ```\n         * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n         * const df2 = df.T()\n         * df2.print()\n         * ```\n        **/\n        get: function () {\n            var newData = utils.transposeArray(this.values);\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.columns, true),\n                columns: __spreadArray([], this.index.map(function (i) { return i.toString(); }), true),\n                config: __assign({}, this.config)\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DataFrame.prototype.replace = function (oldValue, newValue, options) {\n        var _this = this;\n        var _a = __assign({ inplace: false }, options), columns = _a.columns, inplace = _a.inplace;\n        if (!oldValue && typeof oldValue !== 'boolean') {\n            throw Error(\"Params Error: Must specify param 'oldValue' to replace\");\n        }\n        if (!newValue && typeof newValue !== 'boolean') {\n            throw Error(\"Params Error: Must specify param 'newValue' to replace with\");\n        }\n        var newData = [];\n        if (columns) {\n            if (!Array.isArray(columns)) {\n                throw Error(\"Params Error: column must be an array of column(s)\");\n            }\n            var columnIndex_1 = [];\n            columns.forEach(function (column) {\n                var _indx = _this.columns.indexOf(column);\n                if (_indx === -1) {\n                    throw Error(\"Params Error: column not found in columns\");\n                }\n                columnIndex_1.push(_indx);\n            });\n            newData = this.values.map(function (_a) {\n                var row = _a.slice(0);\n                for (var _i = 0, columnIndex_2 = columnIndex_1; _i < columnIndex_2.length; _i++) {\n                    var colIndx = columnIndex_2[_i];\n                    if (row[colIndx] === oldValue) {\n                        row[colIndx] = newValue;\n                    }\n                }\n                return row;\n            });\n        }\n        else {\n            newData = this.values.map(function (_a) {\n                var row = _a.slice(0);\n                return row.map((function (cell) {\n                    if (cell === oldValue) {\n                        return newValue;\n                    }\n                    else {\n                        return cell;\n                    }\n                }));\n            });\n        }\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.asType = function (column, dtype, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var columnIndex = this.columns.indexOf(column);\n        if (columnIndex === -1) {\n            throw Error(\"Params Error: column not found in columns\");\n        }\n        if (!(defaults_1.DATA_TYPES.includes(dtype))) {\n            throw Error(\"dtype \" + dtype + \" not supported. dtype must be one of \" + defaults_1.DATA_TYPES);\n        }\n        var data = this.values;\n        var newData = data.map(function (row) {\n            if (dtype === \"float32\") {\n                row[columnIndex] = Number(row[columnIndex]);\n                return row;\n            }\n            else if (dtype === \"int32\") {\n                row[columnIndex] = parseInt(row[columnIndex]);\n                return row;\n            }\n            else if (dtype === \"string\") {\n                row[columnIndex] = row[columnIndex].toString();\n                return row;\n            }\n            else if (dtype === \"boolean\") {\n                row[columnIndex] = Boolean(row[columnIndex]);\n                return row;\n            }\n        });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            var newDtypes = __spreadArray([], this.dtypes, true);\n            newDtypes[columnIndex] = dtype;\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: newDtypes,\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n     * Return the number of unique elements in a column, across the specified axis.\n     * To get the values use `.unique()` instead.\n     * @param axis The axis to count unique elements across. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4], [1, 2], [5, 6]], { columns: ['A', 'B'] })\n     * df.nunique().print()\n     * ```\n     *\n    */\n    DataFrame.prototype.nUnique = function (axis) {\n        if (axis === void 0) { axis = 1; }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: axis must be 0 or 1\");\n        }\n        var data = this.$getDataArraysByAxis(axis);\n        var newData = data.map(function (row) { return new Set(row).size; });\n        if (axis === 0) {\n            return new series_1.default(newData, {\n                index: __spreadArray([], this.columns, true),\n                dtypes: [\"int32\"]\n            });\n        }\n        else {\n            return new series_1.default(newData, {\n                index: __spreadArray([], this.index, true),\n                dtypes: [\"int32\"]\n            });\n        }\n    };\n    DataFrame.prototype.rename = function (mapper, options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: axis must be 0 or 1\");\n        }\n        if (axis === 1) {\n            var colsAdded_2 = [];\n            var newColumns = this.columns.map(function (col) {\n                if (mapper[col] !== undefined) {\n                    var newCol = \"\" + mapper[col];\n                    colsAdded_2.push(newCol);\n                    return newCol;\n                }\n                else {\n                    return col;\n                }\n            });\n            if (inplace) {\n                this.$setColumnNames(newColumns);\n                for (var _i = 0, colsAdded_1 = colsAdded_2; _i < colsAdded_1.length; _i++) {\n                    var col = colsAdded_1[_i];\n                    this.$setInternalColumnDataProperty(col);\n                }\n            }\n            else {\n                return new DataFrame(__spreadArray([], this.values, true), {\n                    index: __spreadArray([], this.index, true),\n                    columns: newColumns,\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n        else {\n            var newIndex = this.index.map(function (col) {\n                if (mapper[col] !== undefined) {\n                    return mapper[col];\n                }\n                else {\n                    return col;\n                }\n            });\n            if (inplace) {\n                this.$setIndex(newIndex);\n            }\n            else {\n                return new DataFrame(__spreadArray([], this.values, true), {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n    };\n    DataFrame.prototype.sortIndex = function (options) {\n        var _this = this;\n        var _a = __assign({ ascending: true, inplace: false }, options), ascending = _a.ascending, inplace = _a.inplace;\n        var indexPosition = utils.range(0, this.index.length - 1);\n        var index = __spreadArray([], this.index, true);\n        var objToSort = index.map(function (idx, i) {\n            return { index: indexPosition[i], value: idx };\n        });\n        var sortedObjectArr = utils.sortObj(objToSort, ascending);\n        var sortedIndex = sortedObjectArr.map(function (obj) { return obj.index; });\n        var newData = sortedIndex.map(function (i) { return _this.values[i]; });\n        sortedIndex = sortedIndex.map(function (i) { return index[i]; });\n        if (inplace) {\n            this.$setValues(newData);\n            this.$setIndex(sortedIndex);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: sortedIndex,\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.append = function (newValues, index, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!newValues) {\n            throw Error(\"ParamError: newValues must be a Series, DataFrame or Array\");\n        }\n        if (!index) {\n            throw Error(\"ParamError: index must be specified\");\n        }\n        var rowsToAdd = [];\n        if (newValues instanceof series_1.default) {\n            if (newValues.values.length !== this.shape[1]) {\n                throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n            }\n            rowsToAdd = [newValues.values];\n        }\n        else if (newValues instanceof DataFrame) {\n            if (newValues.shape[1] !== this.shape[1]) {\n                throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n            }\n            rowsToAdd = newValues.values;\n        }\n        else if (Array.isArray(newValues)) {\n            if (utils.is1DArray(newValues)) {\n                rowsToAdd = [newValues];\n            }\n            else {\n                rowsToAdd = newValues;\n            }\n            if (rowsToAdd[0].length !== this.shape[1]) {\n                throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n            }\n        }\n        else {\n            throw Error(\"ValueError: newValues must be a Series, DataFrame or Array\");\n        }\n        var indexInArrFormat = [];\n        if (!Array.isArray(index)) {\n            indexInArrFormat = [index];\n        }\n        else {\n            indexInArrFormat = index;\n        }\n        if (rowsToAdd.length !== indexInArrFormat.length) {\n            throw Error(\"ParamError: index must contain the same number of values as newValues\");\n        }\n        var newData = __spreadArray([], this.values, true);\n        var newIndex = __spreadArray([], this.index, true);\n        rowsToAdd.forEach(function (row, i) {\n            newData.push(row);\n            newIndex.push(indexInArrFormat[i]);\n        });\n        if (inplace) {\n            this.$setValues(newData);\n            this.$setIndex(newIndex);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: newIndex,\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.query = function (condition, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!condition) {\n            throw new Error(\"ParamError: condition must be specified\");\n        }\n        var result = (0, indexing_1._iloc)({\n            ndFrame: this,\n            rows: condition,\n        });\n        if (inplace) {\n            this.$setValues(result.values, false, false);\n            this.$setIndex(result.index);\n        }\n        else {\n            return result;\n        }\n    };\n    Object.defineProperty(DataFrame.prototype, \"ctypes\", {\n        /**\n         * Returns the data types for each column as a Series.\n         * @example\n         * ```\n         * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C'] })\n         * df.ctypes().print()\n         * ```\n         */\n        get: function () {\n            return new series_1.default(this.dtypes, { index: this.columns });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DataFrame.prototype.getDummies = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var encodedDF = (0, dummy_encoder_1.default)(this, options);\n        if (inplace) {\n            this.$setValues(encodedDF.values, false, false);\n            this.$setColumnNames(encodedDF.columns);\n        }\n        else {\n            return encodedDF;\n        }\n    };\n    /**\n     * Groupby\n     * @params col a list of column\n     * @returns Groupby\n     * @example\n     * let data = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 20, 30, 40 ], [ 39, 89, 78 ] ];\n     * let cols = [ \"A\", \"B\", \"C\" ];\n     * let df = new dfd.DataFrame(data, { columns: cols });\n     * let groupDf = df.groupby([ \"A\" ]);\n     */\n    DataFrame.prototype.groupby = function (col) {\n        var columns = this.columns;\n        var colIndex = col.map(function (val) { return columns.indexOf(val); });\n        var colDtype = this.dtypes;\n        return new groupby_1.default(col, this.values, columns, colDtype, colIndex).group();\n    };\n    /**\n     * Access a single value for a row/column pair by integer position.\n     * Similar to {@link iloc}, in that both provide integer-based lookups.\n     * Use iat if you only need to get or set a single value in a DataFrame.\n     * @param row Row index of the value to access.\n     * @param column Column index of the value to access.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.iat(0, 0) // 1\n     * df.iat(0, 1) // 2\n     * df.iat(1, 0) // 3\n     * ```\n    */\n    DataFrame.prototype.iat = function (row, column) {\n        if (typeof row === 'string' || typeof column === 'string') {\n            throw new Error('ParamError: row and column index must be an integer. Use .at to get a row or column by label.');\n        }\n        return this.values[row][column];\n    };\n    /**\n     * Access a single value for a row/column label pair.\n     * Similar to {@link loc}, in that both provide label-based lookups.\n     * Use at if you only need to get or set a single value in a DataFrame.\n     * @param row Row index of the value to access.\n     * @param column Column label of the value to access.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.at(0,'A') // 1\n     * df.at(1, 'A') // 3\n     * df.at(1, 'B') // 4\n     * ```\n    */\n    DataFrame.prototype.at = function (row, column) {\n        if (typeof column !== 'string') {\n            throw new Error('ParamError: column index must be a string. Use .iat to get a row or column by index.');\n        }\n        return this.values[this.index.indexOf(row)][this.columns.indexOf(column)];\n    };\n    /**\n     * Exposes functions for creating charts from a DataFrame.\n     * Charts are created using the Plotly.js library, so all Plotly's configuration parameters are available.\n     * @param divId name of the HTML Div to render the chart in.\n    */\n    DataFrame.prototype.plot = function (divId) {\n        //TODO: Add support for check plot library to use. So we can support other plot library like d3, vega, etc\n        if (utils.isBrowserEnv()) {\n            var plt = new plotting_1.PlotlyLib(this, divId);\n            return plt;\n        }\n        else {\n            throw new Error(\"Not supported in NodeJS\");\n        }\n    };\n    return DataFrame;\n}(generic_1.default));\nexports.default = DataFrame;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}