{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsCollections = containsCollections;\nexports.deepForEach = deepForEach;\nexports.deepMap = deepMap;\nexports.reduce = reduce;\nexports.scatter = scatter;\nvar _is = require(\"./is.js\");\nvar _IndexError = require(\"../error/IndexError.js\");\nvar _array = require(\"./array.js\");\n\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\nfunction containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if ((0, _is.isCollection)(array[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\nfunction deepForEach(array, callback) {\n  if ((0, _is.isMatrix)(array)) {\n    array = array.valueOf();\n  }\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n}\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\nfunction deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n}\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\nfunction reduce(mat, dim, callback) {\n  var size = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new _IndexError.IndexError(dim, size.length);\n  }\n  if ((0, _is.isMatrix)(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n}\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n      return ret;\n    }\n  } else {\n    ret = [];\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n    ret.push(tmp);\n  }\n  return ret;\n} // TODO: document function scatter\n\nfunction scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","containsCollections","deepForEach","deepMap","reduce","scatter","_is","require","_IndexError","_array","array","i","length","isCollection","callback","isMatrix","valueOf","ii","Array","isArray","skipZeros","map","x","mat","dim","size","arraySize","IndexError","create","_reduce","ret","val","tran","_switch","I","J","j","tmp","push","a","w","u","mark","cindex","f","inverse","update","avalues","_values","aindex","_index","aptr","_ptr","k","k0","k1"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/utils/collection.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsCollections = containsCollections;\nexports.deepForEach = deepForEach;\nexports.deepMap = deepMap;\nexports.reduce = reduce;\nexports.scatter = scatter;\n\nvar _is = require(\"./is.js\");\n\nvar _IndexError = require(\"../error/IndexError.js\");\n\nvar _array = require(\"./array.js\");\n\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\nfunction containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if ((0, _is.isCollection)(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\n\nfunction deepForEach(array, callback) {\n  if ((0, _is.isMatrix)(array)) {\n    array = array.valueOf();\n  }\n\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n}\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\n\nfunction deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n}\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\n\nfunction reduce(mat, dim, callback) {\n  var size = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();\n\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new _IndexError.IndexError(dim, size.length);\n  }\n\n  if ((0, _is.isMatrix)(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n}\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n} // TODO: document function scatter\n\n\nfunction scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}