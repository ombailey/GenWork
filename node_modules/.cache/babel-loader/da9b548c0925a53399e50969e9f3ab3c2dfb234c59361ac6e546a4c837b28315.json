{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTyped = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _typedFunction = _interopRequireDefault(require(\"typed-function\"));\nvar _number = require(\"../../utils/number.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _map = require(\"../../utils/map.js\");\n\n/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\n// returns a new instance of typed-function\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = _typedFunction[\"default\"].create;\n  return _typedFunction[\"default\"];\n};\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nvar createTyped = /* #__PURE__ */(0, _factory.factory)('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n    Complex = _ref.Complex,\n    DenseMatrix = _ref.DenseMatrix,\n    Fraction = _ref.Fraction;\n\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n  typed.types = [{\n    name: 'number',\n    test: _is.isNumber\n  }, {\n    name: 'Complex',\n    test: _is.isComplex\n  }, {\n    name: 'BigNumber',\n    test: _is.isBigNumber\n  }, {\n    name: 'Fraction',\n    test: _is.isFraction\n  }, {\n    name: 'Unit',\n    test: _is.isUnit\n  }, {\n    name: 'string',\n    test: _is.isString\n  }, {\n    name: 'Chain',\n    test: _is.isChain\n  }, {\n    name: 'Array',\n    test: _is.isArray\n  }, {\n    name: 'Matrix',\n    test: _is.isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: _is.isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: _is.isSparseMatrix\n  }, {\n    name: 'Range',\n    test: _is.isRange\n  }, {\n    name: 'Index',\n    test: _is.isIndex\n  }, {\n    name: 'boolean',\n    test: _is.isBoolean\n  }, {\n    name: 'ResultSet',\n    test: _is.isResultSet\n  }, {\n    name: 'Help',\n    test: _is.isHelp\n  }, {\n    name: 'function',\n    test: _is.isFunction\n  }, {\n    name: 'Date',\n    test: _is.isDate\n  }, {\n    name: 'RegExp',\n    test: _is.isRegExp\n  }, {\n    name: 'null',\n    test: _is.isNull\n  }, {\n    name: 'undefined',\n    test: _is.isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: _is.isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: _is.isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: _is.isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: _is.isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: _is.isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: _is.isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: _is.isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: _is.isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: _is.isIndexNode\n  }, {\n    name: 'Node',\n    test: _is.isNode\n  }, {\n    name: 'ObjectNode',\n    test: _is.isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: _is.isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: _is.isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: _is.isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: _is.isSymbolNode\n  }, {\n    name: 'Map',\n    test: _map.isMap\n  }, {\n    name: 'Object',\n    test: _is.isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n      if ((0, _number.digits)(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n      var f = new Fraction(x);\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\nexports.createTyped = createTyped;\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createTyped","_is","_typedFunction","_number","_factory","_map","_createTyped2","_createTyped","create","dependencies","factory","_ref","BigNumber","Complex","DenseMatrix","Fraction","typed","types","name","test","isNumber","isComplex","isBigNumber","isFraction","isUnit","isString","isChain","isArray","isMatrix","isDenseMatrix","isSparseMatrix","isRange","isIndex","isBoolean","isResultSet","isHelp","isFunction","isDate","isRegExp","isNull","isUndefined","isAccessorNode","isArrayNode","isAssignmentNode","isBlockNode","isConditionalNode","isConstantNode","isFunctionNode","isFunctionAssignmentNode","isIndexNode","isNode","isObjectNode","isOperatorNode","isParenthesisNode","isRangeNode","isSymbolNode","isMap","isObject","conversions","from","to","convert","x","throwNoBignumber","digits","TypeError","throwNoComplex","toNumber","valueOf","throwNoFraction","f","n","Number","isNaN","Error","err","String","array","throwNoMatrix","matrix","concat"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/core/function/typed.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTyped = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _typedFunction = _interopRequireDefault(require(\"typed-function\"));\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _map = require(\"../../utils/map.js\");\n\n/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\n// returns a new instance of typed-function\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = _typedFunction[\"default\"].create;\n  return _typedFunction[\"default\"];\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nvar createTyped = /* #__PURE__ */(0, _factory.factory)('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n      Complex = _ref.Complex,\n      DenseMatrix = _ref.DenseMatrix,\n      Fraction = _ref.Fraction;\n\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: _is.isNumber\n  }, {\n    name: 'Complex',\n    test: _is.isComplex\n  }, {\n    name: 'BigNumber',\n    test: _is.isBigNumber\n  }, {\n    name: 'Fraction',\n    test: _is.isFraction\n  }, {\n    name: 'Unit',\n    test: _is.isUnit\n  }, {\n    name: 'string',\n    test: _is.isString\n  }, {\n    name: 'Chain',\n    test: _is.isChain\n  }, {\n    name: 'Array',\n    test: _is.isArray\n  }, {\n    name: 'Matrix',\n    test: _is.isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: _is.isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: _is.isSparseMatrix\n  }, {\n    name: 'Range',\n    test: _is.isRange\n  }, {\n    name: 'Index',\n    test: _is.isIndex\n  }, {\n    name: 'boolean',\n    test: _is.isBoolean\n  }, {\n    name: 'ResultSet',\n    test: _is.isResultSet\n  }, {\n    name: 'Help',\n    test: _is.isHelp\n  }, {\n    name: 'function',\n    test: _is.isFunction\n  }, {\n    name: 'Date',\n    test: _is.isDate\n  }, {\n    name: 'RegExp',\n    test: _is.isRegExp\n  }, {\n    name: 'null',\n    test: _is.isNull\n  }, {\n    name: 'undefined',\n    test: _is.isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: _is.isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: _is.isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: _is.isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: _is.isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: _is.isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: _is.isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: _is.isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: _is.isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: _is.isIndexNode\n  }, {\n    name: 'Node',\n    test: _is.isNode\n  }, {\n    name: 'ObjectNode',\n    test: _is.isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: _is.isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: _is.isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: _is.isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: _is.isSymbolNode\n  }, {\n    name: 'Map',\n    test: _map.isMap\n  }, {\n    name: 'Object',\n    test: _is.isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if ((0, _number.digits)(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\nexports.createTyped = createTyped;\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAA8C,CAAC;AAEpFC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAE5B,IAAIC,GAAG,GAAGN,OAAO,CAAC,mBAAmB,CAAC;AAEtC,IAAIO,cAAc,GAAGR,sBAAsB,CAACC,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAEtE,IAAIQ,OAAO,GAAGR,OAAO,CAAC,uBAAuB,CAAC;AAE9C,IAAIS,QAAQ,GAAGT,OAAO,CAAC,wBAAwB,CAAC;AAEhD,IAAIU,IAAI,GAAGV,OAAO,CAAC,oBAAoB,CAAC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIW,aAAa,GAAG,SAASC,YAAY,GAAG;EAC1C;EACA;EACAD,aAAa,GAAGJ,cAAc,CAAC,SAAS,CAAC,CAACM,MAAM;EAChD,OAAON,cAAc,CAAC,SAAS,CAAC;AAClC,CAAC;AAED,IAAIO,YAAY,GAAG,CAAC,YAAY,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,CAAC;AAC1E;AACA;AACA;AACA;AACA;;AAEA,IAAIT,WAAW,GAAG,eAAe,CAAC,CAAC,EAAEI,QAAQ,CAACM,OAAO,EAAE,OAAO,EAAED,YAAY,EAAE,SAAST,WAAW,CAACW,IAAI,EAAE;EACvG,IAAIC,SAAS,GAAGD,IAAI,CAACC,SAAS;IAC1BC,OAAO,GAAGF,IAAI,CAACE,OAAO;IACtBC,WAAW,GAAGH,IAAI,CAACG,WAAW;IAC9BC,QAAQ,GAAGJ,IAAI,CAACI,QAAQ;;EAE5B;EACA;EACA,IAAIC,KAAK,GAAGV,aAAa,EAAE,CAAC,CAAC;EAC7B;EACA;;EAGAU,KAAK,CAACC,KAAK,GAAG,CAAC;IACbC,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAElB,GAAG,CAACmB;EACZ,CAAC,EAAE;IACDF,IAAI,EAAE,SAAS;IACfC,IAAI,EAAElB,GAAG,CAACoB;EACZ,CAAC,EAAE;IACDH,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAACqB;EACZ,CAAC,EAAE;IACDJ,IAAI,EAAE,UAAU;IAChBC,IAAI,EAAElB,GAAG,CAACsB;EACZ,CAAC,EAAE;IACDL,IAAI,EAAE,MAAM;IACZC,IAAI,EAAElB,GAAG,CAACuB;EACZ,CAAC,EAAE;IACDN,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAElB,GAAG,CAACwB;EACZ,CAAC,EAAE;IACDP,IAAI,EAAE,OAAO;IACbC,IAAI,EAAElB,GAAG,CAACyB;EACZ,CAAC,EAAE;IACDR,IAAI,EAAE,OAAO;IACbC,IAAI,EAAElB,GAAG,CAAC0B;EACZ,CAAC,EAAE;IACDT,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAElB,GAAG,CAAC2B;EACZ,CAAC,EAAE;IACDV,IAAI,EAAE,aAAa;IACnBC,IAAI,EAAElB,GAAG,CAAC4B;EACZ,CAAC,EAAE;IACDX,IAAI,EAAE,cAAc;IACpBC,IAAI,EAAElB,GAAG,CAAC6B;EACZ,CAAC,EAAE;IACDZ,IAAI,EAAE,OAAO;IACbC,IAAI,EAAElB,GAAG,CAAC8B;EACZ,CAAC,EAAE;IACDb,IAAI,EAAE,OAAO;IACbC,IAAI,EAAElB,GAAG,CAAC+B;EACZ,CAAC,EAAE;IACDd,IAAI,EAAE,SAAS;IACfC,IAAI,EAAElB,GAAG,CAACgC;EACZ,CAAC,EAAE;IACDf,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAACiC;EACZ,CAAC,EAAE;IACDhB,IAAI,EAAE,MAAM;IACZC,IAAI,EAAElB,GAAG,CAACkC;EACZ,CAAC,EAAE;IACDjB,IAAI,EAAE,UAAU;IAChBC,IAAI,EAAElB,GAAG,CAACmC;EACZ,CAAC,EAAE;IACDlB,IAAI,EAAE,MAAM;IACZC,IAAI,EAAElB,GAAG,CAACoC;EACZ,CAAC,EAAE;IACDnB,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAElB,GAAG,CAACqC;EACZ,CAAC,EAAE;IACDpB,IAAI,EAAE,MAAM;IACZC,IAAI,EAAElB,GAAG,CAACsC;EACZ,CAAC,EAAE;IACDrB,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAACuC;EACZ,CAAC,EAAE;IACDtB,IAAI,EAAE,cAAc;IACpBC,IAAI,EAAElB,GAAG,CAACwC;EACZ,CAAC,EAAE;IACDvB,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAACyC;EACZ,CAAC,EAAE;IACDxB,IAAI,EAAE,gBAAgB;IACtBC,IAAI,EAAElB,GAAG,CAAC0C;EACZ,CAAC,EAAE;IACDzB,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAAC2C;EACZ,CAAC,EAAE;IACD1B,IAAI,EAAE,iBAAiB;IACvBC,IAAI,EAAElB,GAAG,CAAC4C;EACZ,CAAC,EAAE;IACD3B,IAAI,EAAE,cAAc;IACpBC,IAAI,EAAElB,GAAG,CAAC6C;EACZ,CAAC,EAAE;IACD5B,IAAI,EAAE,cAAc;IACpBC,IAAI,EAAElB,GAAG,CAAC8C;EACZ,CAAC,EAAE;IACD7B,IAAI,EAAE,wBAAwB;IAC9BC,IAAI,EAAElB,GAAG,CAAC+C;EACZ,CAAC,EAAE;IACD9B,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAACgD;EACZ,CAAC,EAAE;IACD/B,IAAI,EAAE,MAAM;IACZC,IAAI,EAAElB,GAAG,CAACiD;EACZ,CAAC,EAAE;IACDhC,IAAI,EAAE,YAAY;IAClBC,IAAI,EAAElB,GAAG,CAACkD;EACZ,CAAC,EAAE;IACDjC,IAAI,EAAE,cAAc;IACpBC,IAAI,EAAElB,GAAG,CAACmD;EACZ,CAAC,EAAE;IACDlC,IAAI,EAAE,iBAAiB;IACvBC,IAAI,EAAElB,GAAG,CAACoD;EACZ,CAAC,EAAE;IACDnC,IAAI,EAAE,WAAW;IACjBC,IAAI,EAAElB,GAAG,CAACqD;EACZ,CAAC,EAAE;IACDpC,IAAI,EAAE,YAAY;IAClBC,IAAI,EAAElB,GAAG,CAACsD;EACZ,CAAC,EAAE;IACDrC,IAAI,EAAE,KAAK;IACXC,IAAI,EAAEd,IAAI,CAACmD;EACb,CAAC,EAAE;IACDtC,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAElB,GAAG,CAACwD;EACZ,CAAC,CAAC;EAAA,CACD;;EACDzC,KAAK,CAAC0C,WAAW,GAAG,CAAC;IACnBC,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,WAAW;IACfC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAAClD,SAAS,EAAE;QACdmD,gBAAgB,CAACD,CAAC,CAAC;MACrB,CAAC,CAAC;;MAGF,IAAI,CAAC,CAAC,EAAE3D,OAAO,CAAC6D,MAAM,EAAEF,CAAC,CAAC,GAAG,EAAE,EAAE;QAC/B,MAAM,IAAIG,SAAS,CAAC,8EAA8E,GAAG,UAAU,GAAGH,CAAC,GAAG,KAAK,GAAG,oDAAoD,CAAC;MACrL;MAEA,OAAO,IAAIlD,SAAS,CAACkD,CAAC,CAAC;IACzB;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,SAAS;IACbC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAACjD,OAAO,EAAE;QACZqD,cAAc,CAACJ,CAAC,CAAC;MACnB;MAEA,OAAO,IAAIjD,OAAO,CAACiD,CAAC,EAAE,CAAC,CAAC;IAC1B;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,QAAQ;IACZC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,OAAOA,CAAC,GAAG,EAAE;IACf;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,WAAW;IACjBC,EAAE,EAAE,SAAS;IACbC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAACjD,OAAO,EAAE;QACZqD,cAAc,CAACJ,CAAC,CAAC;MACnB;MAEA,OAAO,IAAIjD,OAAO,CAACiD,CAAC,CAACK,QAAQ,EAAE,EAAE,CAAC,CAAC;IACrC;EACF,CAAC,EAAE;IACDR,IAAI,EAAE,UAAU;IAChBC,EAAE,EAAE,WAAW;IACfC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,MAAM,IAAIG,SAAS,CAAC,mEAAmE,GAAG,0FAA0F,CAAC;IACvL;EACF,CAAC,EAAE;IACDN,IAAI,EAAE,UAAU;IAChBC,EAAE,EAAE,SAAS;IACbC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAACjD,OAAO,EAAE;QACZqD,cAAc,CAACJ,CAAC,CAAC;MACnB;MAEA,OAAO,IAAIjD,OAAO,CAACiD,CAAC,CAACM,OAAO,EAAE,EAAE,CAAC,CAAC;IACpC;EACF,CAAC,EAAE;IACDT,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,UAAU;IACdC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAAC/C,QAAQ,EAAE;QACbsD,eAAe,CAACP,CAAC,CAAC;MACpB;MAEA,IAAIQ,CAAC,GAAG,IAAIvD,QAAQ,CAAC+C,CAAC,CAAC;MAEvB,IAAIQ,CAAC,CAACF,OAAO,EAAE,KAAKN,CAAC,EAAE;QACrB,MAAM,IAAIG,SAAS,CAAC,0FAA0F,GAAG,UAAU,GAAGH,CAAC,GAAG,KAAK,GAAG,kDAAkD,CAAC;MAC/L;MAEA,OAAOQ,CAAC;IACV;EACF,CAAC,EAAE;IACD;IACA;IACA;IACA;IACA;IACA;IACA;IACAX,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,QAAQ;IACZC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAIS,CAAC,GAAGC,MAAM,CAACV,CAAC,CAAC;MAEjB,IAAIW,KAAK,CAACF,CAAC,CAAC,EAAE;QACZ,MAAM,IAAIG,KAAK,CAAC,kBAAkB,GAAGZ,CAAC,GAAG,eAAe,CAAC;MAC3D;MAEA,OAAOS,CAAC;IACV;EACF,CAAC,EAAE;IACDZ,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,WAAW;IACfC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAAClD,SAAS,EAAE;QACdmD,gBAAgB,CAACD,CAAC,CAAC;MACrB;MAEA,IAAI;QACF,OAAO,IAAIlD,SAAS,CAACkD,CAAC,CAAC;MACzB,CAAC,CAAC,OAAOa,GAAG,EAAE;QACZ,MAAM,IAAID,KAAK,CAAC,kBAAkB,GAAGZ,CAAC,GAAG,gBAAgB,CAAC;MAC5D;IACF;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,UAAU;IACdC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAAC/C,QAAQ,EAAE;QACbsD,eAAe,CAACP,CAAC,CAAC;MACpB;MAEA,IAAI;QACF,OAAO,IAAI/C,QAAQ,CAAC+C,CAAC,CAAC;MACxB,CAAC,CAAC,OAAOa,GAAG,EAAE;QACZ,MAAM,IAAID,KAAK,CAAC,kBAAkB,GAAGZ,CAAC,GAAG,eAAe,CAAC;MAC3D;IACF;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,SAAS;IACbC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAACjD,OAAO,EAAE;QACZqD,cAAc,CAACJ,CAAC,CAAC;MACnB;MAEA,IAAI;QACF,OAAO,IAAIjD,OAAO,CAACiD,CAAC,CAAC;MACvB,CAAC,CAAC,OAAOa,GAAG,EAAE;QACZ,MAAM,IAAID,KAAK,CAAC,kBAAkB,GAAGZ,CAAC,GAAG,cAAc,CAAC;MAC1D;IACF;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,SAAS;IACfC,EAAE,EAAE,QAAQ;IACZC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,OAAO,CAACA,CAAC;IACX;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,SAAS;IACfC,EAAE,EAAE,WAAW;IACfC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAAClD,SAAS,EAAE;QACdmD,gBAAgB,CAACD,CAAC,CAAC;MACrB;MAEA,OAAO,IAAIlD,SAAS,CAAC,CAACkD,CAAC,CAAC;IAC1B;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,SAAS;IACfC,EAAE,EAAE,UAAU;IACdC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,IAAI,CAAC/C,QAAQ,EAAE;QACbsD,eAAe,CAACP,CAAC,CAAC;MACpB;MAEA,OAAO,IAAI/C,QAAQ,CAAC,CAAC+C,CAAC,CAAC;IACzB;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,SAAS;IACfC,EAAE,EAAE,QAAQ;IACZC,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,OAAOc,MAAM,CAACd,CAAC,CAAC;IAClB;EACF,CAAC,EAAE;IACDH,IAAI,EAAE,OAAO;IACbC,EAAE,EAAE,QAAQ;IACZC,OAAO,EAAE,SAASA,OAAO,CAACgB,KAAK,EAAE;MAC/B,IAAI,CAAC/D,WAAW,EAAE;QAChBgE,aAAa,EAAE;MACjB;MAEA,OAAO,IAAIhE,WAAW,CAAC+D,KAAK,CAAC;IAC/B;EACF,CAAC,EAAE;IACDlB,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,OAAO;IACXC,OAAO,EAAE,SAASA,OAAO,CAACkB,MAAM,EAAE;MAChC,OAAOA,MAAM,CAACX,OAAO,EAAE;IACzB;EACF,CAAC,CAAC;EACF,OAAOpD,KAAK;AACd,CAAC,CAAC;AACFlB,OAAO,CAACE,WAAW,GAAGA,WAAW;AAEjC,SAAS+D,gBAAgB,CAACD,CAAC,EAAE;EAC3B,MAAM,IAAIY,KAAK,CAAC,uBAAuB,CAACM,MAAM,CAAClB,CAAC,EAAE,kDAAkD,CAAC,CAAC;AACxG;AAEA,SAASI,cAAc,CAACJ,CAAC,EAAE;EACzB,MAAM,IAAIY,KAAK,CAAC,uBAAuB,CAACM,MAAM,CAAClB,CAAC,EAAE,qDAAqD,CAAC,CAAC;AAC3G;AAEA,SAASgB,aAAa,GAAG;EACvB,MAAM,IAAIJ,KAAK,CAAC,uEAAuE,CAAC;AAC1F;AAEA,SAASL,eAAe,CAACP,CAAC,EAAE;EAC1B,MAAM,IAAIY,KAAK,CAAC,uBAAuB,CAACM,MAAM,CAAClB,CAAC,EAAE,iDAAiD,CAAC,CAAC;AACvG"},"metadata":{},"sourceType":"script","externalDependencies":[]}