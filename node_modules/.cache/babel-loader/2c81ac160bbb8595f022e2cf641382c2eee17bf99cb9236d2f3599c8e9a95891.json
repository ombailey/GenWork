{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQr = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _factory = require(\"../../../utils/factory.js\");\nvar name = 'qr';\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];\nvar createQr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix,\n    zeros = _ref.zeros,\n    identity = _ref.identity,\n    isZero = _ref.isZero,\n    equal = _ref.equal,\n    sign = _ref.sign,\n    sqrt = _ref.sqrt,\n    conj = _ref.conj,\n    unaryMinus = _ref.unaryMinus,\n    addScalar = _ref.addScalar,\n    divideScalar = _ref.divideScalar,\n    multiplyScalar = _ref.multiplyScalar,\n    subtract = _ref.subtract,\n    complex = _ref.complex;\n\n  /**\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\n   * two matrices (`Q`, `R`) where `Q` is an\n   * orthogonal matrix and `R` is an upper triangular matrix.\n   *\n   * Syntax:\n   *\n   *    math.qr(A)\n   *\n   * Example:\n   *\n   *    const m = [\n   *      [1, -1,  4],\n   *      [1,  4, -2],\n   *      [1,  4,  2],\n   *      [1,  -1, 0]\n   *    ]\n   *    const result = math.qr(m)\n   *    // r = {\n   *    //   Q: [\n   *    //     [0.5, -0.5,   0.5],\n   *    //     [0.5,  0.5,  -0.5],\n   *    //     [0.5,  0.5,   0.5],\n   *    //     [0.5, -0.5,  -0.5],\n   *    //   ],\n   *    //   R: [\n   *    //     [2, 3,  2],\n   *    //     [0, 5, -2],\n   *    //     [0, 0,  4],\n   *    //     [0, 0,  0]\n   *    //   ]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lusolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array\n   * for which to get the QR decomposition.\n   *\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\n   * matrix and R: the upper triangular matrix\n   */\n  return (0, _extends2[\"default\"])(typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseQR(m); // result\n\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  }), {\n    _denseQRimpl: _denseQRimpl\n  });\n  function _denseQRimpl(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data; // vars\n\n    var i, j, k;\n    var w = zeros([rows], '');\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\n       * **k-th Household matrix**\n       *\n       * The matrix I - 2*v*transpose(v)\n       * x     = first column of A\n       * x1    = first element of x\n       * alpha = x1 / |x1| * |x|\n       * e1    = tranpose([1, 0, 0, ...])\n       * u     = x - alpha * e1\n       * v     = u / |u|\n       *\n       * Household matrix = I - 2 * v * tranpose(v)\n       *\n       *  * Initially Q = I and R = A.\n       *  * Household matrix is a reflection in a plane normal to v which\n       *    will zero out all but the top right element in R.\n       *  * Appplying reflection to both Q and R will not change product.\n       *  * Repeat this process on the (1,1) minor to get R as an upper\n       *    triangular matrix.\n       *  * Reflections leave the magnitude of the columns of Q unchanged\n       *    so Q remains othoganal.\n       *\n       */\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n\n        w[k] = 1;\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        } // tau = - conj(u1 / alpha)\n\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n        /*\n         * tau and w have been choosen so that\n         *\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\n         */\n\n        /*\n         * -- calculate R = R - tau * w * tranpose(w) * R --\n         * Only do calculation with rows k to (rows-1)\n         * Additionally columns 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n        for (j = k; j < cols; j++) {\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\n\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          } // calculate the jth element of [tau * transpose(w) * R]\n\n          s = multiplyScalar(s, tau);\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\n         * Q is a square matrix (rows x rows)\n         * Only do calculation with columns k to (rows-1)\n         * Additionally rows 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n        for (i = 0; i < rows; i++) {\n          s = 0.0; // calculate ith element of [Q * w]\n\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          } // calculate the ith element of [tau * Q * w]\n\n          s = multiplyScalar(s, tau);\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    } // return matrices\n\n    return {\n      Q: Q,\n      R: R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n  function _denseQR(m) {\n    var ret = _denseQRimpl(m);\n    var Rdata = ret.R._data;\n    if (m._data.length > 0) {\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\n      for (var i = 0; i < Rdata.length; ++i) {\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\n          Rdata[i][j] = zero;\n        }\n      }\n    }\n    return ret;\n  }\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n});\nexports.createQr = createQr;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createQr","_extends2","_factory","name","dependencies","factory","_ref","typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtract","complex","DenseMatrix","m","_denseQR","SparseMatrix","_sparseQR","Array","a","r","Q","valueOf","R","_denseQRimpl","rows","_size","cols","Qdata","_data","clone","Rdata","i","j","k","w","Math","min","pivot","sgn","conjSgn","alphaSquared","alpha","u1","tau","s","toString","ret","length","zero","type","Error"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/decomposition/qr.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQr = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'qr';\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];\nvar createQr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      zeros = _ref.zeros,\n      identity = _ref.identity,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      sign = _ref.sign,\n      sqrt = _ref.sqrt,\n      conj = _ref.conj,\n      unaryMinus = _ref.unaryMinus,\n      addScalar = _ref.addScalar,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      complex = _ref.complex;\n\n  /**\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\n   * two matrices (`Q`, `R`) where `Q` is an\n   * orthogonal matrix and `R` is an upper triangular matrix.\n   *\n   * Syntax:\n   *\n   *    math.qr(A)\n   *\n   * Example:\n   *\n   *    const m = [\n   *      [1, -1,  4],\n   *      [1,  4, -2],\n   *      [1,  4,  2],\n   *      [1,  -1, 0]\n   *    ]\n   *    const result = math.qr(m)\n   *    // r = {\n   *    //   Q: [\n   *    //     [0.5, -0.5,   0.5],\n   *    //     [0.5,  0.5,  -0.5],\n   *    //     [0.5,  0.5,   0.5],\n   *    //     [0.5, -0.5,  -0.5],\n   *    //   ],\n   *    //   R: [\n   *    //     [2, 3,  2],\n   *    //     [0, 5, -2],\n   *    //     [0, 0,  4],\n   *    //     [0, 0,  0]\n   *    //   ]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lusolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array\n   * for which to get the QR decomposition.\n   *\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\n   * matrix and R: the upper triangular matrix\n   */\n  return (0, _extends2[\"default\"])(typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseQR(m); // result\n\n\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  }), {\n    _denseQRimpl: _denseQRimpl\n  });\n\n  function _denseQRimpl(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data; // vars\n\n    var i, j, k;\n    var w = zeros([rows], '');\n\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\n       * **k-th Household matrix**\n       *\n       * The matrix I - 2*v*transpose(v)\n       * x     = first column of A\n       * x1    = first element of x\n       * alpha = x1 / |x1| * |x|\n       * e1    = tranpose([1, 0, 0, ...])\n       * u     = x - alpha * e1\n       * v     = u / |u|\n       *\n       * Household matrix = I - 2 * v * tranpose(v)\n       *\n       *  * Initially Q = I and R = A.\n       *  * Household matrix is a reflection in a plane normal to v which\n       *    will zero out all but the top right element in R.\n       *  * Appplying reflection to both Q and R will not change product.\n       *  * Repeat this process on the (1,1) minor to get R as an upper\n       *    triangular matrix.\n       *  * Reflections leave the magnitude of the columns of Q unchanged\n       *    so Q remains othoganal.\n       *\n       */\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n\n        w[k] = 1;\n\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        } // tau = - conj(u1 / alpha)\n\n\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n        /*\n         * tau and w have been choosen so that\n         *\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\n         */\n\n        /*\n         * -- calculate R = R - tau * w * tranpose(w) * R --\n         * Only do calculation with rows k to (rows-1)\n         * Additionally columns 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n        for (j = k; j < cols; j++) {\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\n\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          } // calculate the jth element of [tau * transpose(w) * R]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\n         * Q is a square matrix (rows x rows)\n         * Only do calculation with columns k to (rows-1)\n         * Additionally rows 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n\n\n        for (i = 0; i < rows; i++) {\n          s = 0.0; // calculate ith element of [Q * w]\n\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          } // calculate the ith element of [tau * Q * w]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    } // return matrices\n\n\n    return {\n      Q: Q,\n      R: R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n\n  function _denseQR(m) {\n    var ret = _denseQRimpl(m);\n\n    var Rdata = ret.R._data;\n\n    if (m._data.length > 0) {\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\n\n      for (var i = 0; i < Rdata.length; ++i) {\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\n          Rdata[i][j] = zero;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n});\nexports.createQr = createQr;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}