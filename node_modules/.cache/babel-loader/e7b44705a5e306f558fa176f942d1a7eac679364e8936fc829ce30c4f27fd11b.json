{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSetPowerset = void 0;\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'setPowerset';\nvar dependencies = ['typed', 'size', 'subset', 'compareNatural', 'Index'];\nvar createSetPowerset = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    size = _ref.size,\n    subset = _ref.subset,\n    compareNatural = _ref.compareNatural,\n    Index = _ref.Index;\n\n  /**\n   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setPowerset(set)\n   *\n   * Examples:\n   *\n   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n   *\n   * See also:\n   *\n   *    setCartesian\n   *\n   * @param {Array | Matrix}    a  A (multi)set\n   * @return {Array}    The powerset of the (multi)set\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(a) {\n      if (subset(size(a), new Index(0)) === 0) {\n        // if empty, return empty\n        return [];\n      }\n      var b = (0, _array.flatten)(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n      var result = [];\n      var number = 0;\n      while (number.toString(2).length <= b.length) {\n        result.push(_subset(b, number.toString(2).split('').reverse()));\n        number++;\n      } // can not return a matrix, because of the different size of the subarrays\n\n      return _sort(result);\n    }\n  }); // create subset\n\n  function _subset(array, bitarray) {\n    var result = [];\n    for (var i = 0; i < bitarray.length; i++) {\n      if (bitarray[i] === '1') {\n        result.push(array[i]);\n      }\n    }\n    return result;\n  } // sort subsests by length\n\n  function _sort(array) {\n    var temp = [];\n    for (var i = array.length - 1; i > 0; i--) {\n      for (var j = 0; j < i; j++) {\n        if (array[j].length > array[j + 1].length) {\n          temp = array[j];\n          array[j] = array[j + 1];\n          array[j + 1] = temp;\n        }\n      }\n    }\n    return array;\n  }\n});\nexports.createSetPowerset = createSetPowerset;","map":{"version":3,"names":["Object","defineProperty","exports","value","createSetPowerset","_array","require","_factory","name","dependencies","factory","_ref","typed","size","subset","compareNatural","Index","ArrayMatrix","a","b","flatten","Array","isArray","toArray","sort","result","number","toString","length","push","_subset","split","reverse","_sort","array","bitarray","i","temp","j"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/set/setPowerset.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSetPowerset = void 0;\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'setPowerset';\nvar dependencies = ['typed', 'size', 'subset', 'compareNatural', 'Index'];\nvar createSetPowerset = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      size = _ref.size,\n      subset = _ref.subset,\n      compareNatural = _ref.compareNatural,\n      Index = _ref.Index;\n\n  /**\n   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setPowerset(set)\n   *\n   * Examples:\n   *\n   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n   *\n   * See also:\n   *\n   *    setCartesian\n   *\n   * @param {Array | Matrix}    a  A (multi)set\n   * @return {Array}    The powerset of the (multi)set\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(a) {\n      if (subset(size(a), new Index(0)) === 0) {\n        // if empty, return empty\n        return [];\n      }\n\n      var b = (0, _array.flatten)(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n      var result = [];\n      var number = 0;\n\n      while (number.toString(2).length <= b.length) {\n        result.push(_subset(b, number.toString(2).split('').reverse()));\n        number++;\n      } // can not return a matrix, because of the different size of the subarrays\n\n\n      return _sort(result);\n    }\n  }); // create subset\n\n  function _subset(array, bitarray) {\n    var result = [];\n\n    for (var i = 0; i < bitarray.length; i++) {\n      if (bitarray[i] === '1') {\n        result.push(array[i]);\n      }\n    }\n\n    return result;\n  } // sort subsests by length\n\n\n  function _sort(array) {\n    var temp = [];\n\n    for (var i = array.length - 1; i > 0; i--) {\n      for (var j = 0; j < i; j++) {\n        if (array[j].length > array[j + 1].length) {\n          temp = array[j];\n          array[j] = array[j + 1];\n          array[j + 1] = temp;\n        }\n      }\n    }\n\n    return array;\n  }\n});\nexports.createSetPowerset = createSetPowerset;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,iBAAiB,GAAG,KAAK,CAAC;AAElC,IAAIC,MAAM,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAE5C,IAAIC,QAAQ,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AAEhD,IAAIE,IAAI,GAAG,aAAa;AACxB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAE,OAAO,CAAC;AACzE,IAAIL,iBAAiB,GAAG,eAAe,CAAC,CAAC,EAAEG,QAAQ,CAACG,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EAC/F,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK;IAClBC,IAAI,GAAGF,IAAI,CAACE,IAAI;IAChBC,MAAM,GAAGH,IAAI,CAACG,MAAM;IACpBC,cAAc,GAAGJ,IAAI,CAACI,cAAc;IACpCC,KAAK,GAAGL,IAAI,CAACK,KAAK;;EAEtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOJ,KAAK,CAACJ,IAAI,EAAE;IACjB,gBAAgB,EAAE,SAASS,WAAW,CAACC,CAAC,EAAE;MACxC,IAAIJ,MAAM,CAACD,IAAI,CAACK,CAAC,CAAC,EAAE,IAAIF,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QACvC;QACA,OAAO,EAAE;MACX;MAEA,IAAIG,CAAC,GAAG,CAAC,CAAC,EAAEd,MAAM,CAACe,OAAO,EAAEC,KAAK,CAACC,OAAO,CAACJ,CAAC,CAAC,GAAGA,CAAC,GAAGA,CAAC,CAACK,OAAO,EAAE,CAAC,CAACC,IAAI,CAACT,cAAc,CAAC;MACpF,IAAIU,MAAM,GAAG,EAAE;MACf,IAAIC,MAAM,GAAG,CAAC;MAEd,OAAOA,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACC,MAAM,IAAIT,CAAC,CAACS,MAAM,EAAE;QAC5CH,MAAM,CAACI,IAAI,CAACC,OAAO,CAACX,CAAC,EAAEO,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACI,KAAK,CAAC,EAAE,CAAC,CAACC,OAAO,EAAE,CAAC,CAAC;QAC/DN,MAAM,EAAE;MACV,CAAC,CAAC;;MAGF,OAAOO,KAAK,CAACR,MAAM,CAAC;IACtB;EACF,CAAC,CAAC,CAAC,CAAC;;EAEJ,SAASK,OAAO,CAACI,KAAK,EAAEC,QAAQ,EAAE;IAChC,IAAIV,MAAM,GAAG,EAAE;IAEf,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACP,MAAM,EAAEQ,CAAC,EAAE,EAAE;MACxC,IAAID,QAAQ,CAACC,CAAC,CAAC,KAAK,GAAG,EAAE;QACvBX,MAAM,CAACI,IAAI,CAACK,KAAK,CAACE,CAAC,CAAC,CAAC;MACvB;IACF;IAEA,OAAOX,MAAM;EACf,CAAC,CAAC;;EAGF,SAASQ,KAAK,CAACC,KAAK,EAAE;IACpB,IAAIG,IAAI,GAAG,EAAE;IAEb,KAAK,IAAID,CAAC,GAAGF,KAAK,CAACN,MAAM,GAAG,CAAC,EAAEQ,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACzC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,CAAC,EAAEE,CAAC,EAAE,EAAE;QAC1B,IAAIJ,KAAK,CAACI,CAAC,CAAC,CAACV,MAAM,GAAGM,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC,CAACV,MAAM,EAAE;UACzCS,IAAI,GAAGH,KAAK,CAACI,CAAC,CAAC;UACfJ,KAAK,CAACI,CAAC,CAAC,GAAGJ,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC;UACvBJ,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGD,IAAI;QACrB;MACF;IACF;IAEA,OAAOH,KAAK;EACd;AACF,CAAC,CAAC;AACFhC,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB"},"metadata":{},"sourceType":"script","externalDependencies":[]}