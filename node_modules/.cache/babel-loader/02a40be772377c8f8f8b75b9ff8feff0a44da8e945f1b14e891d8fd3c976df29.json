{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyConstant = void 0;\nvar _is = require(\"../../../utils/is.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar _util = require(\"./util.js\");\nvar _noop = require(\"../../../utils/noop.js\");\n\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    config = _ref.config,\n    mathWithTransform = _ref.mathWithTransform,\n    fraction = _ref.fraction,\n    bignumber = _ref.bignumber,\n    ConstantNode = _ref.ConstantNode,\n    OperatorNode = _ref.OperatorNode,\n    FunctionNode = _ref.FunctionNode,\n    SymbolNode = _ref.SymbolNode;\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    isCommutative = _createUtil.isCommutative,\n    isAssociative = _createUtil.isAssociative,\n    allChildren = _createUtil.allChildren,\n    createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return (0, _is.isNode)(res) ? res : _toNode(res);\n  }\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if ((0, _is.isFraction)(x)) {\n          return x.valueOf();\n        }\n        return x;\n      });\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          (0, _noop.noBignumber)();\n        }\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          (0, _noop.noFraction)();\n        }\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re, options);\n    }\n  });\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n    if (f.d === 1) {\n      return n;\n    }\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!(0, _is.isNode)(a)) {\n        a = _toNode(a);\n      } else if (!(0, _is.isNode)(b)) {\n        b = _toNode(b);\n      }\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n        return node;\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(_is.isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontine) {}\n            } // Convert all args to nodes and construct a symbolic function call\n\n            args = args.map(function (arg) {\n              return (0, _is.isNode)(arg) ? arg : _toNode(arg);\n            });\n            return new FunctionNode(node.name, args);\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n          var _args;\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n            if (!(0, _is.isNode)(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node)) {\n            _args = allChildren(node);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            if (isCommutative(fn)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n              for (var i = 0; i < _args.length; i++) {\n                if (!(0, _is.isNode)(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n          return res;\n        }\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n  return simplifyConstant;\n});\nexports.createSimplifyConstant = createSimplifyConstant;","map":{"version":3,"names":["Object","defineProperty","exports","value","createSimplifyConstant","_is","require","_factory","_util","_noop","name","dependencies","factory","_ref","typed","config","mathWithTransform","fraction","bignumber","ConstantNode","OperatorNode","FunctionNode","SymbolNode","_createUtil","createUtil","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","expr","options","res","foldFraction","isNode","_toNode","_eval","fnname","args","_toNumber","apply","ignore","map","x","isFraction","valueOf","Fraction","_fractionToNode","number","n","unaryMinusNode","BigNumber","Complex","s","Error","_exactFraction","exactFractions","isFinite","f","fractionsLimit","Infinity","d","stringObject","undefined","noBignumber","noFraction","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","vn","foldOp","fn","makeNode","reduce","a","b","ignoreandcontinue","node","type","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","ignoreandcontine","toString","_args","isOperatorNode","isUnary","consts","vars","i","length","push","unshift","content","concat"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/simplify/simplifyConstant.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyConstant = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _util = require(\"./util.js\");\n\nvar _noop = require(\"../../../utils/noop.js\");\n\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      mathWithTransform = _ref.mathWithTransform,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      SymbolNode = _ref.SymbolNode;\n\n  var _createUtil = (0, _util.createUtil)({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      allChildren = _createUtil.allChildren,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return (0, _is.isNode)(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if ((0, _is.isFraction)(x)) {\n          return x.valueOf();\n        }\n\n        return x;\n      });\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          (0, _noop.noBignumber)();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          (0, _noop.noFraction)();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!(0, _is.isNode)(a)) {\n        a = _toNode(a);\n      } else if (!(0, _is.isNode)(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(_is.isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontine) {}\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            args = args.map(function (arg) {\n              return (0, _is.isNode)(arg) ? arg : _toNode(arg);\n            });\n            return new FunctionNode(node.name, args);\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!(0, _is.isNode)(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node)) {\n            _args = allChildren(node);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            if (isCommutative(fn)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!(0, _is.isNode)(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});\nexports.createSimplifyConstant = createSimplifyConstant;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}