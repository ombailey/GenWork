{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOperatorNode = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _customs = require(\"../../utils/customs.js\");\nvar _operators = require(\"../operators.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n    var fn = (0, _customs.getSafeProperty)(math, this.fn);\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis);\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n          default:\n            return true;\n        }\n      });\n    }\n    var result;\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n          result = [false];\n        }\n        break;\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // is the root node associative with the left hand side\n\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis); // is the root node associative with the right hand side?\n\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex) {\n            var _rootIdentifier;\n            var lhsIdentifier;\n            var rhsIdentifier;\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n            if (lhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n            if (rhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n          result = [lhsParens, rhsParens];\n        }\n        break;\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis);\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n            return false;\n          });\n        }\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n        return false;\n      });\n    }\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toString(options);\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      } // for example for \"not\", we want a space between operand and argument\n\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + (opIsNamed ? ' ' : '') + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + (opIsNamed ? ' ' : '') + this.op;\n      } // fall back to postfix\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n        return arg;\n      });\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toHTML(options);\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>' + operand;\n      } else {\n        // postfix when assoc === 'left' or undefined\n        return operand + '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>';\n      }\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        return arg;\n      });\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = _latex.latexOperators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toTex(options);\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n      var lhsIdentifier;\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n          break;\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n      }\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n        return arg;\n      });\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createOperatorNode = createOperatorNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createOperatorNode","_is","require","_array","_string","_customs","_operators","_latex","_factory","name","dependencies","factory","_ref","Node","OperatorNode","op","fn","args","implicit","SyntaxError","TypeError","Array","isArray","every","isNode","prototype","type","isOperatorNode","_compile","math","argNames","isSafeMethod","Error","getSafeProperty","evalArgs","map","arg","length","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","apply","evalArg","forEach","callback","i","_ifNode","clone","slice","isUnary","isBinary","calculateNecessaryParentheses","root","parenthesis","latex","precedence","getPrecedence","associativity","getAssociativity","getIdentifier","getContent","result","operandPrecedence","operandIdentifier","rootIdentifier","properties","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","isAssociativeWith","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","index","isParenthesisNode","_toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","join","toJSON","mathjs","fromJSON","json","toHTML","escape","_toTex","latexOperators","toTex","concat","lhsTex","rhsTex","texifiedArgs","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOperatorNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n\n    var fn = (0, _customs.getSafeProperty)(math, this.fn);\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis);\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // is the root node associative with the left hand side\n\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis); // is the root node associative with the right hand side?\n\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis);\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toString(options);\n\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      } // for example for \"not\", we want a space between operand and argument\n\n\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + (opIsNamed ? ' ' : '') + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + (opIsNamed ? ' ' : '') + this.op;\n      } // fall back to postfix\n\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toHTML(options);\n\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>' + operand;\n      } else {\n        // postfix when assoc === 'left' or undefined\n        return operand + '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>';\n      }\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = _latex.latexOperators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toTex(options);\n\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n\n      var lhsIdentifier;\n\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          break;\n\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n\n      }\n\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n\n        return arg;\n      });\n\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createOperatorNode = createOperatorNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}