{"ast":null,"code":"\"use strict\";\n\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar frame_1 = __importDefault(require(\"../core/frame\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\nvar Merge = /** @class */function () {\n  function Merge(_a) {\n    var left = _a.left,\n      right = _a.right,\n      on = _a.on,\n      how = _a.how;\n    this.leftColIndex = [];\n    this.rightColIndex = [];\n    this.left = left;\n    this.right = right;\n    this.on = on;\n    this.how = how;\n    //Obtain the column index of the column will\n    //want to merge on for both left and right dataframe\n    for (var i = 0; i < this.on.length; i++) {\n      var key = this.on[i];\n      if (this.left.columns.includes(key) && this.right.columns.includes(key)) {\n        var leftIndex = this.left.columns.indexOf(key);\n        var rightIndex = this.right.columns.indexOf(key);\n        this.leftColIndex.push(leftIndex);\n        this.rightColIndex.push(rightIndex);\n      }\n    }\n  }\n  /**\n   * Generate key combination base on the columns we want to merge on\n   * e.g  df = {\n   *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n   *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n   *  A: [1,2,3,4]\n   *  B: [3,4,5,6]\n   * }\n   * keycomb = generateKeyCombination(df.values, [0,1])\n   * This should output\n   * {\n   *  'k0_k1': {\n   *      filters: [[1,3], [2,4]], # the value of other columns in thesame row with the combination keys\n   *      combValues: [\"KO\", \"k1\"] # the combination key from column Key1 (index 2) and key2 (index 1)\n   *  },\n   *  'K3_K3 : {\n   *      filters: [[3,5]],\n   *      combValues: ['K3', 'k3']\n   *  },\n   *  'k4_k5' : {\n   *      filters: [[4,6]]\n   *      combValues: ['K4', 'K5']\n   *  }\n   * }\n   * This key combination will be generated for both left and right dataframe\n   * @param values\n   * @param colIndex\n   */\n  Merge.prototype.generateKeyCombination = function (values, colIndex) {\n    var colKeyComb = {};\n    for (var i = 0; i < values.length; i++) {\n      var rowValues = values[i];\n      var rowKeyCombValues = [];\n      for (var j = 0; j < colIndex.length; j++) {\n        var index = colIndex[j];\n        rowKeyCombValues.push(rowValues[index]);\n      }\n      var rowKeyComb = rowKeyCombValues.join('_');\n      var otherValues = rowValues.filter(function (val, index) {\n        return !colIndex.includes(index);\n      });\n      if (utils.keyInObject(colKeyComb, rowKeyComb)) {\n        colKeyComb[rowKeyComb].filters.push(otherValues);\n      } else {\n        colKeyComb[rowKeyComb] = {\n          filters: [otherValues],\n          combValues: rowKeyCombValues\n        };\n      }\n    }\n    return colKeyComb;\n  };\n  /**\n   * Generate columns for the newly generated merged DataFrame\n   * e.g df = {\n   *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n   *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n   *  A: [1,2,3,4]\n   *  B: [3,4,5,6]\n   * }\n   * df2 = {\n   *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n   *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n   *  A: [1,2,3,4]\n   *  c: [3,4,5,6]\n   * }\n   * And both dataframe are to be merged on `key1` and `key2`\n   * the newly generated column will be of the form\n   * columns = ['key1', 'Key2', 'A', 'A_1', 'B', 'C']\n   * Notice 'A_1' , this because both DataFrame as column A and 1 is the\n   * number of duplicate of that column\n   */\n  Merge.prototype.createColumns = function () {\n    var self = this;\n    this.leftCol = self.left.columns.filter(function (_, index) {\n      return !self.leftColIndex.includes(index);\n    });\n    this.rightCol = self.right.columns.filter(function (_, index) {\n      return !self.rightColIndex.includes(index);\n    });\n    this.columns = __spreadArray([], this.on, true);\n    var duplicateColumn = {};\n    var tempColumn = __spreadArray([], this.leftCol, true);\n    tempColumn.push.apply(tempColumn, this.rightCol);\n    for (var i = 0; i < tempColumn.length; i++) {\n      var col = tempColumn[i];\n      if (utils.keyInObject(duplicateColumn, col)) {\n        var columnName = col + \"_\" + duplicateColumn[col];\n        this.columns.push(columnName);\n        duplicateColumn[col] += 1;\n      } else {\n        this.columns.push(col);\n        duplicateColumn[col] = 1;\n      }\n    }\n  };\n  /**\n   * The basic methos perform the underneath operation of generating\n   * the merge dataframe; using the combination keys generated from\n   * bothe left and right DataFrame\n   * e.g df = {\n   *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n   *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n   *  A: [1,2,3,4]\n   *  B: [3,4,5,6]\n   * }\n   * df2 = {\n   *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n   *  Key2: [\"K1\", \"K2\", \"K4\", \"K5\"],\n   *  A: [3,6,8,9]\n   *  c: [2,4,6,8]\n   * }\n   * Running generatekeyCombination on both left and right data frame\n   * we should have\n   * leftKeyDict = {\n   *  'k0_k1': {\n   *      filters: [[1,3], [2,4]],\n   *      combValues: [\"KO\", \"k1\"]\n   *  },\n   *  'K3_K3' : {\n   *      filters: [[3,5]],\n   *      combValues: ['K3', 'k3']\n   *  },\n   *  'k4_k5' : {\n   *      filters: [[4,6]]\n   *      combValues: ['K4', 'K5']\n   *  }\n   * }\n   * rightKeyDict = {\n   *  'k0_k1': {\n   *      filters: [[3,2]],\n   *      combValues: [\"KO\", \"k1\"]\n   *  },\n   *  'K0_K2': {\n   *      filters: [[6,4]],\n   *      combValues: ['K0', 'K2']\n   *  },\n   *  'K3_K4' : {\n   *      filters: [[8,9]],\n   *      combValues: ['K3', 'k4']\n   *  },\n   *  'k4_k5' : {\n   *      filters: [[9,8]]\n   *      combValues: ['K4', 'K5']\n   *  }\n   * }\n   * The `keys` is generated base on the type of merge operation we want to\n   * perform. If we assume we are performing `outer` merge (which is a set of the\n   * key combination from both leftKeyDict and rightKeyDict) then Keys should be\n   * this\n   * keys = ['K0_K1', 'K3_K3', 'k4_k5', 'K0_K2', 'k3_k4']\n   * The Keys, leftKeyDict and rightKeyDict are used to generated DataFrame data,\n   * by looping through the Keys and checking if leftKeyDict and rightKeyDict as the\n   * key if one of them does not the column in that row will be NaN\n   * e.g Data for each row base on keys\n   * COLUMNS = ['key1', 'Key2', 'A', 'B', 'A_1', 'C']\n   * 'K0_K1':  ['K0',   'K1',   1,    3 ,   3,   2 ]\n   * 'K0_K1':  ['K0',   'K1',   2,    4,   NaN, NaN]\n   * 'K3_K3':  ['k3',   'K3',   3,    5,  NaN,  NaN]\n   * 'K4_K5':  ['K4',   'K5',   4,    6,  9,    8]\n   * 'k0_K2':  ['k0',   'K2'    NaN,  NaN, 6,   4]\n   * 'k3_k4':  ['K3',   'K4',   NaN,  NaN, 8, 6]\n   *\n   * @param keys\n   * @param leftKeyDict\n   * @param rightKeyDict\n   */\n  Merge.prototype.basic = function (keys, leftKeyDict, rightKeyDict) {\n    var _a, _b;\n    var data = [];\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (utils.keyInObject(leftKeyDict, key)) {\n        var leftRows = leftKeyDict[key].filters;\n        var leftCombValues = leftKeyDict[key].combValues;\n        for (var lIndex = 0; lIndex < leftRows.length; lIndex++) {\n          var leftRow = leftRows[lIndex];\n          if (utils.keyInObject(rightKeyDict, key)) {\n            var rightRows = rightKeyDict[key].filters;\n            for (var rIndex = 0; rIndex < rightRows.length; rIndex++) {\n              var rightRow = rightRows[rIndex];\n              var combineData = leftCombValues.slice(0);\n              combineData.push.apply(combineData, leftRow);\n              combineData.push.apply(combineData, rightRow);\n              data.push(combineData);\n            }\n          } else {\n            var nanArray = Array((_a = this.rightCol) === null || _a === void 0 ? void 0 : _a.length).fill(NaN);\n            var combineData = leftCombValues.slice(0);\n            combineData.push.apply(combineData, leftRow);\n            combineData.push.apply(combineData, nanArray);\n            data.push(combineData);\n          }\n        }\n      } else {\n        var rightRows = rightKeyDict[key].filters;\n        var rightCombValues = rightKeyDict[key].combValues;\n        for (var i_1 = 0; i_1 < rightRows.length; i_1++) {\n          var rightRow = rightRows[i_1];\n          var nanArray = Array((_b = this.leftCol) === null || _b === void 0 ? void 0 : _b.length).fill(NaN);\n          var combineData = rightCombValues.slice(0);\n          combineData.push.apply(combineData, nanArray);\n          combineData.push.apply(combineData, rightRow);\n          data.push(combineData);\n        }\n      }\n    }\n    return data;\n  };\n  /**\n   * Generate outer key from leftKeyDict and rightKeyDict\n   * The Key pass into basic method is the union of\n   * leftKeyDict and rightKeyDict\n   * @param leftKeyDict\n   * @param rightKeyDict\n   */\n  Merge.prototype.outer = function (leftKeyDict, rightKeyDict) {\n    var keys = Object.keys(leftKeyDict);\n    keys.push.apply(keys, Object.keys(rightKeyDict));\n    var UniqueKeys = Array.from(new Set(keys));\n    var data = this.basic(UniqueKeys, leftKeyDict, rightKeyDict);\n    return data;\n  };\n  /**\n   * Generate Key for basic method,\n   * the key geneerated is the intersection of\n   * leftKeyDict and rightKeyDict\n   * @param leftKeyDict\n   * @param rightKeyDict\n   */\n  Merge.prototype.inner = function (leftKeyDict, rightKeyDict) {\n    var leftKey = Object.keys(leftKeyDict);\n    var rightKey = Object.keys(rightKeyDict);\n    var keys = leftKey.filter(function (val) {\n      return rightKey.includes(val);\n    });\n    var data = this.basic(keys, leftKeyDict, rightKeyDict);\n    return data;\n  };\n  /**\n   * The key is the leftKeyDict\n   * @param leftKeyDict\n   * @param rightKeyDict\n   */\n  Merge.prototype.leftMerge = function (leftKeyDict, rightKeyDict) {\n    var keys = Object.keys(leftKeyDict);\n    var data = this.basic(keys, leftKeyDict, rightKeyDict);\n    return data;\n  };\n  /**\n   * The key is the rightKeyDict\n   * @param leftKeyDict\n   * @param rightKeyDict\n   */\n  Merge.prototype.rightMerge = function (leftKeyDict, rightKeyDict) {\n    var keys = Object.keys(rightKeyDict);\n    var data = this.basic(keys, leftKeyDict, rightKeyDict);\n    return data;\n  };\n  /**\n   * Perform the merge operation\n   * 1) Obtain both left and right dataframe values\n   * 2) Generate the leftkeyDict and rightKeyDict\n   * 3) Generate new merge columns\n   * 4) check how merge is to be done and apply the\n   * right methods\n   */\n  Merge.prototype.operation = function () {\n    var leftValues = this.left.values;\n    var rightValues = this.right.values;\n    var leftKeyDict = this.generateKeyCombination(leftValues, this.leftColIndex);\n    var rightKeyDict = this.generateKeyCombination(rightValues, this.rightColIndex);\n    this.createColumns();\n    var data = [];\n    switch (this.how) {\n      case \"outer\":\n        data = this.outer(leftKeyDict, rightKeyDict);\n        break;\n      case \"inner\":\n        data = this.inner(leftKeyDict, rightKeyDict);\n        break;\n      case \"left\":\n        data = this.leftMerge(leftKeyDict, rightKeyDict);\n        break;\n      case \"right\":\n        data = this.rightMerge(leftKeyDict, rightKeyDict);\n        break;\n    }\n    var columns = this.columns;\n    return new frame_1.default(data, {\n      columns: __spreadArray([], columns, true)\n    });\n  };\n  return Merge;\n}();\n/**\n * Perform merge operation between two DataFrame\n * @param params : {\n * left: DataFrame\n * right: DataFrame\n * on: Array<string>\n * how: \"outer\" | \"inner\" | \"left\" | \"right\"\n * }\n */\nfunction merge(params) {\n  var mergeClass = new Merge(params);\n  return mergeClass.operation();\n}\nexports.default = merge;","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","__importDefault","mod","__esModule","Object","defineProperty","exports","value","frame_1","require","utils_1","utils","default","Merge","_a","left","right","on","how","leftColIndex","rightColIndex","key","columns","includes","leftIndex","indexOf","rightIndex","push","generateKeyCombination","values","colIndex","colKeyComb","rowValues","rowKeyCombValues","j","index","rowKeyComb","join","otherValues","filter","val","keyInObject","filters","combValues","createColumns","self","leftCol","_","rightCol","duplicateColumn","tempColumn","apply","col","columnName","basic","keys","leftKeyDict","rightKeyDict","_b","data","leftRows","leftCombValues","lIndex","leftRow","rightRows","rIndex","rightRow","combineData","nanArray","fill","NaN","rightCombValues","i_1","outer","UniqueKeys","Set","inner","leftKey","rightKey","leftMerge","rightMerge","operation","leftValues","rightValues","merge","params","mergeClass"],"sources":["/Users/omarbailey/node_modules/danfojs/dist/danfojs-base/transformers/merge.js"],"sourcesContent":["\"use strict\";\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar frame_1 = __importDefault(require(\"../core/frame\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\nvar Merge = /** @class */ (function () {\n    function Merge(_a) {\n        var left = _a.left, right = _a.right, on = _a.on, how = _a.how;\n        this.leftColIndex = [];\n        this.rightColIndex = [];\n        this.left = left;\n        this.right = right;\n        this.on = on;\n        this.how = how;\n        //Obtain the column index of the column will\n        //want to merge on for both left and right dataframe\n        for (var i = 0; i < this.on.length; i++) {\n            var key = this.on[i];\n            if (this.left.columns.includes(key) && this.right.columns.includes(key)) {\n                var leftIndex = this.left.columns.indexOf(key);\n                var rightIndex = this.right.columns.indexOf(key);\n                this.leftColIndex.push(leftIndex);\n                this.rightColIndex.push(rightIndex);\n            }\n        }\n    }\n    /**\n     * Generate key combination base on the columns we want to merge on\n     * e.g  df = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  B: [3,4,5,6]\n     * }\n     * keycomb = generateKeyCombination(df.values, [0,1])\n     * This should output\n     * {\n     *  'k0_k1': {\n     *      filters: [[1,3], [2,4]], # the value of other columns in thesame row with the combination keys\n     *      combValues: [\"KO\", \"k1\"] # the combination key from column Key1 (index 2) and key2 (index 1)\n     *  },\n     *  'K3_K3 : {\n     *      filters: [[3,5]],\n     *      combValues: ['K3', 'k3']\n     *  },\n     *  'k4_k5' : {\n     *      filters: [[4,6]]\n     *      combValues: ['K4', 'K5']\n     *  }\n     * }\n     * This key combination will be generated for both left and right dataframe\n     * @param values\n     * @param colIndex\n     */\n    Merge.prototype.generateKeyCombination = function (values, colIndex) {\n        var colKeyComb = {};\n        for (var i = 0; i < values.length; i++) {\n            var rowValues = values[i];\n            var rowKeyCombValues = [];\n            for (var j = 0; j < colIndex.length; j++) {\n                var index = colIndex[j];\n                rowKeyCombValues.push(rowValues[index]);\n            }\n            var rowKeyComb = rowKeyCombValues.join('_');\n            var otherValues = rowValues.filter(function (val, index) {\n                return !colIndex.includes(index);\n            });\n            if (utils.keyInObject(colKeyComb, rowKeyComb)) {\n                colKeyComb[rowKeyComb].filters.push(otherValues);\n            }\n            else {\n                colKeyComb[rowKeyComb] = {\n                    filters: [otherValues],\n                    combValues: rowKeyCombValues\n                };\n            }\n        }\n        return colKeyComb;\n    };\n    /**\n     * Generate columns for the newly generated merged DataFrame\n     * e.g df = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  B: [3,4,5,6]\n     * }\n     * df2 = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  c: [3,4,5,6]\n     * }\n     * And both dataframe are to be merged on `key1` and `key2`\n     * the newly generated column will be of the form\n     * columns = ['key1', 'Key2', 'A', 'A_1', 'B', 'C']\n     * Notice 'A_1' , this because both DataFrame as column A and 1 is the\n     * number of duplicate of that column\n     */\n    Merge.prototype.createColumns = function () {\n        var self = this;\n        this.leftCol = self.left.columns.filter(function (_, index) {\n            return !self.leftColIndex.includes(index);\n        });\n        this.rightCol = self.right.columns.filter(function (_, index) {\n            return !self.rightColIndex.includes(index);\n        });\n        this.columns = __spreadArray([], this.on, true);\n        var duplicateColumn = {};\n        var tempColumn = __spreadArray([], this.leftCol, true);\n        tempColumn.push.apply(tempColumn, this.rightCol);\n        for (var i = 0; i < tempColumn.length; i++) {\n            var col = tempColumn[i];\n            if (utils.keyInObject(duplicateColumn, col)) {\n                var columnName = col + \"_\" + duplicateColumn[col];\n                this.columns.push(columnName);\n                duplicateColumn[col] += 1;\n            }\n            else {\n                this.columns.push(col);\n                duplicateColumn[col] = 1;\n            }\n        }\n    };\n    /**\n     * The basic methos perform the underneath operation of generating\n     * the merge dataframe; using the combination keys generated from\n     * bothe left and right DataFrame\n     * e.g df = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  B: [3,4,5,6]\n     * }\n     * df2 = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K2\", \"K4\", \"K5\"],\n     *  A: [3,6,8,9]\n     *  c: [2,4,6,8]\n     * }\n     * Running generatekeyCombination on both left and right data frame\n     * we should have\n     * leftKeyDict = {\n     *  'k0_k1': {\n     *      filters: [[1,3], [2,4]],\n     *      combValues: [\"KO\", \"k1\"]\n     *  },\n     *  'K3_K3' : {\n     *      filters: [[3,5]],\n     *      combValues: ['K3', 'k3']\n     *  },\n     *  'k4_k5' : {\n     *      filters: [[4,6]]\n     *      combValues: ['K4', 'K5']\n     *  }\n     * }\n     * rightKeyDict = {\n     *  'k0_k1': {\n     *      filters: [[3,2]],\n     *      combValues: [\"KO\", \"k1\"]\n     *  },\n     *  'K0_K2': {\n     *      filters: [[6,4]],\n     *      combValues: ['K0', 'K2']\n     *  },\n     *  'K3_K4' : {\n     *      filters: [[8,9]],\n     *      combValues: ['K3', 'k4']\n     *  },\n     *  'k4_k5' : {\n     *      filters: [[9,8]]\n     *      combValues: ['K4', 'K5']\n     *  }\n     * }\n     * The `keys` is generated base on the type of merge operation we want to\n     * perform. If we assume we are performing `outer` merge (which is a set of the\n     * key combination from both leftKeyDict and rightKeyDict) then Keys should be\n     * this\n     * keys = ['K0_K1', 'K3_K3', 'k4_k5', 'K0_K2', 'k3_k4']\n     * The Keys, leftKeyDict and rightKeyDict are used to generated DataFrame data,\n     * by looping through the Keys and checking if leftKeyDict and rightKeyDict as the\n     * key if one of them does not the column in that row will be NaN\n     * e.g Data for each row base on keys\n     * COLUMNS = ['key1', 'Key2', 'A', 'B', 'A_1', 'C']\n     * 'K0_K1':  ['K0',   'K1',   1,    3 ,   3,   2 ]\n     * 'K0_K1':  ['K0',   'K1',   2,    4,   NaN, NaN]\n     * 'K3_K3':  ['k3',   'K3',   3,    5,  NaN,  NaN]\n     * 'K4_K5':  ['K4',   'K5',   4,    6,  9,    8]\n     * 'k0_K2':  ['k0',   'K2'    NaN,  NaN, 6,   4]\n     * 'k3_k4':  ['K3',   'K4',   NaN,  NaN, 8, 6]\n     *\n     * @param keys\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.basic = function (keys, leftKeyDict, rightKeyDict) {\n        var _a, _b;\n        var data = [];\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (utils.keyInObject(leftKeyDict, key)) {\n                var leftRows = leftKeyDict[key].filters;\n                var leftCombValues = leftKeyDict[key].combValues;\n                for (var lIndex = 0; lIndex < leftRows.length; lIndex++) {\n                    var leftRow = leftRows[lIndex];\n                    if (utils.keyInObject(rightKeyDict, key)) {\n                        var rightRows = rightKeyDict[key].filters;\n                        for (var rIndex = 0; rIndex < rightRows.length; rIndex++) {\n                            var rightRow = rightRows[rIndex];\n                            var combineData = leftCombValues.slice(0);\n                            combineData.push.apply(combineData, leftRow);\n                            combineData.push.apply(combineData, rightRow);\n                            data.push(combineData);\n                        }\n                    }\n                    else {\n                        var nanArray = Array((_a = this.rightCol) === null || _a === void 0 ? void 0 : _a.length).fill(NaN);\n                        var combineData = leftCombValues.slice(0);\n                        combineData.push.apply(combineData, leftRow);\n                        combineData.push.apply(combineData, nanArray);\n                        data.push(combineData);\n                    }\n                }\n            }\n            else {\n                var rightRows = rightKeyDict[key].filters;\n                var rightCombValues = rightKeyDict[key].combValues;\n                for (var i_1 = 0; i_1 < rightRows.length; i_1++) {\n                    var rightRow = rightRows[i_1];\n                    var nanArray = Array((_b = this.leftCol) === null || _b === void 0 ? void 0 : _b.length).fill(NaN);\n                    var combineData = rightCombValues.slice(0);\n                    combineData.push.apply(combineData, nanArray);\n                    combineData.push.apply(combineData, rightRow);\n                    data.push(combineData);\n                }\n            }\n        }\n        return data;\n    };\n    /**\n     * Generate outer key from leftKeyDict and rightKeyDict\n     * The Key pass into basic method is the union of\n     * leftKeyDict and rightKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.outer = function (leftKeyDict, rightKeyDict) {\n        var keys = Object.keys(leftKeyDict);\n        keys.push.apply(keys, Object.keys(rightKeyDict));\n        var UniqueKeys = Array.from(new Set(keys));\n        var data = this.basic(UniqueKeys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * Generate Key for basic method,\n     * the key geneerated is the intersection of\n     * leftKeyDict and rightKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.inner = function (leftKeyDict, rightKeyDict) {\n        var leftKey = Object.keys(leftKeyDict);\n        var rightKey = Object.keys(rightKeyDict);\n        var keys = leftKey.filter(function (val) { return rightKey.includes(val); });\n        var data = this.basic(keys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * The key is the leftKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.leftMerge = function (leftKeyDict, rightKeyDict) {\n        var keys = Object.keys(leftKeyDict);\n        var data = this.basic(keys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * The key is the rightKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.rightMerge = function (leftKeyDict, rightKeyDict) {\n        var keys = Object.keys(rightKeyDict);\n        var data = this.basic(keys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * Perform the merge operation\n     * 1) Obtain both left and right dataframe values\n     * 2) Generate the leftkeyDict and rightKeyDict\n     * 3) Generate new merge columns\n     * 4) check how merge is to be done and apply the\n     * right methods\n     */\n    Merge.prototype.operation = function () {\n        var leftValues = this.left.values;\n        var rightValues = this.right.values;\n        var leftKeyDict = this.generateKeyCombination(leftValues, this.leftColIndex);\n        var rightKeyDict = this.generateKeyCombination(rightValues, this.rightColIndex);\n        this.createColumns();\n        var data = [];\n        switch (this.how) {\n            case \"outer\":\n                data = this.outer(leftKeyDict, rightKeyDict);\n                break;\n            case \"inner\":\n                data = this.inner(leftKeyDict, rightKeyDict);\n                break;\n            case \"left\":\n                data = this.leftMerge(leftKeyDict, rightKeyDict);\n                break;\n            case \"right\":\n                data = this.rightMerge(leftKeyDict, rightKeyDict);\n                break;\n        }\n        var columns = this.columns;\n        return new frame_1.default(data, { columns: __spreadArray([], columns, true) });\n    };\n    return Merge;\n}());\n/**\n * Perform merge operation between two DataFrame\n * @param params : {\n * left: DataFrame\n * right: DataFrame\n * on: Array<string>\n * how: \"outer\" | \"inner\" | \"left\" | \"right\"\n * }\n */\nfunction merge(params) {\n    var mergeClass = new Merge(params);\n    return mergeClass.operation();\n}\nexports.default = merge;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}