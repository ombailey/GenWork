{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTranspose = void 0;\nvar _object = require(\"../../utils/object.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nvar createTranspose = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix;\n\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed('transpose', {\n    Array: function Array(x) {\n      // use dense matrix implementation\n      return this(matrix(x)).valueOf();\n    },\n    Matrix: function Matrix(x) {\n      // matrix size\n      var size = x.size(); // result\n\n      var c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n        case 2:\n          {\n            // rows and columns\n            var rows = size[0];\n            var columns = size[1]; // check columns\n\n            if (columns === 0) {\n              // throw exception\n              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + (0, _string.format)(size) + ')');\n            } // process storage format\n\n            switch (x.storage()) {\n              case 'dense':\n                c = _denseTranspose(x, rows, columns);\n                break;\n              case 'sparse':\n                c = _sparseTranspose(x, rows, columns);\n                break;\n            }\n          }\n          break;\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + (0, _string.format)(this._size) + ')');\n      }\n      return c;\n    },\n    // scalars\n    any: function any(x) {\n      return (0, _object.clone)(x);\n    }\n  });\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = (0, _object.clone)(data[i][j]);\n      }\n    } // return matrix\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = (0, _object.clone)(values[k]);\n        }\n      }\n    } // return matrix\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});\nexports.createTranspose = createTranspose;","map":{"version":3,"names":["Object","defineProperty","exports","value","createTranspose","_object","require","_string","_factory","name","dependencies","factory","_ref","typed","matrix","Array","x","valueOf","Matrix","size","c","length","clone","rows","columns","RangeError","format","storage","_denseTranspose","_sparseTranspose","_size","any","m","data","_data","transposed","transposedRow","j","i","createDenseMatrix","datatype","_datatype","values","_values","index","_index","ptr","_ptr","cvalues","undefined","cindex","cptr","w","p","l","sum","push","k0","k1","k","q","createSparseMatrix"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/matrix/transpose.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTranspose = void 0;\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nvar createTranspose = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix;\n\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed('transpose', {\n    Array: function Array(x) {\n      // use dense matrix implementation\n      return this(matrix(x)).valueOf();\n    },\n    Matrix: function Matrix(x) {\n      // matrix size\n      var size = x.size(); // result\n\n      var c; // process dimensions\n\n      switch (size.length) {\n        case 1:\n          // vector\n          c = x.clone();\n          break;\n\n        case 2:\n          {\n            // rows and columns\n            var rows = size[0];\n            var columns = size[1]; // check columns\n\n            if (columns === 0) {\n              // throw exception\n              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + (0, _string.format)(size) + ')');\n            } // process storage format\n\n\n            switch (x.storage()) {\n              case 'dense':\n                c = _denseTranspose(x, rows, columns);\n                break;\n\n              case 'sparse':\n                c = _sparseTranspose(x, rows, columns);\n                break;\n            }\n          }\n          break;\n\n        default:\n          // multi dimensional\n          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + (0, _string.format)(this._size) + ')');\n      }\n\n      return c;\n    },\n    // scalars\n    any: function any(x) {\n      return (0, _object.clone)(x);\n    }\n  });\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = (0, _object.clone)(data[i][j]);\n      }\n    } // return matrix\n\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = (0, _object.clone)(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});\nexports.createTranspose = createTranspose;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}