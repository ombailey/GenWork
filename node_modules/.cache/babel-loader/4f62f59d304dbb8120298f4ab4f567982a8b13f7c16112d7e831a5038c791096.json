{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLsolve = void 0;\nvar _factory = require(\"../../../utils/factory.js\");\nvar _solveValidation = require(\"./utils/solveValidation.js\");\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nvar createLsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix,\n    divideScalar = _ref.divideScalar,\n    multiplyScalar = _ref.multiplyScalar,\n    subtract = _ref.subtract,\n    equalScalar = _ref.equalScalar,\n    DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lsolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n      var r = _denseForwardSubstitution(m, b);\n      return r.valueOf();\n    }\n  });\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = [];\n    var mdata = m._data; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      var xj = void 0;\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = mdata[j][j];\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // degenerate row, we can choose any value\n        xj = 0;\n      }\n      x[j] = [xj];\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result\n\n    var x = []; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = 0; // matrix values & indices (column j)\n\n        var jValues = [];\n        var jIndices = []; // first and last index in the column\n\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j]\n\n        for (var k = firstIndex; k < lastIndex; k++) {\n          var i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        } // at this point we must have a value in vjj\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        var xj = divideScalar(bj, vjj);\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\n        }\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});\nexports.createLsolve = createLsolve;","map":{"version":3,"names":["Object","defineProperty","exports","value","createLsolve","_factory","require","_solveValidation","name","dependencies","factory","_ref","typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix","solveValidation","createSolveValidation","SparseMatrixArrayMatrix","m","b","_sparseForwardSubstitution","DenseMatrixArrayMatrix","_denseForwardSubstitution","ArrayArrayMatrix","a","r","valueOf","bdata","_data","rows","_size","columns","x","mdata","j","bj","xj","vjj","Error","i","data","size","values","_values","index","_index","ptr","_ptr","jValues","jIndices","firstIndex","lastIndex","k","push","_k","l","length","_i"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/solver/lsolve.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLsolve = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nvar createLsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lsolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var r = _denseForwardSubstitution(m, b);\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = [];\n    var mdata = m._data; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      var xj = void 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = mdata[j][j];\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // degenerate row, we can choose any value\n        xj = 0;\n      }\n\n      x[j] = [xj];\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result\n\n    var x = []; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = 0; // matrix values & indices (column j)\n\n        var jValues = [];\n        var jIndices = []; // first and last index in the column\n\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j]\n\n        for (var k = firstIndex; k < lastIndex; k++) {\n          var i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        } // at this point we must have a value in vjj\n\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        var xj = divideScalar(bj, vjj);\n\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\n        }\n\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});\nexports.createLsolve = createLsolve;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}