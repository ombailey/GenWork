{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._genericMathOp = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"./series\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Generic function for performing math operations on a series\n * @param object\n *\n * ndframe ==> The current Series\n *\n * other ==> The Series or number to perform math operation with\n *\n * operation ==> The type of operation to perform\n*/\nfunction _genericMathOp(_a) {\n  var ndFrame = _a.ndFrame,\n    other = _a.other,\n    operation = _a.operation;\n  if (typeof other === 'number') {\n    //broadcast operation\n    var newData = void 0;\n    switch (operation) {\n      case 'add':\n        newData = ndFrame.values.map(function (ele) {\n          return ele + other;\n        });\n        return newData;\n      case 'sub':\n        newData = ndFrame.values.map(function (ele) {\n          return ele - other;\n        });\n        return newData;\n      case 'mul':\n        newData = ndFrame.values.map(function (ele) {\n          return ele * other;\n        });\n        return newData;\n      case 'div':\n        newData = ndFrame.values.map(function (ele) {\n          return ele / other;\n        });\n        return newData;\n      case 'mod':\n        newData = ndFrame.values.map(function (ele) {\n          return ele % other;\n        });\n        return newData;\n      case 'pow':\n        newData = ndFrame.values.map(function (ele) {\n          return Math.pow(ele, other);\n        });\n        return newData;\n      case 'minimum':\n        newData = ndFrame.values.map(function (ele) {\n          return Math.min(ele, other);\n        });\n        return newData;\n      case 'maximum':\n        newData = ndFrame.values.map(function (ele) {\n          return Math.max(ele, other);\n        });\n        return newData;\n      default:\n        throw new Error(operation + \" is not implemented\");\n    }\n  } else if (other instanceof series_1.default) {\n    utils.checkSeriesOpCompactibility({\n      firstSeries: ndFrame,\n      secondSeries: other,\n      operation: operation\n    });\n    var newData = void 0;\n    switch (operation) {\n      case 'add':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele + other.values[index];\n        });\n        return newData;\n      case 'sub':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele - other.values[index];\n        });\n        return newData;\n      case 'mul':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele * other.values[index];\n        });\n        return newData;\n      case 'div':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele / other.values[index];\n        });\n        return newData;\n      case 'mod':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele % other.values[index];\n        });\n        return newData;\n      case 'pow':\n        newData = ndFrame.values.map(function (ele, index) {\n          return Math.pow(ele, other.values[index]);\n        });\n        return newData;\n      case 'minimum':\n        newData = ndFrame.values.map(function (ele, index) {\n          return Math.min(ele, other.values[index]);\n        });\n        return newData;\n      case 'maximum':\n        newData = ndFrame.values.map(function (ele, index) {\n          return Math.max(ele, other.values[index]);\n        });\n        return newData;\n      default:\n        throw new Error(operation + \" is not implemented\");\n    }\n  } else if (Array.isArray(other)) {\n    if (other.length !== ndFrame.values.length) {\n      throw new Error(\"ParamError: Length of array must be equal to length of Series\");\n    }\n    var newData = void 0;\n    switch (operation) {\n      case 'add':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele + other[index];\n        });\n        return newData;\n      case 'sub':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele - other[index];\n        });\n        return newData;\n      case 'mul':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele * other[index];\n        });\n        return newData;\n      case 'div':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele / other[index];\n        });\n        return newData;\n      case 'mod':\n        newData = ndFrame.values.map(function (ele, index) {\n          return ele % other[index];\n        });\n        return newData;\n      case 'pow':\n        newData = ndFrame.values.map(function (ele, index) {\n          return Math.pow(ele, other[index]);\n        });\n        return newData;\n      case 'minimum':\n        newData = ndFrame.values.map(function (ele, index) {\n          return Math.min(ele, other[index]);\n        });\n        return newData;\n      case 'maximum':\n        newData = ndFrame.values.map(function (ele, index) {\n          return Math.max(ele, other[index]);\n        });\n        return newData;\n    }\n  } else {\n    throw new Error(\"ParamError: value for other not supported. It must be either a scalar, Array or Series\");\n  }\n}\nexports._genericMathOp = _genericMathOp;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","_genericMathOp","series_1","require","utils_1","utils","default","_a","ndFrame","other","operation","newData","values","map","ele","Math","pow","min","max","Error","checkSeriesOpCompactibility","firstSeries","secondSeries","index","Array","isArray","length"],"sources":["/Users/omarbailey/node_modules/danfojs/dist/danfojs-base/core/math.ops.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._genericMathOp = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"./series\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Generic function for performing math operations on a series\n * @param object\n *\n * ndframe ==> The current Series\n *\n * other ==> The Series or number to perform math operation with\n *\n * operation ==> The type of operation to perform\n*/\nfunction _genericMathOp(_a) {\n    var ndFrame = _a.ndFrame, other = _a.other, operation = _a.operation;\n    if (typeof other === 'number') {\n        //broadcast operation\n        var newData = void 0;\n        switch (operation) {\n            case 'add':\n                newData = ndFrame.values.map((function (ele) { return ele + other; }));\n                return newData;\n            case 'sub':\n                newData = ndFrame.values.map((function (ele) { return ele - other; }));\n                return newData;\n            case 'mul':\n                newData = ndFrame.values.map((function (ele) { return ele * other; }));\n                return newData;\n            case 'div':\n                newData = ndFrame.values.map((function (ele) { return ele / other; }));\n                return newData;\n            case 'mod':\n                newData = ndFrame.values.map((function (ele) { return ele % other; }));\n                return newData;\n            case 'pow':\n                newData = ndFrame.values.map((function (ele) { return Math.pow(ele, other); }));\n                return newData;\n            case 'minimum':\n                newData = ndFrame.values.map((function (ele) { return Math.min(ele, other); }));\n                return newData;\n            case 'maximum':\n                newData = ndFrame.values.map((function (ele) { return Math.max(ele, other); }));\n                return newData;\n            default:\n                throw new Error(operation + \" is not implemented\");\n        }\n    }\n    else if (other instanceof series_1.default) {\n        utils.checkSeriesOpCompactibility({ firstSeries: ndFrame, secondSeries: other, operation: operation });\n        var newData = void 0;\n        switch (operation) {\n            case 'add':\n                newData = ndFrame.values.map(function (ele, index) { return ele + other.values[index]; });\n                return newData;\n            case 'sub':\n                newData = ndFrame.values.map(function (ele, index) { return ele - other.values[index]; });\n                return newData;\n            case 'mul':\n                newData = ndFrame.values.map(function (ele, index) { return ele * other.values[index]; });\n                return newData;\n            case 'div':\n                newData = ndFrame.values.map(function (ele, index) { return ele / other.values[index]; });\n                return newData;\n            case 'mod':\n                newData = ndFrame.values.map(function (ele, index) { return ele % other.values[index]; });\n                return newData;\n            case 'pow':\n                newData = ndFrame.values.map(function (ele, index) { return Math.pow(ele, other.values[index]); });\n                return newData;\n            case 'minimum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.min(ele, other.values[index]); });\n                return newData;\n            case 'maximum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.max(ele, other.values[index]); });\n                return newData;\n            default:\n                throw new Error(operation + \" is not implemented\");\n        }\n    }\n    else if (Array.isArray(other)) {\n        if (other.length !== ndFrame.values.length) {\n            throw new Error(\"ParamError: Length of array must be equal to length of Series\");\n        }\n        var newData = void 0;\n        switch (operation) {\n            case 'add':\n                newData = ndFrame.values.map(function (ele, index) { return ele + other[index]; });\n                return newData;\n            case 'sub':\n                newData = ndFrame.values.map(function (ele, index) { return ele - other[index]; });\n                return newData;\n            case 'mul':\n                newData = ndFrame.values.map(function (ele, index) { return ele * other[index]; });\n                return newData;\n            case 'div':\n                newData = ndFrame.values.map(function (ele, index) { return ele / other[index]; });\n                return newData;\n            case 'mod':\n                newData = ndFrame.values.map(function (ele, index) { return ele % other[index]; });\n                return newData;\n            case 'pow':\n                newData = ndFrame.values.map(function (ele, index) { return Math.pow(ele, other[index]); });\n                return newData;\n            case 'minimum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.min(ele, other[index]); });\n                return newData;\n            case 'maximum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.max(ele, other[index]); });\n                return newData;\n        }\n    }\n    else {\n        throw new Error(\"ParamError: value for other not supported. It must be either a scalar, Array or Series\");\n    }\n}\nexports._genericMathOp = _genericMathOp;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAG,KAAK,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,QAAQ,GAAGR,eAAe,CAACS,OAAO,CAAC,UAAU,CAAC,CAAC;AACnD,IAAIC,OAAO,GAAGV,eAAe,CAACS,OAAO,CAAC,iBAAiB,CAAC,CAAC;AACzD,IAAIE,KAAK,GAAG,IAAID,OAAO,CAACE,OAAO,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,cAAc,CAACM,EAAE,EAAE;EACxB,IAAIC,OAAO,GAAGD,EAAE,CAACC,OAAO;IAAEC,KAAK,GAAGF,EAAE,CAACE,KAAK;IAAEC,SAAS,GAAGH,EAAE,CAACG,SAAS;EACpE,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;IAC3B;IACA,IAAIE,OAAO,GAAG,KAAK,CAAC;IACpB,QAAQD,SAAS;MACb,KAAK,KAAK;QACNC,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOA,GAAG,GAAGL,KAAK;QAAE,CAAC,CAAE;QACtE,OAAOE,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOA,GAAG,GAAGL,KAAK;QAAE,CAAC,CAAE;QACtE,OAAOE,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOA,GAAG,GAAGL,KAAK;QAAE,CAAC,CAAE;QACtE,OAAOE,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOA,GAAG,GAAGL,KAAK;QAAE,CAAC,CAAE;QACtE,OAAOE,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOA,GAAG,GAAGL,KAAK;QAAE,CAAC,CAAE;QACtE,OAAOE,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOC,IAAI,CAACC,GAAG,CAACF,GAAG,EAAEL,KAAK,CAAC;QAAE,CAAC,CAAE;QAC/E,OAAOE,OAAO;MAClB,KAAK,SAAS;QACVA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOC,IAAI,CAACE,GAAG,CAACH,GAAG,EAAEL,KAAK,CAAC;QAAE,CAAC,CAAE;QAC/E,OAAOE,OAAO;MAClB,KAAK,SAAS;QACVA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAE,UAAUC,GAAG,EAAE;UAAE,OAAOC,IAAI,CAACG,GAAG,CAACJ,GAAG,EAAEL,KAAK,CAAC;QAAE,CAAC,CAAE;QAC/E,OAAOE,OAAO;MAClB;QACI,MAAM,IAAIQ,KAAK,CAACT,SAAS,GAAG,qBAAqB,CAAC;IAAC;EAE/D,CAAC,MACI,IAAID,KAAK,YAAYP,QAAQ,CAACI,OAAO,EAAE;IACxCD,KAAK,CAACe,2BAA2B,CAAC;MAAEC,WAAW,EAAEb,OAAO;MAAEc,YAAY,EAAEb,KAAK;MAAEC,SAAS,EAAEA;IAAU,CAAC,CAAC;IACtG,IAAIC,OAAO,GAAG,KAAK,CAAC;IACpB,QAAQD,SAAS;MACb,KAAK,KAAK;QACNC,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC;QAAE,CAAC,CAAC;QACzF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC;QAAE,CAAC,CAAC;QACzF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC;QAAE,CAAC,CAAC;QACzF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC;QAAE,CAAC,CAAC;QACzF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC;QAAE,CAAC,CAAC;QACzF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOR,IAAI,CAACC,GAAG,CAACF,GAAG,EAAEL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC;QAClG,OAAOZ,OAAO;MAClB,KAAK,SAAS;QACVA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOR,IAAI,CAACE,GAAG,CAACH,GAAG,EAAEL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC;QAClG,OAAOZ,OAAO;MAClB,KAAK,SAAS;QACVA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOR,IAAI,CAACG,GAAG,CAACJ,GAAG,EAAEL,KAAK,CAACG,MAAM,CAACW,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC;QAClG,OAAOZ,OAAO;MAClB;QACI,MAAM,IAAIQ,KAAK,CAACT,SAAS,GAAG,qBAAqB,CAAC;IAAC;EAE/D,CAAC,MACI,IAAIc,KAAK,CAACC,OAAO,CAAChB,KAAK,CAAC,EAAE;IAC3B,IAAIA,KAAK,CAACiB,MAAM,KAAKlB,OAAO,CAACI,MAAM,CAACc,MAAM,EAAE;MACxC,MAAM,IAAIP,KAAK,CAAC,+DAA+D,CAAC;IACpF;IACA,IAAIR,OAAO,GAAG,KAAK,CAAC;IACpB,QAAQD,SAAS;MACb,KAAK,KAAK;QACNC,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACc,KAAK,CAAC;QAAE,CAAC,CAAC;QAClF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACc,KAAK,CAAC;QAAE,CAAC,CAAC;QAClF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACc,KAAK,CAAC;QAAE,CAAC,CAAC;QAClF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACc,KAAK,CAAC;QAAE,CAAC,CAAC;QAClF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOT,GAAG,GAAGL,KAAK,CAACc,KAAK,CAAC;QAAE,CAAC,CAAC;QAClF,OAAOZ,OAAO;MAClB,KAAK,KAAK;QACNA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOR,IAAI,CAACC,GAAG,CAACF,GAAG,EAAEL,KAAK,CAACc,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC;QAC3F,OAAOZ,OAAO;MAClB,KAAK,SAAS;QACVA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOR,IAAI,CAACE,GAAG,CAACH,GAAG,EAAEL,KAAK,CAACc,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC;QAC3F,OAAOZ,OAAO;MAClB,KAAK,SAAS;QACVA,OAAO,GAAGH,OAAO,CAACI,MAAM,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAES,KAAK,EAAE;UAAE,OAAOR,IAAI,CAACG,GAAG,CAACJ,GAAG,EAAEL,KAAK,CAACc,KAAK,CAAC,CAAC;QAAE,CAAC,CAAC;QAC3F,OAAOZ,OAAO;IAAC;EAE3B,CAAC,MACI;IACD,MAAM,IAAIQ,KAAK,CAAC,wFAAwF,CAAC;EAC7G;AACJ;AACApB,OAAO,CAACE,cAAc,GAAGA,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}