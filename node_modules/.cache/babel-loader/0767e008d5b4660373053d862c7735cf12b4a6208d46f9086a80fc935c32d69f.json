{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConditionalNode = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _operators = require(\"../operators.js\");\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (!(0, _is.isNode)(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!(0, _is.isNode)(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!(0, _is.isNode)(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n    if (condition) {\n      if ((0, _is.isBigNumber)(condition)) {\n        return !condition.isZero();\n      }\n      if ((0, _is.isComplex)(condition)) {\n        return !!(condition.re || condition.im);\n      }\n      if ((0, _is.isUnit)(condition)) {\n        return !!condition.value;\n      }\n    }\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n    throw new TypeError('Unsupported type of condition \"' + (0, _is.typeOf)(condition) + '\"');\n  }\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createConditionalNode = createConditionalNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createConditionalNode","_is","require","_factory","_operators","name","dependencies","factory","_ref","Node","ConditionalNode","condition","trueExpr","falseExpr","SyntaxError","isNode","TypeError","prototype","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","testCondition","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","getPrecedence","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isBigNumber","isZero","isComplex","re","im","isUnit","undefined","typeOf","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConditionalNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!(0, _is.isNode)(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!(0, _is.isNode)(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!(0, _is.isNode)(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if ((0, _is.isBigNumber)(condition)) {\n        return !condition.isZero();\n      }\n\n      if ((0, _is.isComplex)(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if ((0, _is.isUnit)(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + (0, _is.typeOf)(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createConditionalNode = createConditionalNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}