{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMode = void 0;\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'mode';\nvar dependencies = ['typed', 'isNaN', 'isNumeric'];\nvar createMode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    isNaN = _ref.isNaN,\n    isNumeric = _ref.isNumeric;\n\n  /**\n  * Computes the mode of a set of numbers or a list with values(numbers or characters).\n  * If there are more than one modes, it returns a list of those values.\n  *\n  * Syntax:\n  *\n  *     math.mode(a, b, c, ...)\n  *     math.mode(A)\n  *\n  * Examples:\n  *\n  *     math.mode(2, 1, 4, 3, 1)                            // returns [1]\n  *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]\n  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]\n  *     math.mode('a','a','b','c')                           // returns [\"a\"]\n  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, \"abc\"]\n  *\n  * See also:\n  *\n  *     median,\n  *     mean\n  *\n  * @param {... *} args  A single matrix\n  * @return {*} The mode of all values\n  */\n  return typed(name, {\n    'Array | Matrix': _mode,\n    '...': function _(args) {\n      return _mode(args);\n    }\n  });\n  /**\n   * Calculates the mode in an 1-dimensional array\n   * @param {Array} values\n   * @return {Array} mode\n   * @private\n   */\n\n  function _mode(values) {\n    values = (0, _array.flatten)(values.valueOf());\n    var num = values.length;\n    if (num === 0) {\n      throw new Error('Cannot calculate mode of an empty array');\n    }\n    var count = {};\n    var mode = [];\n    var max = 0;\n    for (var i = 0; i < values.length; i++) {\n      var value = values[i];\n      if (isNumeric(value) && isNaN(value)) {\n        throw new Error('Cannot calculate mode of an array containing NaN values');\n      }\n      if (!(value in count)) {\n        count[value] = 0;\n      }\n      count[value]++;\n      if (count[value] === max) {\n        mode.push(value);\n      } else if (count[value] > max) {\n        max = count[value];\n        mode = [value];\n      }\n    }\n    return mode;\n  }\n});\nexports.createMode = createMode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createMode","_array","require","_factory","name","dependencies","factory","_ref","typed","isNaN","isNumeric","_mode","_","args","values","flatten","valueOf","num","length","Error","count","mode","max","i","push"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/statistics/mode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMode = void 0;\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'mode';\nvar dependencies = ['typed', 'isNaN', 'isNumeric'];\nvar createMode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      isNaN = _ref.isNaN,\n      isNumeric = _ref.isNumeric;\n\n  /**\n  * Computes the mode of a set of numbers or a list with values(numbers or characters).\n  * If there are more than one modes, it returns a list of those values.\n  *\n  * Syntax:\n  *\n  *     math.mode(a, b, c, ...)\n  *     math.mode(A)\n  *\n  * Examples:\n  *\n  *     math.mode(2, 1, 4, 3, 1)                            // returns [1]\n  *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]\n  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]\n  *     math.mode('a','a','b','c')                           // returns [\"a\"]\n  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, \"abc\"]\n  *\n  * See also:\n  *\n  *     median,\n  *     mean\n  *\n  * @param {... *} args  A single matrix\n  * @return {*} The mode of all values\n  */\n  return typed(name, {\n    'Array | Matrix': _mode,\n    '...': function _(args) {\n      return _mode(args);\n    }\n  });\n  /**\n   * Calculates the mode in an 1-dimensional array\n   * @param {Array} values\n   * @return {Array} mode\n   * @private\n   */\n\n  function _mode(values) {\n    values = (0, _array.flatten)(values.valueOf());\n    var num = values.length;\n\n    if (num === 0) {\n      throw new Error('Cannot calculate mode of an empty array');\n    }\n\n    var count = {};\n    var mode = [];\n    var max = 0;\n\n    for (var i = 0; i < values.length; i++) {\n      var value = values[i];\n\n      if (isNumeric(value) && isNaN(value)) {\n        throw new Error('Cannot calculate mode of an array containing NaN values');\n      }\n\n      if (!(value in count)) {\n        count[value] = 0;\n      }\n\n      count[value]++;\n\n      if (count[value] === max) {\n        mode.push(value);\n      } else if (count[value] > max) {\n        max = count[value];\n        mode = [value];\n      }\n    }\n\n    return mode;\n  }\n});\nexports.createMode = createMode;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,UAAU,GAAG,KAAK,CAAC;AAE3B,IAAIC,MAAM,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAE5C,IAAIC,QAAQ,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AAEhD,IAAIE,IAAI,GAAG,MAAM;AACjB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,WAAW,CAAC;AAClD,IAAIL,UAAU,GAAG,eAAe,CAAC,CAAC,EAAEG,QAAQ,CAACG,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EACxF,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK;IAClBC,KAAK,GAAGF,IAAI,CAACE,KAAK;IAClBC,SAAS,GAAGH,IAAI,CAACG,SAAS;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOF,KAAK,CAACJ,IAAI,EAAE;IACjB,gBAAgB,EAAEO,KAAK;IACvB,KAAK,EAAE,SAASC,CAAC,CAACC,IAAI,EAAE;MACtB,OAAOF,KAAK,CAACE,IAAI,CAAC;IACpB;EACF,CAAC,CAAC;EACF;AACF;AACA;AACA;AACA;AACA;;EAEE,SAASF,KAAK,CAACG,MAAM,EAAE;IACrBA,MAAM,GAAG,CAAC,CAAC,EAAEb,MAAM,CAACc,OAAO,EAAED,MAAM,CAACE,OAAO,EAAE,CAAC;IAC9C,IAAIC,GAAG,GAAGH,MAAM,CAACI,MAAM;IAEvB,IAAID,GAAG,KAAK,CAAC,EAAE;MACb,MAAM,IAAIE,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IAEA,IAAIC,KAAK,GAAG,CAAC,CAAC;IACd,IAAIC,IAAI,GAAG,EAAE;IACb,IAAIC,GAAG,GAAG,CAAC;IAEX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAACI,MAAM,EAAEK,CAAC,EAAE,EAAE;MACtC,IAAIxB,KAAK,GAAGe,MAAM,CAACS,CAAC,CAAC;MAErB,IAAIb,SAAS,CAACX,KAAK,CAAC,IAAIU,KAAK,CAACV,KAAK,CAAC,EAAE;QACpC,MAAM,IAAIoB,KAAK,CAAC,yDAAyD,CAAC;MAC5E;MAEA,IAAI,EAAEpB,KAAK,IAAIqB,KAAK,CAAC,EAAE;QACrBA,KAAK,CAACrB,KAAK,CAAC,GAAG,CAAC;MAClB;MAEAqB,KAAK,CAACrB,KAAK,CAAC,EAAE;MAEd,IAAIqB,KAAK,CAACrB,KAAK,CAAC,KAAKuB,GAAG,EAAE;QACxBD,IAAI,CAACG,IAAI,CAACzB,KAAK,CAAC;MAClB,CAAC,MAAM,IAAIqB,KAAK,CAACrB,KAAK,CAAC,GAAGuB,GAAG,EAAE;QAC7BA,GAAG,GAAGF,KAAK,CAACrB,KAAK,CAAC;QAClBsB,IAAI,GAAG,CAACtB,KAAK,CAAC;MAChB;IACF;IAEA,OAAOsB,IAAI;EACb;AACF,CAAC,CAAC;AACFvB,OAAO,CAACE,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}