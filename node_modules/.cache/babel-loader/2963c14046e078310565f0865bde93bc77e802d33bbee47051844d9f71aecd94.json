{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createKldivergence = void 0;\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];\nvar createKldivergence = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix,\n    divide = _ref.divide,\n    sum = _ref.sum,\n    multiply = _ref.multiply,\n    dotDivide = _ref.dotDivide,\n    log = _ref.log,\n    isNumeric = _ref.isNumeric;\n\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    } // Before calculation, apply normalization\n\n    var sumq = sum(q);\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n    var sump = sum(p);\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});\nexports.createKldivergence = createKldivergence;","map":{"version":3,"names":["Object","defineProperty","exports","value","createKldivergence","_factory","require","name","dependencies","factory","_ref","typed","matrix","divide","sum","multiply","dotDivide","log","isNumeric","ArrayArray","q","p","_kldiv","MatrixArray","ArrayMatrix","MatrixMatrix","plength","size","length","qlength","Error","sumq","sump","qnorm","pnorm","result","Number","NaN"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/probability/kldivergence.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createKldivergence = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];\nvar createKldivergence = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divide = _ref.divide,\n      sum = _ref.sum,\n      multiply = _ref.multiply,\n      dotDivide = _ref.dotDivide,\n      log = _ref.log,\n      isNumeric = _ref.isNumeric;\n\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    } // Before calculation, apply normalization\n\n\n    var sumq = sum(q);\n\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n\n    var sump = sum(p);\n\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));\n\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});\nexports.createKldivergence = createKldivergence;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}