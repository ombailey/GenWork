{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createIndexNode = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _customs = require(\"../../utils/customs.js\");\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nvar createIndexNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n    Node = _ref.Node,\n    size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = (0, _array.map)(this.dimensions, function (range, i) {\n      if ((0, _is.isRangeNode)(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n          var evalStart = range.start._compile(math, childArgNames);\n          var evalEnd = range.end._compile(math, childArgNames);\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n          var _evalEnd = range.end._compile(math, argNames);\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if ((0, _is.isSymbolNode)(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n        _childArgNames.end = true;\n        var evalRange = range._compile(math, _childArgNames);\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = (0, _customs.getSafeProperty)(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = (0, _array.map)(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, (0, _toConsumableArray2[\"default\"])(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && (0, _is.isConstantNode)(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + (0, _string.escape)(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n  function createRange(start, end, step) {\n    return new Range((0, _is.isBigNumber)(start) ? start.toNumber() : start, (0, _is.isBigNumber)(end) ? end.toNumber() : end, (0, _is.isBigNumber)(step) ? step.toNumber() : step);\n  }\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createIndexNode = createIndexNode;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createIndexNode","_toConsumableArray2","_is","_array","_string","_factory","_customs","name","dependencies","factory","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","Array","isArray","every","isNode","TypeError","isObjectProperty","Error","prototype","type","isIndexNode","_compile","math","argNames","evalDimensions","map","range","i","isRangeNode","needsEnd","childArgNames","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","isSymbolNode","_childArgNames","evalRange","_evalRange","index","getSafeProperty","evalIndexNode","apply","forEach","callback","length","_ifNode","clone","slice","isConstantNode","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","escape","_toTex","toTex","isBigNumber","toNumber","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/IndexNode.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createIndexNode = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nvar createIndexNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = (0, _array.map)(this.dimensions, function (range, i) {\n      if ((0, _is.isRangeNode)(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if ((0, _is.isSymbolNode)(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = (0, _customs.getSafeProperty)(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = (0, _array.map)(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, (0, _toConsumableArray2[\"default\"])(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && (0, _is.isConstantNode)(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + (0, _string.escape)(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range((0, _is.isBigNumber)(start) ? start.toNumber() : start, (0, _is.isBigNumber)(end) ? end.toNumber() : end, (0, _is.isBigNumber)(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createIndexNode = createIndexNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}