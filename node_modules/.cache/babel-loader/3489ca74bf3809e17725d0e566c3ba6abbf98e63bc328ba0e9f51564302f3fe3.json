{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBlockNode = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'BlockNode';\nvar dependencies = ['ResultSet', 'Node'];\nvar createBlockNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var ResultSet = _ref.ResultSet,\n    Node = _ref.Node;\n\n  /**\n   * @constructor BlockNode\n   * @extends {Node}\n   * Holds a set with blocks\n   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\n   *            An array with blocks, where a block is constructed as an Object\n   *            with properties block, which is a Node, and visible, which is\n   *            a boolean. The property visible is optional and is true by default\n   */\n  function BlockNode(blocks) {\n    if (!(this instanceof BlockNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input, copy blocks\n\n    if (!Array.isArray(blocks)) throw new Error('Array expected');\n    this.blocks = blocks.map(function (block) {\n      var node = block && block.node;\n      var visible = block && block.visible !== undefined ? block.visible : true;\n      if (!(0, _is.isNode)(node)) throw new TypeError('Property \"node\" must be a Node');\n      if (typeof visible !== 'boolean') throw new TypeError('Property \"visible\" must be a boolean');\n      return {\n        node: node,\n        visible: visible\n      };\n    });\n  }\n  BlockNode.prototype = new Node();\n  BlockNode.prototype.type = 'BlockNode';\n  BlockNode.prototype.isBlockNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  BlockNode.prototype._compile = function (math, argNames) {\n    var evalBlocks = (0, _array.map)(this.blocks, function (block) {\n      return {\n        evaluate: block.node._compile(math, argNames),\n        visible: block.visible\n      };\n    });\n    return function evalBlockNodes(scope, args, context) {\n      var results = [];\n      (0, _array.forEach)(evalBlocks, function evalBlockNode(block) {\n        var result = block.evaluate(scope, args, context);\n        if (block.visible) {\n          results.push(result);\n        }\n      });\n      return new ResultSet(results);\n    };\n  };\n  /**\n   * Execute a callback for each of the child blocks of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  BlockNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.blocks.length; i++) {\n      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n    }\n  };\n  /**\n   * Create a new BlockNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {BlockNode} Returns a transformed copy of the node\n   */\n\n  BlockNode.prototype.map = function (callback) {\n    var blocks = [];\n    for (var i = 0; i < this.blocks.length; i++) {\n      var block = this.blocks[i];\n      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n      blocks[i] = {\n        node: node,\n        visible: block.visible\n      };\n    }\n    return new BlockNode(blocks);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {BlockNode}\n   */\n\n  BlockNode.prototype.clone = function () {\n    var blocks = this.blocks.map(function (block) {\n      return {\n        node: block.node,\n        visible: block.visible\n      };\n    });\n    return new BlockNode(blocks);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  BlockNode.prototype._toString = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toString(options) + (param.visible ? '' : ';');\n    }).join('\\n');\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  BlockNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'BlockNode',\n      blocks: this.blocks\n    };\n  };\n  /**\n   * Instantiate an BlockNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\n   *                       where mathjs is optional\n   * @returns {BlockNode}\n   */\n\n  BlockNode.fromJSON = function (json) {\n    return new BlockNode(json.blocks);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  BlockNode.prototype.toHTML = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n    }).join('<span class=\"math-separator\"><br /></span>');\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  BlockNode.prototype._toTex = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toTex(options) + (param.visible ? '' : ';');\n    }).join('\\\\;\\\\;\\n');\n  };\n  return BlockNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createBlockNode = createBlockNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createBlockNode","_is","require","_array","_factory","name","dependencies","factory","_ref","ResultSet","Node","BlockNode","blocks","SyntaxError","Array","isArray","Error","map","block","node","visible","undefined","isNode","TypeError","prototype","type","isBlockNode","_compile","math","argNames","evalBlocks","evaluate","evalBlockNodes","scope","args","context","results","forEach","evalBlockNode","result","push","callback","i","length","_ifNode","clone","_toString","options","param","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/BlockNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBlockNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'BlockNode';\nvar dependencies = ['ResultSet', 'Node'];\nvar createBlockNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var ResultSet = _ref.ResultSet,\n      Node = _ref.Node;\n\n  /**\n   * @constructor BlockNode\n   * @extends {Node}\n   * Holds a set with blocks\n   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\n   *            An array with blocks, where a block is constructed as an Object\n   *            with properties block, which is a Node, and visible, which is\n   *            a boolean. The property visible is optional and is true by default\n   */\n  function BlockNode(blocks) {\n    if (!(this instanceof BlockNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input, copy blocks\n\n\n    if (!Array.isArray(blocks)) throw new Error('Array expected');\n    this.blocks = blocks.map(function (block) {\n      var node = block && block.node;\n      var visible = block && block.visible !== undefined ? block.visible : true;\n      if (!(0, _is.isNode)(node)) throw new TypeError('Property \"node\" must be a Node');\n      if (typeof visible !== 'boolean') throw new TypeError('Property \"visible\" must be a boolean');\n      return {\n        node: node,\n        visible: visible\n      };\n    });\n  }\n\n  BlockNode.prototype = new Node();\n  BlockNode.prototype.type = 'BlockNode';\n  BlockNode.prototype.isBlockNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  BlockNode.prototype._compile = function (math, argNames) {\n    var evalBlocks = (0, _array.map)(this.blocks, function (block) {\n      return {\n        evaluate: block.node._compile(math, argNames),\n        visible: block.visible\n      };\n    });\n    return function evalBlockNodes(scope, args, context) {\n      var results = [];\n      (0, _array.forEach)(evalBlocks, function evalBlockNode(block) {\n        var result = block.evaluate(scope, args, context);\n\n        if (block.visible) {\n          results.push(result);\n        }\n      });\n      return new ResultSet(results);\n    };\n  };\n  /**\n   * Execute a callback for each of the child blocks of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  BlockNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.blocks.length; i++) {\n      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n    }\n  };\n  /**\n   * Create a new BlockNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {BlockNode} Returns a transformed copy of the node\n   */\n\n\n  BlockNode.prototype.map = function (callback) {\n    var blocks = [];\n\n    for (var i = 0; i < this.blocks.length; i++) {\n      var block = this.blocks[i];\n\n      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n\n      blocks[i] = {\n        node: node,\n        visible: block.visible\n      };\n    }\n\n    return new BlockNode(blocks);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {BlockNode}\n   */\n\n\n  BlockNode.prototype.clone = function () {\n    var blocks = this.blocks.map(function (block) {\n      return {\n        node: block.node,\n        visible: block.visible\n      };\n    });\n    return new BlockNode(blocks);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  BlockNode.prototype._toString = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toString(options) + (param.visible ? '' : ';');\n    }).join('\\n');\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  BlockNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'BlockNode',\n      blocks: this.blocks\n    };\n  };\n  /**\n   * Instantiate an BlockNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\n   *                       where mathjs is optional\n   * @returns {BlockNode}\n   */\n\n\n  BlockNode.fromJSON = function (json) {\n    return new BlockNode(json.blocks);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  BlockNode.prototype.toHTML = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n    }).join('<span class=\"math-separator\"><br /></span>');\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  BlockNode.prototype._toTex = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toTex(options) + (param.visible ? '' : ';');\n    }).join('\\\\;\\\\;\\n');\n  };\n\n  return BlockNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createBlockNode = createBlockNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}