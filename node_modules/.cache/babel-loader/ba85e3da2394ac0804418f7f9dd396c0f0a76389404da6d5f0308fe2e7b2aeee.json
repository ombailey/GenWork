{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compileInlineExpression = compileInlineExpression;\nvar _is = require(\"../../../utils/is.js\");\nvar _scope = require(\"../../../utils/scope.js\");\n\n/**\n * Compile an inline expression like \"x > 0\"\n * @param {Node} expression\n * @param {Object} math\n * @param {Object} scope\n * @return {function} Returns a function with one argument which fills in the\n *                    undefined variable (like \"x\") and evaluates the expression\n */\nfunction compileInlineExpression(expression, math, scope) {\n  // find an undefined symbol\n  var symbol = expression.filter(function (node) {\n    return (0, _is.isSymbolNode)(node) && !(node.name in math) && !scope.has(node.name);\n  })[0];\n  if (!symbol) {\n    throw new Error('No undefined variable found in inline expression \"' + expression + '\"');\n  } // create a test function for this equation\n\n  var name = symbol.name; // variable name\n\n  var subScope = (0, _scope.createSubScope)(scope);\n  var eq = expression.compile();\n  return function inlineExpression(x) {\n    subScope.set(name, x);\n    return eq.evaluate(subScope);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","compileInlineExpression","_is","require","_scope","expression","math","scope","symbol","filter","node","isSymbolNode","name","has","Error","subScope","createSubScope","eq","compile","inlineExpression","x","set","evaluate"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/transform/utils/compileInlineExpression.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compileInlineExpression = compileInlineExpression;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _scope = require(\"../../../utils/scope.js\");\n\n/**\n * Compile an inline expression like \"x > 0\"\n * @param {Node} expression\n * @param {Object} math\n * @param {Object} scope\n * @return {function} Returns a function with one argument which fills in the\n *                    undefined variable (like \"x\") and evaluates the expression\n */\nfunction compileInlineExpression(expression, math, scope) {\n  // find an undefined symbol\n  var symbol = expression.filter(function (node) {\n    return (0, _is.isSymbolNode)(node) && !(node.name in math) && !scope.has(node.name);\n  })[0];\n\n  if (!symbol) {\n    throw new Error('No undefined variable found in inline expression \"' + expression + '\"');\n  } // create a test function for this equation\n\n\n  var name = symbol.name; // variable name\n\n  var subScope = (0, _scope.createSubScope)(scope);\n  var eq = expression.compile();\n  return function inlineExpression(x) {\n    subScope.set(name, x);\n    return eq.evaluate(subScope);\n  };\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,uBAAuB,GAAGA,uBAAuB;AAEzD,IAAIC,GAAG,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAEzC,IAAIC,MAAM,GAAGD,OAAO,CAAC,yBAAyB,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,uBAAuB,CAACI,UAAU,EAAEC,IAAI,EAAEC,KAAK,EAAE;EACxD;EACA,IAAIC,MAAM,GAAGH,UAAU,CAACI,MAAM,CAAC,UAAUC,IAAI,EAAE;IAC7C,OAAO,CAAC,CAAC,EAAER,GAAG,CAACS,YAAY,EAAED,IAAI,CAAC,IAAI,EAAEA,IAAI,CAACE,IAAI,IAAIN,IAAI,CAAC,IAAI,CAACC,KAAK,CAACM,GAAG,CAACH,IAAI,CAACE,IAAI,CAAC;EACrF,CAAC,CAAC,CAAC,CAAC,CAAC;EAEL,IAAI,CAACJ,MAAM,EAAE;IACX,MAAM,IAAIM,KAAK,CAAC,oDAAoD,GAAGT,UAAU,GAAG,GAAG,CAAC;EAC1F,CAAC,CAAC;;EAGF,IAAIO,IAAI,GAAGJ,MAAM,CAACI,IAAI,CAAC,CAAC;;EAExB,IAAIG,QAAQ,GAAG,CAAC,CAAC,EAAEX,MAAM,CAACY,cAAc,EAAET,KAAK,CAAC;EAChD,IAAIU,EAAE,GAAGZ,UAAU,CAACa,OAAO,EAAE;EAC7B,OAAO,SAASC,gBAAgB,CAACC,CAAC,EAAE;IAClCL,QAAQ,CAACM,GAAG,CAACT,IAAI,EAAEQ,CAAC,CAAC;IACrB,OAAOH,EAAE,CAACK,QAAQ,CAACP,QAAQ,CAAC;EAC9B,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}