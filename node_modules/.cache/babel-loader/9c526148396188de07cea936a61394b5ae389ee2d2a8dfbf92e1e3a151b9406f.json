{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPrecedence = getPrecedence;\nexports.getAssociativity = getAssociativity;\nexports.isAssociativeWith = isAssociativeWith;\nexports.properties = void 0;\nvar _object = require(\"../utils/object.js\");\n\n// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nvar properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n  },\n\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n  },\n\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {number | null}\n */\n\nexports.properties = properties;\nfunction getPrecedence(_node, parenthesis) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifier];\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifierA];\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n    return false;\n  } // associativeWith is not defined\n\n  return null;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getPrecedence","getAssociativity","isAssociativeWith","properties","_object","require","AssignmentNode","FunctionAssignmentNode","ConditionalNode","latexLeftParens","latexRightParens","latexParens","associativity","associativeWith","RelationalNode","RangeNode","_node","parenthesis","node","getContent","identifier","getIdentifier","i","length","index","property","hasOwnProperty","Error","nodeA","nodeB","a","b","identifierA","identifierB","Array"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/operators.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPrecedence = getPrecedence;\nexports.getAssociativity = getAssociativity;\nexports.isAssociativeWith = isAssociativeWith;\nexports.properties = void 0;\n\nvar _object = require(\"../utils/object.js\");\n\n// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nvar properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {number | null}\n */\n\nexports.properties = properties;\n\nfunction getPrecedence(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\n\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\n\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}