{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../../core/frame\"));\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Generate one-hot encoding for categorical columns in an Array, Series or Dataframe.\n * @param data Series or Dataframe\n * @param columns Columns to encode\n * @param prefix Prefix for the new columns\n * @param prefixSeparator Separator for the prefix and the column name\n * @returns Encoded Dataframe\n * @example\n * import { DataFrame, DummyEncoder }from 'danfojs';\n * const df = new DataFrame([[1,2,3], [4,5,6]], { columns: ['a', 'b', 'c'] });\n * const df2 = new DummyEncoder({data: df, columns: ['a', 'b'], prefix: 'enc', prefixSeparator: '#'}).encode();\n * df2.print();\n */\nfunction dummyEncode(data, options) {\n  var _a = __assign({\n      columns: null,\n      prefix: null,\n      prefixSeparator: \"_\"\n    }, options),\n    columns = _a.columns,\n    prefix = _a.prefix,\n    prefixSeparator = _a.prefixSeparator;\n  if (!data) {\n    throw new Error('ParamError: data must be one of Array, Series or DataFrame');\n  }\n  if (data instanceof series_1.default || data instanceof frame_1.default) {\n    if (!columns) {\n      var colsWithStringDtype_1 = [];\n      data.dtypes.forEach(function (dtype, index) {\n        if (dtype === \"string\") {\n          colsWithStringDtype_1.push(data.columns[index]);\n        }\n      });\n      columns = colsWithStringDtype_1;\n    }\n  } else {\n    throw new Error('ParamError: data must be one of Array, Series or DataFrame');\n  }\n  if (typeof columns === \"string\") {\n    columns = [columns];\n    if (Array.isArray(prefix) && prefix.length === 1) {\n      prefix = prefix;\n    } else if (typeof prefix === \"string\") {\n      prefix = [prefix];\n    } else {\n      throw new Error('ParamError: prefix must be a string, or an array of same length as columns');\n    }\n    if (Array.isArray(prefixSeparator) && prefixSeparator.length === 1) {\n      prefixSeparator = prefixSeparator;\n    } else if (typeof prefixSeparator === \"string\") {\n      prefixSeparator = [prefixSeparator];\n    } else {\n      throw new Error('ParamError: prefix must be a string, or an array of same length as columns');\n    }\n  } else if (Array.isArray(columns)) {\n    if (prefix) {\n      if (Array.isArray(prefix) && prefix.length !== columns.length) {\n        throw new Error(\"ParamError: prefix and data array must be of the same length. If you need to use the same prefix, then pass a string param instead. e.g {prefix: \\\"\" + prefix + \"\\\"}\");\n      }\n      if (typeof prefix === \"string\") {\n        prefix = columns.map(function (_) {\n          return prefix;\n        });\n      }\n    }\n    if (prefixSeparator) {\n      if (Array.isArray(prefixSeparator) && prefixSeparator.length !== columns.length) {\n        throw new Error(\"ParamError: prefixSeparator and data array must be of the same length. If you need to use the same prefix separator, then pass a string param instead. e.g {prefixSeparator: \\\"\" + prefixSeparator + \"\\\"}\");\n      }\n      if (typeof prefixSeparator === \"string\") {\n        prefixSeparator = columns.map(function (_) {\n          return prefixSeparator;\n        });\n      }\n    }\n  } else {\n    throw new Error('ParamError: columns must be a string or an array of strings');\n  }\n  if (data instanceof series_1.default) {\n    var colData = data.values;\n    var newColumnNames = [];\n    var uniqueValues = Array.from(new Set(colData));\n    var oneHotArr = utils.zeros(colData.length, uniqueValues.length);\n    for (var i = 0; i < colData.length; i++) {\n      var index = uniqueValues.indexOf(colData[i]);\n      oneHotArr[i][index] = 1;\n    }\n    for (var i = 0; i < uniqueValues.length; i++) {\n      var prefixToAdd = prefix ? prefix[0] : i;\n      newColumnNames.push(\"\" + prefixToAdd + prefixSeparator[0] + uniqueValues[i]);\n    }\n    return new frame_1.default(oneHotArr, {\n      columns: newColumnNames\n    });\n  } else {\n    var dfWithSelectedColumnsDropped = data.drop({\n      columns: columns\n    });\n    var newData = dfWithSelectedColumnsDropped === null || dfWithSelectedColumnsDropped === void 0 ? void 0 : dfWithSelectedColumnsDropped.values;\n    var newColumnNames = dfWithSelectedColumnsDropped === null || dfWithSelectedColumnsDropped === void 0 ? void 0 : dfWithSelectedColumnsDropped.columns;\n    for (var i = 0; i < columns.length; i++) {\n      var column = columns[i];\n      var colData = data.column(column).values;\n      var uniqueValues = Array.from(new Set(colData));\n      var oneHotArr = utils.zeros(colData.length, uniqueValues.length);\n      for (var j = 0; j < colData.length; j++) {\n        var index = uniqueValues.indexOf(colData[j]);\n        oneHotArr[j][index] = 1;\n        var prefixToAdd = prefix ? prefix[i] : column;\n        var newColName = \"\" + prefixToAdd + prefixSeparator[i] + colData[j];\n        if (!newColumnNames.includes(newColName)) {\n          newColumnNames.push(newColName);\n        }\n      }\n      for (var k = 0; k < newData.length; k++) {\n        newData[k] = __spreadArray(__spreadArray([], newData[k], true), oneHotArr[k], true);\n      }\n    }\n    return new frame_1.default(newData, {\n      columns: newColumnNames\n    });\n  }\n}\nexports.default = dummyEncode;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","__importDefault","mod","__esModule","defineProperty","exports","value","frame_1","require","series_1","utils_1","utils","default","dummyEncode","data","options","_a","columns","prefix","prefixSeparator","Error","colsWithStringDtype_1","dtypes","forEach","dtype","index","push","isArray","map","_","colData","values","newColumnNames","uniqueValues","Set","oneHotArr","zeros","indexOf","prefixToAdd","dfWithSelectedColumnsDropped","drop","newData","column","j","newColName","includes","k"],"sources":["/Users/omarbailey/node_modules/danfojs/dist/danfojs-base/transformers/encoders/dummy.encoder.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../../core/frame\"));\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Generate one-hot encoding for categorical columns in an Array, Series or Dataframe.\n * @param data Series or Dataframe\n * @param columns Columns to encode\n * @param prefix Prefix for the new columns\n * @param prefixSeparator Separator for the prefix and the column name\n * @returns Encoded Dataframe\n * @example\n * import { DataFrame, DummyEncoder }from 'danfojs';\n * const df = new DataFrame([[1,2,3], [4,5,6]], { columns: ['a', 'b', 'c'] });\n * const df2 = new DummyEncoder({data: df, columns: ['a', 'b'], prefix: 'enc', prefixSeparator: '#'}).encode();\n * df2.print();\n */\nfunction dummyEncode(data, options) {\n    var _a = __assign({ columns: null, prefix: null, prefixSeparator: \"_\" }, options), columns = _a.columns, prefix = _a.prefix, prefixSeparator = _a.prefixSeparator;\n    if (!data) {\n        throw new Error('ParamError: data must be one of Array, Series or DataFrame');\n    }\n    if (data instanceof series_1.default || data instanceof frame_1.default) {\n        if (!columns) {\n            var colsWithStringDtype_1 = [];\n            data.dtypes.forEach(function (dtype, index) {\n                if (dtype === \"string\") {\n                    colsWithStringDtype_1.push(data.columns[index]);\n                }\n            });\n            columns = colsWithStringDtype_1;\n        }\n    }\n    else {\n        throw new Error('ParamError: data must be one of Array, Series or DataFrame');\n    }\n    if (typeof columns === \"string\") {\n        columns = [columns];\n        if (Array.isArray(prefix) && prefix.length === 1) {\n            prefix = prefix;\n        }\n        else if (typeof prefix === \"string\") {\n            prefix = [prefix];\n        }\n        else {\n            throw new Error('ParamError: prefix must be a string, or an array of same length as columns');\n        }\n        if (Array.isArray(prefixSeparator) && prefixSeparator.length === 1) {\n            prefixSeparator = prefixSeparator;\n        }\n        else if (typeof prefixSeparator === \"string\") {\n            prefixSeparator = [prefixSeparator];\n        }\n        else {\n            throw new Error('ParamError: prefix must be a string, or an array of same length as columns');\n        }\n    }\n    else if (Array.isArray(columns)) {\n        if (prefix) {\n            if (Array.isArray(prefix) && prefix.length !== columns.length) {\n                throw new Error(\"ParamError: prefix and data array must be of the same length. If you need to use the same prefix, then pass a string param instead. e.g {prefix: \\\"\" + prefix + \"\\\"}\");\n            }\n            if (typeof prefix === \"string\") {\n                prefix = columns.map(function (_) { return prefix; });\n            }\n        }\n        if (prefixSeparator) {\n            if (Array.isArray(prefixSeparator) && prefixSeparator.length !== columns.length) {\n                throw new Error(\"ParamError: prefixSeparator and data array must be of the same length. If you need to use the same prefix separator, then pass a string param instead. e.g {prefixSeparator: \\\"\" + prefixSeparator + \"\\\"}\");\n            }\n            if (typeof prefixSeparator === \"string\") {\n                prefixSeparator = columns.map(function (_) { return prefixSeparator; });\n            }\n        }\n    }\n    else {\n        throw new Error('ParamError: columns must be a string or an array of strings');\n    }\n    if (data instanceof series_1.default) {\n        var colData = data.values;\n        var newColumnNames = [];\n        var uniqueValues = Array.from(new Set(colData));\n        var oneHotArr = utils.zeros(colData.length, uniqueValues.length);\n        for (var i = 0; i < colData.length; i++) {\n            var index = uniqueValues.indexOf(colData[i]);\n            oneHotArr[i][index] = 1;\n        }\n        for (var i = 0; i < uniqueValues.length; i++) {\n            var prefixToAdd = prefix ? prefix[0] : i;\n            newColumnNames.push(\"\" + prefixToAdd + prefixSeparator[0] + uniqueValues[i]);\n        }\n        return new frame_1.default(oneHotArr, { columns: newColumnNames });\n    }\n    else {\n        var dfWithSelectedColumnsDropped = data.drop({ columns: columns });\n        var newData = dfWithSelectedColumnsDropped === null || dfWithSelectedColumnsDropped === void 0 ? void 0 : dfWithSelectedColumnsDropped.values;\n        var newColumnNames = dfWithSelectedColumnsDropped === null || dfWithSelectedColumnsDropped === void 0 ? void 0 : dfWithSelectedColumnsDropped.columns;\n        for (var i = 0; i < columns.length; i++) {\n            var column = columns[i];\n            var colData = data.column(column).values;\n            var uniqueValues = Array.from(new Set(colData));\n            var oneHotArr = utils.zeros(colData.length, uniqueValues.length);\n            for (var j = 0; j < colData.length; j++) {\n                var index = uniqueValues.indexOf(colData[j]);\n                oneHotArr[j][index] = 1;\n                var prefixToAdd = prefix ? prefix[i] : column;\n                var newColName = \"\" + prefixToAdd + prefixSeparator[i] + colData[j];\n                if (!newColumnNames.includes(newColName)) {\n                    newColumnNames.push(newColName);\n                }\n            }\n            for (var k = 0; k < newData.length; k++) {\n                newData[k] = __spreadArray(__spreadArray([], newData[k], true), oneHotArr[k], true);\n            }\n        }\n        return new frame_1.default(newData, { columns: newColumnNames });\n    }\n}\nexports.default = dummyEncode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}