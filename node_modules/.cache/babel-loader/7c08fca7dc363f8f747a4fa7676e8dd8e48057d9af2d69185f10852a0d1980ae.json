{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsSqr = void 0;\nvar _csPermute = require(\"./csPermute.js\");\nvar _csPost = require(\"./csPost.js\");\nvar _csEtree = require(\"./csEtree.js\");\nvar _csAmd = require(\"./csAmd.js\");\nvar _csCounts = require(\"./csCounts.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nvar createCsSqr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var add = _ref.add,\n    multiply = _ref.multiply,\n    transpose = _ref.transpose;\n  var csAmd = (0, _csAmd.createCsAmd)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csCounts = (0, _csCounts.createCsCounts)({\n    transpose: transpose\n  });\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = (0, _csEtree.csEtree)(c, 1); // post order elimination tree\n\n      var post = (0, _csPost.csPost)(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n    return true;\n  }\n});\nexports.createCsSqr = createCsSqr;","map":{"version":3,"names":["Object","defineProperty","exports","value","createCsSqr","_csPermute","require","_csPost","_csEtree","_csAmd","_csCounts","_factory","name","dependencies","factory","_ref","add","multiply","transpose","csAmd","createCsAmd","csCounts","createCsCounts","csSqr","order","a","qr","aptr","_ptr","asize","_size","n","k","s","q","c","csPermute","parent","csEtree","post","csPost","cp","_vcount","unz","lnz","aindex","_index","m","pinv","leftmost","w","next","head","tail","nque","i","p","p0","p1","m2","pa"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsSqr = void 0;\n\nvar _csPermute = require(\"./csPermute.js\");\n\nvar _csPost = require(\"./csPost.js\");\n\nvar _csEtree = require(\"./csEtree.js\");\n\nvar _csAmd = require(\"./csAmd.js\");\n\nvar _csCounts = require(\"./csCounts.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nvar createCsSqr = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose;\n  var csAmd = (0, _csAmd.createCsAmd)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csCounts = (0, _csCounts.createCsCounts)({\n    transpose: transpose\n  });\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = (0, _csEtree.csEtree)(c, 1); // post order elimination tree\n\n      var post = (0, _csPost.csPost)(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n});\nexports.createCsSqr = createCsSqr;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAE5B,IAAIC,UAAU,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAE1C,IAAIC,OAAO,GAAGD,OAAO,CAAC,aAAa,CAAC;AAEpC,IAAIE,QAAQ,GAAGF,OAAO,CAAC,cAAc,CAAC;AAEtC,IAAIG,MAAM,GAAGH,OAAO,CAAC,YAAY,CAAC;AAElC,IAAII,SAAS,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAExC,IAAIK,QAAQ,GAAGL,OAAO,CAAC,2BAA2B,CAAC;AAEnD,IAAIM,IAAI,GAAG,OAAO;AAClB,IAAIC,YAAY,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,WAAW,CAAC;AACnD,IAAIT,WAAW,GAAG,eAAe,CAAC,CAAC,EAAEO,QAAQ,CAACG,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EACzF,IAAIC,GAAG,GAAGD,IAAI,CAACC,GAAG;IACdC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;IACxBC,SAAS,GAAGH,IAAI,CAACG,SAAS;EAC9B,IAAIC,KAAK,GAAG,CAAC,CAAC,EAAEV,MAAM,CAACW,WAAW,EAAE;IAClCJ,GAAG,EAAEA,GAAG;IACRC,QAAQ,EAAEA,QAAQ;IAClBC,SAAS,EAAEA;EACb,CAAC,CAAC;EACF,IAAIG,QAAQ,GAAG,CAAC,CAAC,EAAEX,SAAS,CAACY,cAAc,EAAE;IAC3CJ,SAAS,EAAEA;EACb,CAAC,CAAC;EACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,OAAO,SAASK,KAAK,CAACC,KAAK,EAAEC,CAAC,EAAEC,EAAE,EAAE;IAClC;IACA,IAAIC,IAAI,GAAGF,CAAC,CAACG,IAAI;IACjB,IAAIC,KAAK,GAAGJ,CAAC,CAACK,KAAK,CAAC,CAAC;;IAErB,IAAIC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;IAElB,IAAIG,CAAC,CAAC,CAAC;;IAEP,IAAIC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEZA,CAAC,CAACC,CAAC,GAAGf,KAAK,CAACK,KAAK,EAAEC,CAAC,CAAC,CAAC,CAAC;;IAEvB,IAAID,KAAK,IAAI,CAACS,CAAC,CAACC,CAAC,EAAE;MACjB,OAAO,IAAI;IACb,CAAC,CAAC;;IAGF,IAAIR,EAAE,EAAE;MACN;MACA,IAAIS,CAAC,GAAGX,KAAK,GAAG,CAAC,CAAC,EAAEnB,UAAU,CAAC+B,SAAS,EAAEX,CAAC,EAAE,IAAI,EAAEQ,CAAC,CAACC,CAAC,EAAE,CAAC,CAAC,GAAGT,CAAC,CAAC,CAAC;;MAEhEQ,CAAC,CAACI,MAAM,GAAG,CAAC,CAAC,EAAE7B,QAAQ,CAAC8B,OAAO,EAAEH,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;MAExC,IAAII,IAAI,GAAG,CAAC,CAAC,EAAEhC,OAAO,CAACiC,MAAM,EAAEP,CAAC,CAACI,MAAM,EAAEN,CAAC,CAAC,CAAC,CAAC;;MAE7CE,CAAC,CAACQ,EAAE,GAAGpB,QAAQ,CAACc,CAAC,EAAEF,CAAC,CAACI,MAAM,EAAEE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;;MAEvC,IAAIJ,CAAC,IAAIF,CAAC,CAACI,MAAM,IAAIJ,CAAC,CAACQ,EAAE,IAAIC,OAAO,CAACP,CAAC,EAAEF,CAAC,CAAC,EAAE;QAC1C;QACA,KAAKA,CAAC,CAACU,GAAG,GAAG,CAAC,EAAEX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;UACjCC,CAAC,CAACU,GAAG,IAAIV,CAAC,CAACQ,EAAE,CAACT,CAAC,CAAC;QAClB;MACF;IACF,CAAC,MAAM;MACL;MACAC,CAAC,CAACU,GAAG,GAAG,CAAC,GAAGhB,IAAI,CAACI,CAAC,CAAC,GAAGA,CAAC;MACvBE,CAAC,CAACW,GAAG,GAAGX,CAAC,CAACU,GAAG;IACf,CAAC,CAAC;;IAGF,OAAOV,CAAC;EACV,CAAC;EACD;AACF;AACA;;EAEE,SAASS,OAAO,CAACjB,CAAC,EAAEQ,CAAC,EAAE;IACrB;IACA,IAAIN,IAAI,GAAGF,CAAC,CAACG,IAAI;IACjB,IAAIiB,MAAM,GAAGpB,CAAC,CAACqB,MAAM;IACrB,IAAIjB,KAAK,GAAGJ,CAAC,CAACK,KAAK,CAAC,CAAC;;IAErB,IAAIiB,CAAC,GAAGlB,KAAK,CAAC,CAAC,CAAC;IAChB,IAAIE,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;IAElBI,CAAC,CAACe,IAAI,GAAG,EAAE,CAAC,CAAC;;IAEbf,CAAC,CAACgB,QAAQ,GAAG,EAAE,CAAC,CAAC;IACjB;;IAEA,IAAIZ,MAAM,GAAGJ,CAAC,CAACI,MAAM;IACrB,IAAIW,IAAI,GAAGf,CAAC,CAACe,IAAI;IACjB,IAAIC,QAAQ,GAAGhB,CAAC,CAACgB,QAAQ,CAAC,CAAC;;IAE3B,IAAIC,CAAC,GAAG,EAAE,CAAC,CAAC;;IAEZ,IAAIC,IAAI,GAAG,CAAC;IACZ,IAAIC,IAAI,GAAGL,CAAC;IACZ,IAAIM,IAAI,GAAGN,CAAC,GAAGhB,CAAC;IAChB,IAAIuB,IAAI,GAAGP,CAAC,GAAG,CAAC,GAAGhB,CAAC,CAAC,CAAC;;IAEtB,IAAIwB,CAAC,EAAEvB,CAAC,EAAEwB,CAAC,EAAEC,EAAE,EAAEC,EAAE,CAAC,CAAC;;IAErB,KAAK1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;MACtB;MACAkB,CAAC,CAACE,IAAI,GAAGpB,CAAC,CAAC,GAAG,CAAC,CAAC;MAChBkB,CAAC,CAACG,IAAI,GAAGrB,CAAC,CAAC,GAAG,CAAC,CAAC;MAChBkB,CAAC,CAACI,IAAI,GAAGtB,CAAC,CAAC,GAAG,CAAC;IACjB,CAAC,CAAC;;IAGF,KAAKuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,CAAC,EAAEQ,CAAC,EAAE,EAAE;MACtBN,QAAQ,CAACM,CAAC,CAAC,GAAG,CAAC,CAAC;IAClB,CAAC,CAAC;;IAGF,KAAKvB,CAAC,GAAGD,CAAC,GAAG,CAAC,EAAEC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3B;MACA,KAAKyB,EAAE,GAAG9B,IAAI,CAACK,CAAC,CAAC,EAAE0B,EAAE,GAAG/B,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC,EAAEwB,CAAC,GAAGC,EAAE,EAAED,CAAC,GAAGE,EAAE,EAAEF,CAAC,EAAE,EAAE;QACxD;QACAP,QAAQ,CAACJ,MAAM,CAACW,CAAC,CAAC,CAAC,GAAGxB,CAAC;MACzB;IACF,CAAC,CAAC;;IAGF,KAAKuB,CAAC,GAAGR,CAAC,GAAG,CAAC,EAAEQ,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3B;MACAP,IAAI,CAACO,CAAC,CAAC,GAAG,CAAC,CAAC;MACZvB,CAAC,GAAGiB,QAAQ,CAACM,CAAC,CAAC,CAAC,CAAC;;MAEjB,IAAIvB,CAAC,KAAK,CAAC,CAAC,EAAE;QACZ;MACF,CAAC,CAAC;;MAGF,IAAIkB,CAAC,CAACI,IAAI,GAAGtB,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE;QACvBkB,CAAC,CAACG,IAAI,GAAGrB,CAAC,CAAC,GAAGuB,CAAC;MACjB,CAAC,CAAC;;MAGFL,CAAC,CAACC,IAAI,GAAGI,CAAC,CAAC,GAAGL,CAAC,CAACE,IAAI,GAAGpB,CAAC,CAAC;MACzBkB,CAAC,CAACE,IAAI,GAAGpB,CAAC,CAAC,GAAGuB,CAAC;IACjB;IAEAtB,CAAC,CAACW,GAAG,GAAG,CAAC;IACTX,CAAC,CAAC0B,EAAE,GAAGZ,CAAC,CAAC,CAAC;;IAEV,KAAKf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;MACtB;MACAuB,CAAC,GAAGL,CAAC,CAACE,IAAI,GAAGpB,CAAC,CAAC,CAAC,CAAC;;MAEjBC,CAAC,CAACW,GAAG,EAAE,CAAC,CAAC;;MAET,IAAIW,CAAC,GAAG,CAAC,EAAE;QACTA,CAAC,GAAGtB,CAAC,CAAC0B,EAAE,EAAE;MACZ,CAAC,CAAC;;MAGFX,IAAI,CAACO,CAAC,CAAC,GAAGvB,CAAC,CAAC,CAAC;;MAEb,IAAI,EAAEsB,IAAI,CAACtB,CAAC,CAAC,IAAI,CAAC,EAAE;QAClB;MACF,CAAC,CAAC;;MAGFC,CAAC,CAACW,GAAG,IAAIM,CAAC,CAACI,IAAI,GAAGtB,CAAC,CAAC,CAAC,CAAC;;MAEtB,IAAI4B,EAAE,GAAGvB,MAAM,CAACL,CAAC,CAAC;MAElB,IAAI4B,EAAE,KAAK,CAAC,CAAC,EAAE;QACb,IAAIV,CAAC,CAACI,IAAI,GAAGM,EAAE,CAAC,KAAK,CAAC,EAAE;UACtBV,CAAC,CAACG,IAAI,GAAGO,EAAE,CAAC,GAAGV,CAAC,CAACG,IAAI,GAAGrB,CAAC,CAAC;QAC5B;QAEAkB,CAAC,CAACC,IAAI,GAAGD,CAAC,CAACG,IAAI,GAAGrB,CAAC,CAAC,CAAC,GAAGkB,CAAC,CAACE,IAAI,GAAGQ,EAAE,CAAC;QACpCV,CAAC,CAACE,IAAI,GAAGQ,EAAE,CAAC,GAAGV,CAAC,CAACC,IAAI,GAAGI,CAAC,CAAC;QAC1BL,CAAC,CAACI,IAAI,GAAGM,EAAE,CAAC,IAAIV,CAAC,CAACI,IAAI,GAAGtB,CAAC,CAAC;MAC7B;IACF;IAEA,KAAKuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,CAAC,EAAEQ,CAAC,EAAE,EAAE;MACtB,IAAIP,IAAI,CAACO,CAAC,CAAC,GAAG,CAAC,EAAE;QACfP,IAAI,CAACO,CAAC,CAAC,GAAGvB,CAAC,EAAE;MACf;IACF;IAEA,OAAO,IAAI;EACb;AACF,CAAC,CAAC;AACF9B,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}