{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParserClass = void 0;\nvar _factory = require(\"../utils/factory.js\");\nvar _map = require(\"../utils/map.js\");\nvar name = 'Parser';\nvar dependencies = ['parse'];\nvar createParserClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse;\n\n  /**\n   * @constructor Parser\n   * Parser contains methods to evaluate or parse expressions, and has a number\n   * of convenience methods to get, set, and remove variables from memory. Parser\n   * keeps a scope containing variables in memory, which is used for all\n   * evaluations.\n   *\n   * Methods:\n   *    const result = parser.evaluate(expr)  // evaluate an expression\n   *    const value = parser.get(name)        // retrieve a variable from the parser\n   *    const values = parser.getAll()        // retrieve all defined variables\n   *    parser.set(name, value)               // set a variable in the parser\n   *    parser.remove(name)                   // clear a variable from the\n   *                                          // parsers scope\n   *    parser.clear()                        // clear the parsers scope\n   *\n   * Example usage:\n   *    const parser = new Parser()\n   *    // Note: there is a convenience method which can be used instead:\n   *    // const parser = new math.parser()\n   *\n   *    // evaluate expressions\n   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5\n   *    parser.evaluate('sqrt(-4)')               // 2i\n   *    parser.evaluate('2 inch in cm')           // 5.08 cm\n   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476\n   *\n   *    // define variables and functions\n   *    parser.evaluate('x = 7 / 2')              // 3.5\n   *    parser.evaluate('x + 3')                  // 6.5\n   *    parser.evaluate('function f(x, y) = x^y') // f(x, y)\n   *    parser.evaluate('f(2, 3)')                // 8\n   *\n   *    // get and set variables and functions\n   *    const x = parser.get('x')                 // 7\n   *    const f = parser.get('f')                 // function\n   *    const g = f(3, 2)                         // 9\n   *    parser.set('h', 500)\n   *    const i = parser.evaluate('h / 2')        // 250\n   *    parser.set('hello', function (name) {\n   *        return 'hello, ' + name + '!'\n   *    })\n   *    parser.evaluate('hello(\"user\")')          // \"hello, user!\"\n   *\n   *    // clear defined functions and variables\n   *    parser.clear()\n   *\n   */\n  function Parser() {\n    if (!(this instanceof Parser)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    Object.defineProperty(this, 'scope', {\n      value: (0, _map.createEmptyMap)(),\n      writable: false\n    });\n  }\n  /**\n   * Attach type information\n   */\n\n  Parser.prototype.type = 'Parser';\n  Parser.prototype.isParser = true;\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n\n  Parser.prototype.evaluate = function (expr) {\n    // TODO: validate arguments\n    return parse(expr).compile().evaluate(this.scope);\n  };\n  /**\n   * Get a variable (a function or variable) by name from the parsers scope.\n   * Returns undefined when not found\n   * @param {string} name\n   * @return {* | undefined} value\n   */\n\n  Parser.prototype.get = function (name) {\n    // TODO: validate arguments\n    if (this.scope.has(name)) {\n      return this.scope.get(name);\n    }\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Object} values\n   */\n\n  Parser.prototype.getAll = function () {\n    return (0, _map.toObject)(this.scope);\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Map} values\n   */\n\n  Parser.prototype.getAllAsMap = function () {\n    return this.scope;\n  };\n  /**\n   * Set a symbol (a function or variable) by name from the parsers scope.\n   * @param {string} name\n   * @param {* | undefined} value\n   */\n\n  Parser.prototype.set = function (name, value) {\n    this.scope.set(name, value);\n    return value;\n  };\n  /**\n   * Remove a variable from the parsers scope\n   * @param {string} name\n   */\n\n  Parser.prototype.remove = function (name) {\n    this.scope[\"delete\"](name);\n  };\n  /**\n   * Clear the scope with variables and functions\n   */\n\n  Parser.prototype.clear = function () {\n    this.scope.clear();\n  };\n  return Parser;\n}, {\n  isClass: true\n});\nexports.createParserClass = createParserClass;","map":{"version":3,"names":["Object","defineProperty","exports","value","createParserClass","_factory","require","_map","name","dependencies","factory","_ref","parse","Parser","SyntaxError","createEmptyMap","writable","prototype","type","isParser","evaluate","expr","compile","scope","get","has","getAll","toObject","getAllAsMap","set","remove","clear","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/Parser.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParserClass = void 0;\n\nvar _factory = require(\"../utils/factory.js\");\n\nvar _map = require(\"../utils/map.js\");\n\nvar name = 'Parser';\nvar dependencies = ['parse'];\nvar createParserClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse;\n\n  /**\n   * @constructor Parser\n   * Parser contains methods to evaluate or parse expressions, and has a number\n   * of convenience methods to get, set, and remove variables from memory. Parser\n   * keeps a scope containing variables in memory, which is used for all\n   * evaluations.\n   *\n   * Methods:\n   *    const result = parser.evaluate(expr)  // evaluate an expression\n   *    const value = parser.get(name)        // retrieve a variable from the parser\n   *    const values = parser.getAll()        // retrieve all defined variables\n   *    parser.set(name, value)               // set a variable in the parser\n   *    parser.remove(name)                   // clear a variable from the\n   *                                          // parsers scope\n   *    parser.clear()                        // clear the parsers scope\n   *\n   * Example usage:\n   *    const parser = new Parser()\n   *    // Note: there is a convenience method which can be used instead:\n   *    // const parser = new math.parser()\n   *\n   *    // evaluate expressions\n   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5\n   *    parser.evaluate('sqrt(-4)')               // 2i\n   *    parser.evaluate('2 inch in cm')           // 5.08 cm\n   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476\n   *\n   *    // define variables and functions\n   *    parser.evaluate('x = 7 / 2')              // 3.5\n   *    parser.evaluate('x + 3')                  // 6.5\n   *    parser.evaluate('function f(x, y) = x^y') // f(x, y)\n   *    parser.evaluate('f(2, 3)')                // 8\n   *\n   *    // get and set variables and functions\n   *    const x = parser.get('x')                 // 7\n   *    const f = parser.get('f')                 // function\n   *    const g = f(3, 2)                         // 9\n   *    parser.set('h', 500)\n   *    const i = parser.evaluate('h / 2')        // 250\n   *    parser.set('hello', function (name) {\n   *        return 'hello, ' + name + '!'\n   *    })\n   *    parser.evaluate('hello(\"user\")')          // \"hello, user!\"\n   *\n   *    // clear defined functions and variables\n   *    parser.clear()\n   *\n   */\n  function Parser() {\n    if (!(this instanceof Parser)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    Object.defineProperty(this, 'scope', {\n      value: (0, _map.createEmptyMap)(),\n      writable: false\n    });\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Parser.prototype.type = 'Parser';\n  Parser.prototype.isParser = true;\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n\n  Parser.prototype.evaluate = function (expr) {\n    // TODO: validate arguments\n    return parse(expr).compile().evaluate(this.scope);\n  };\n  /**\n   * Get a variable (a function or variable) by name from the parsers scope.\n   * Returns undefined when not found\n   * @param {string} name\n   * @return {* | undefined} value\n   */\n\n\n  Parser.prototype.get = function (name) {\n    // TODO: validate arguments\n    if (this.scope.has(name)) {\n      return this.scope.get(name);\n    }\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Object} values\n   */\n\n\n  Parser.prototype.getAll = function () {\n    return (0, _map.toObject)(this.scope);\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Map} values\n   */\n\n\n  Parser.prototype.getAllAsMap = function () {\n    return this.scope;\n  };\n  /**\n   * Set a symbol (a function or variable) by name from the parsers scope.\n   * @param {string} name\n   * @param {* | undefined} value\n   */\n\n\n  Parser.prototype.set = function (name, value) {\n    this.scope.set(name, value);\n    return value;\n  };\n  /**\n   * Remove a variable from the parsers scope\n   * @param {string} name\n   */\n\n\n  Parser.prototype.remove = function (name) {\n    this.scope[\"delete\"](name);\n  };\n  /**\n   * Clear the scope with variables and functions\n   */\n\n\n  Parser.prototype.clear = function () {\n    this.scope.clear();\n  };\n\n  return Parser;\n}, {\n  isClass: true\n});\nexports.createParserClass = createParserClass;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}