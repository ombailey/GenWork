{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDot = void 0;\nvar _factory = require(\"../../utils/factory.js\");\nvar _is = require(\"../../utils/is.js\");\nvar name = 'dot';\nvar dependencies = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];\nvar createDot = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    addScalar = _ref.addScalar,\n    multiplyScalar = _ref.multiplyScalar,\n    conj = _ref.conj,\n    size = _ref.size;\n\n  /**\n   * Calculate the dot product of two vectors. The dot product of\n   * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:\n   *\n   *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn\n   *\n   * Syntax:\n   *\n   *    math.dot(x, y)\n   *\n   * Examples:\n   *\n   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15\n   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15\n   *\n   * See also:\n   *\n   *    multiply, cross\n   *\n   * @param  {Array | Matrix} x     First vector\n   * @param  {Array | Matrix} y     Second vector\n   * @return {number}               Returns the dot product of `x` and `y`\n   */\n  return typed(name, {\n    'Array | DenseMatrix, Array | DenseMatrix': _denseDot,\n    'SparseMatrix, SparseMatrix': _sparseDot\n  });\n  function _validateDim(x, y) {\n    var xSize = _size(x);\n    var ySize = _size(y);\n    var xLen, yLen;\n    if (xSize.length === 1) {\n      xLen = xSize[0];\n    } else if (xSize.length === 2 && xSize[1] === 1) {\n      xLen = xSize[0];\n    } else {\n      throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');\n    }\n    if (ySize.length === 1) {\n      yLen = ySize[0];\n    } else if (ySize.length === 2 && ySize[1] === 1) {\n      yLen = ySize[0];\n    } else {\n      throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');\n    }\n    if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');\n    if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');\n    return xLen;\n  }\n  function _denseDot(a, b) {\n    var N = _validateDim(a, b);\n    var adata = (0, _is.isMatrix)(a) ? a._data : a;\n    var adt = (0, _is.isMatrix)(a) ? a._datatype : undefined;\n    var bdata = (0, _is.isMatrix)(b) ? b._data : b;\n    var bdt = (0, _is.isMatrix)(b) ? b._datatype : undefined; // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)\n\n    var aIsColumn = _size(a).length === 2;\n    var bIsColumn = _size(b).length === 2;\n    var add = addScalar;\n    var mul = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      var dt = adt; // find signatures that matches (dt, dt)\n\n      add = typed.find(addScalar, [dt, dt]);\n      mul = typed.find(multiplyScalar, [dt, dt]);\n    } // both vectors 1-dimensional\n\n    if (!aIsColumn && !bIsColumn) {\n      var c = mul(conj(adata[0]), bdata[0]);\n      for (var i = 1; i < N; i++) {\n        c = add(c, mul(conj(adata[i]), bdata[i]));\n      }\n      return c;\n    } // a is 1-dim, b is column\n\n    if (!aIsColumn && bIsColumn) {\n      var _c = mul(conj(adata[0]), bdata[0][0]);\n      for (var _i = 1; _i < N; _i++) {\n        _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));\n      }\n      return _c;\n    } // a is column, b is 1-dim\n\n    if (aIsColumn && !bIsColumn) {\n      var _c2 = mul(conj(adata[0][0]), bdata[0]);\n      for (var _i2 = 1; _i2 < N; _i2++) {\n        _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));\n      }\n      return _c2;\n    } // both vectors are column\n\n    if (aIsColumn && bIsColumn) {\n      var _c3 = mul(conj(adata[0][0]), bdata[0][0]);\n      for (var _i3 = 1; _i3 < N; _i3++) {\n        _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));\n      }\n      return _c3;\n    }\n  }\n  function _sparseDot(x, y) {\n    _validateDim(x, y);\n    var xindex = x._index;\n    var xvalues = x._values;\n    var yindex = y._index;\n    var yvalues = y._values; // TODO optimize add & mul using datatype\n\n    var c = 0;\n    var add = addScalar;\n    var mul = multiplyScalar;\n    var i = 0;\n    var j = 0;\n    while (i < xindex.length && j < yindex.length) {\n      var I = xindex[i];\n      var J = yindex[j];\n      if (I < J) {\n        i++;\n        continue;\n      }\n      if (I > J) {\n        j++;\n        continue;\n      }\n      if (I === J) {\n        c = add(c, mul(xvalues[i], yvalues[j]));\n        i++;\n        j++;\n      }\n    }\n    return c;\n  } // TODO remove this once #1771 is fixed\n\n  function _size(x) {\n    return (0, _is.isMatrix)(x) ? x.size() : size(x);\n  }\n});\nexports.createDot = createDot;","map":{"version":3,"names":["Object","defineProperty","exports","value","createDot","_factory","require","_is","name","dependencies","factory","_ref","typed","addScalar","multiplyScalar","conj","size","_denseDot","_sparseDot","_validateDim","x","y","xSize","_size","ySize","xLen","yLen","length","RangeError","join","a","b","N","adata","isMatrix","_data","adt","_datatype","undefined","bdata","bdt","aIsColumn","bIsColumn","add","mul","dt","find","c","i","_c","_i","_c2","_i2","_c3","_i3","xindex","_index","xvalues","_values","yindex","yvalues","j","I","J"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/matrix/dot.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDot = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _is = require(\"../../utils/is.js\");\n\nvar name = 'dot';\nvar dependencies = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];\nvar createDot = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      addScalar = _ref.addScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      conj = _ref.conj,\n      size = _ref.size;\n\n  /**\n   * Calculate the dot product of two vectors. The dot product of\n   * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:\n   *\n   *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn\n   *\n   * Syntax:\n   *\n   *    math.dot(x, y)\n   *\n   * Examples:\n   *\n   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15\n   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15\n   *\n   * See also:\n   *\n   *    multiply, cross\n   *\n   * @param  {Array | Matrix} x     First vector\n   * @param  {Array | Matrix} y     Second vector\n   * @return {number}               Returns the dot product of `x` and `y`\n   */\n  return typed(name, {\n    'Array | DenseMatrix, Array | DenseMatrix': _denseDot,\n    'SparseMatrix, SparseMatrix': _sparseDot\n  });\n\n  function _validateDim(x, y) {\n    var xSize = _size(x);\n\n    var ySize = _size(y);\n\n    var xLen, yLen;\n\n    if (xSize.length === 1) {\n      xLen = xSize[0];\n    } else if (xSize.length === 2 && xSize[1] === 1) {\n      xLen = xSize[0];\n    } else {\n      throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');\n    }\n\n    if (ySize.length === 1) {\n      yLen = ySize[0];\n    } else if (ySize.length === 2 && ySize[1] === 1) {\n      yLen = ySize[0];\n    } else {\n      throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');\n    }\n\n    if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');\n    if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');\n    return xLen;\n  }\n\n  function _denseDot(a, b) {\n    var N = _validateDim(a, b);\n\n    var adata = (0, _is.isMatrix)(a) ? a._data : a;\n    var adt = (0, _is.isMatrix)(a) ? a._datatype : undefined;\n    var bdata = (0, _is.isMatrix)(b) ? b._data : b;\n    var bdt = (0, _is.isMatrix)(b) ? b._datatype : undefined; // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)\n\n    var aIsColumn = _size(a).length === 2;\n    var bIsColumn = _size(b).length === 2;\n    var add = addScalar;\n    var mul = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      var dt = adt; // find signatures that matches (dt, dt)\n\n      add = typed.find(addScalar, [dt, dt]);\n      mul = typed.find(multiplyScalar, [dt, dt]);\n    } // both vectors 1-dimensional\n\n\n    if (!aIsColumn && !bIsColumn) {\n      var c = mul(conj(adata[0]), bdata[0]);\n\n      for (var i = 1; i < N; i++) {\n        c = add(c, mul(conj(adata[i]), bdata[i]));\n      }\n\n      return c;\n    } // a is 1-dim, b is column\n\n\n    if (!aIsColumn && bIsColumn) {\n      var _c = mul(conj(adata[0]), bdata[0][0]);\n\n      for (var _i = 1; _i < N; _i++) {\n        _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));\n      }\n\n      return _c;\n    } // a is column, b is 1-dim\n\n\n    if (aIsColumn && !bIsColumn) {\n      var _c2 = mul(conj(adata[0][0]), bdata[0]);\n\n      for (var _i2 = 1; _i2 < N; _i2++) {\n        _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));\n      }\n\n      return _c2;\n    } // both vectors are column\n\n\n    if (aIsColumn && bIsColumn) {\n      var _c3 = mul(conj(adata[0][0]), bdata[0][0]);\n\n      for (var _i3 = 1; _i3 < N; _i3++) {\n        _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));\n      }\n\n      return _c3;\n    }\n  }\n\n  function _sparseDot(x, y) {\n    _validateDim(x, y);\n\n    var xindex = x._index;\n    var xvalues = x._values;\n    var yindex = y._index;\n    var yvalues = y._values; // TODO optimize add & mul using datatype\n\n    var c = 0;\n    var add = addScalar;\n    var mul = multiplyScalar;\n    var i = 0;\n    var j = 0;\n\n    while (i < xindex.length && j < yindex.length) {\n      var I = xindex[i];\n      var J = yindex[j];\n\n      if (I < J) {\n        i++;\n        continue;\n      }\n\n      if (I > J) {\n        j++;\n        continue;\n      }\n\n      if (I === J) {\n        c = add(c, mul(xvalues[i], yvalues[j]));\n        i++;\n        j++;\n      }\n    }\n\n    return c;\n  } // TODO remove this once #1771 is fixed\n\n\n  function _size(x) {\n    return (0, _is.isMatrix)(x) ? x.size() : size(x);\n  }\n});\nexports.createDot = createDot;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,SAAS,GAAG,KAAK,CAAC;AAE1B,IAAIC,QAAQ,GAAGC,OAAO,CAAC,wBAAwB,CAAC;AAEhD,IAAIC,GAAG,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AAEtC,IAAIE,IAAI,GAAG,KAAK;AAChB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,EAAE,MAAM,CAAC;AAC3E,IAAIL,SAAS,GAAG,eAAe,CAAC,CAAC,EAAEC,QAAQ,CAACK,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EACvF,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK;IAClBC,SAAS,GAAGF,IAAI,CAACE,SAAS;IAC1BC,cAAc,GAAGH,IAAI,CAACG,cAAc;IACpCC,IAAI,GAAGJ,IAAI,CAACI,IAAI;IAChBC,IAAI,GAAGL,IAAI,CAACK,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOJ,KAAK,CAACJ,IAAI,EAAE;IACjB,0CAA0C,EAAES,SAAS;IACrD,4BAA4B,EAAEC;EAChC,CAAC,CAAC;EAEF,SAASC,YAAY,CAACC,CAAC,EAAEC,CAAC,EAAE;IAC1B,IAAIC,KAAK,GAAGC,KAAK,CAACH,CAAC,CAAC;IAEpB,IAAII,KAAK,GAAGD,KAAK,CAACF,CAAC,CAAC;IAEpB,IAAII,IAAI,EAAEC,IAAI;IAEd,IAAIJ,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE;MACtBF,IAAI,GAAGH,KAAK,CAAC,CAAC,CAAC;IACjB,CAAC,MAAM,IAAIA,KAAK,CAACK,MAAM,KAAK,CAAC,IAAIL,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MAC/CG,IAAI,GAAGH,KAAK,CAAC,CAAC,CAAC;IACjB,CAAC,MAAM;MACL,MAAM,IAAIM,UAAU,CAAC,0DAA0D,GAAGN,KAAK,CAACO,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;IAC3G;IAEA,IAAIL,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACtBD,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC;IACjB,CAAC,MAAM,IAAIA,KAAK,CAACG,MAAM,KAAK,CAAC,IAAIH,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MAC/CE,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC;IACjB,CAAC,MAAM;MACL,MAAM,IAAII,UAAU,CAAC,0DAA0D,GAAGJ,KAAK,CAACK,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;IAC3G;IAEA,IAAIJ,IAAI,KAAKC,IAAI,EAAE,MAAM,IAAIE,UAAU,CAAC,kCAAkC,GAAGH,IAAI,GAAG,MAAM,GAAGC,IAAI,GAAG,GAAG,CAAC;IACxG,IAAID,IAAI,KAAK,CAAC,EAAE,MAAM,IAAIG,UAAU,CAAC,mDAAmD,CAAC;IACzF,OAAOH,IAAI;EACb;EAEA,SAASR,SAAS,CAACa,CAAC,EAAEC,CAAC,EAAE;IACvB,IAAIC,CAAC,GAAGb,YAAY,CAACW,CAAC,EAAEC,CAAC,CAAC;IAE1B,IAAIE,KAAK,GAAG,CAAC,CAAC,EAAE1B,GAAG,CAAC2B,QAAQ,EAAEJ,CAAC,CAAC,GAAGA,CAAC,CAACK,KAAK,GAAGL,CAAC;IAC9C,IAAIM,GAAG,GAAG,CAAC,CAAC,EAAE7B,GAAG,CAAC2B,QAAQ,EAAEJ,CAAC,CAAC,GAAGA,CAAC,CAACO,SAAS,GAAGC,SAAS;IACxD,IAAIC,KAAK,GAAG,CAAC,CAAC,EAAEhC,GAAG,CAAC2B,QAAQ,EAAEH,CAAC,CAAC,GAAGA,CAAC,CAACI,KAAK,GAAGJ,CAAC;IAC9C,IAAIS,GAAG,GAAG,CAAC,CAAC,EAAEjC,GAAG,CAAC2B,QAAQ,EAAEH,CAAC,CAAC,GAAGA,CAAC,CAACM,SAAS,GAAGC,SAAS,CAAC,CAAC;;IAE1D,IAAIG,SAAS,GAAGlB,KAAK,CAACO,CAAC,CAAC,CAACH,MAAM,KAAK,CAAC;IACrC,IAAIe,SAAS,GAAGnB,KAAK,CAACQ,CAAC,CAAC,CAACJ,MAAM,KAAK,CAAC;IACrC,IAAIgB,GAAG,GAAG9B,SAAS;IACnB,IAAI+B,GAAG,GAAG9B,cAAc,CAAC,CAAC;;IAE1B,IAAIsB,GAAG,IAAII,GAAG,IAAIJ,GAAG,KAAKI,GAAG,IAAI,OAAOJ,GAAG,KAAK,QAAQ,EAAE;MACxD,IAAIS,EAAE,GAAGT,GAAG,CAAC,CAAC;;MAEdO,GAAG,GAAG/B,KAAK,CAACkC,IAAI,CAACjC,SAAS,EAAE,CAACgC,EAAE,EAAEA,EAAE,CAAC,CAAC;MACrCD,GAAG,GAAGhC,KAAK,CAACkC,IAAI,CAAChC,cAAc,EAAE,CAAC+B,EAAE,EAAEA,EAAE,CAAC,CAAC;IAC5C,CAAC,CAAC;;IAGF,IAAI,CAACJ,SAAS,IAAI,CAACC,SAAS,EAAE;MAC5B,IAAIK,CAAC,GAAGH,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEM,KAAK,CAAC,CAAC,CAAC,CAAC;MAErC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,CAAC,EAAEgB,CAAC,EAAE,EAAE;QAC1BD,CAAC,GAAGJ,GAAG,CAACI,CAAC,EAAEH,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAACe,CAAC,CAAC,CAAC,EAAET,KAAK,CAACS,CAAC,CAAC,CAAC,CAAC;MAC3C;MAEA,OAAOD,CAAC;IACV,CAAC,CAAC;;IAGF,IAAI,CAACN,SAAS,IAAIC,SAAS,EAAE;MAC3B,IAAIO,EAAE,GAAGL,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEM,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAEzC,KAAK,IAAIW,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGlB,CAAC,EAAEkB,EAAE,EAAE,EAAE;QAC7BD,EAAE,GAAGN,GAAG,CAACM,EAAE,EAAEL,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAACiB,EAAE,CAAC,CAAC,EAAEX,KAAK,CAACW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAClD;MAEA,OAAOD,EAAE;IACX,CAAC,CAAC;;IAGF,IAAIR,SAAS,IAAI,CAACC,SAAS,EAAE;MAC3B,IAAIS,GAAG,GAAGP,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEM,KAAK,CAAC,CAAC,CAAC,CAAC;MAE1C,KAAK,IAAIa,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGpB,CAAC,EAAEoB,GAAG,EAAE,EAAE;QAChCD,GAAG,GAAGR,GAAG,CAACQ,GAAG,EAAEP,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAACmB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEb,KAAK,CAACa,GAAG,CAAC,CAAC,CAAC;MACtD;MAEA,OAAOD,GAAG;IACZ,CAAC,CAAC;;IAGF,IAAIV,SAAS,IAAIC,SAAS,EAAE;MAC1B,IAAIW,GAAG,GAAGT,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEM,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAE7C,KAAK,IAAIe,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGtB,CAAC,EAAEsB,GAAG,EAAE,EAAE;QAChCD,GAAG,GAAGV,GAAG,CAACU,GAAG,EAAET,GAAG,CAAC7B,IAAI,CAACkB,KAAK,CAACqB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEf,KAAK,CAACe,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACzD;MAEA,OAAOD,GAAG;IACZ;EACF;EAEA,SAASnC,UAAU,CAACE,CAAC,EAAEC,CAAC,EAAE;IACxBF,YAAY,CAACC,CAAC,EAAEC,CAAC,CAAC;IAElB,IAAIkC,MAAM,GAAGnC,CAAC,CAACoC,MAAM;IACrB,IAAIC,OAAO,GAAGrC,CAAC,CAACsC,OAAO;IACvB,IAAIC,MAAM,GAAGtC,CAAC,CAACmC,MAAM;IACrB,IAAII,OAAO,GAAGvC,CAAC,CAACqC,OAAO,CAAC,CAAC;;IAEzB,IAAIX,CAAC,GAAG,CAAC;IACT,IAAIJ,GAAG,GAAG9B,SAAS;IACnB,IAAI+B,GAAG,GAAG9B,cAAc;IACxB,IAAIkC,CAAC,GAAG,CAAC;IACT,IAAIa,CAAC,GAAG,CAAC;IAET,OAAOb,CAAC,GAAGO,MAAM,CAAC5B,MAAM,IAAIkC,CAAC,GAAGF,MAAM,CAAChC,MAAM,EAAE;MAC7C,IAAImC,CAAC,GAAGP,MAAM,CAACP,CAAC,CAAC;MACjB,IAAIe,CAAC,GAAGJ,MAAM,CAACE,CAAC,CAAC;MAEjB,IAAIC,CAAC,GAAGC,CAAC,EAAE;QACTf,CAAC,EAAE;QACH;MACF;MAEA,IAAIc,CAAC,GAAGC,CAAC,EAAE;QACTF,CAAC,EAAE;QACH;MACF;MAEA,IAAIC,CAAC,KAAKC,CAAC,EAAE;QACXhB,CAAC,GAAGJ,GAAG,CAACI,CAAC,EAAEH,GAAG,CAACa,OAAO,CAACT,CAAC,CAAC,EAAEY,OAAO,CAACC,CAAC,CAAC,CAAC,CAAC;QACvCb,CAAC,EAAE;QACHa,CAAC,EAAE;MACL;IACF;IAEA,OAAOd,CAAC;EACV,CAAC,CAAC;;EAGF,SAASxB,KAAK,CAACH,CAAC,EAAE;IAChB,OAAO,CAAC,CAAC,EAAEb,GAAG,CAAC2B,QAAQ,EAAEd,CAAC,CAAC,GAAGA,CAAC,CAACJ,IAAI,EAAE,GAAGA,IAAI,CAACI,CAAC,CAAC;EAClD;AACF,CAAC,CAAC;AACFlB,OAAO,CAACE,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}