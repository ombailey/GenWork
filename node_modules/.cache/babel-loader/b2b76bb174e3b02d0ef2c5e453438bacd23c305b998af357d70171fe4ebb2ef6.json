{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParenthesisNode = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'ParenthesisNode';\nvar dependencies = ['Node'];\nvar createParenthesisNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor ParenthesisNode\n   * @extends {Node}\n   * A parenthesis node describes manual parenthesis from the user input\n   * @param {Node} content\n   * @extends {Node}\n   */\n  function ParenthesisNode(content) {\n    if (!(this instanceof ParenthesisNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n    if (!(0, _is.isNode)(content)) {\n      throw new TypeError('Node expected for parameter \"content\"');\n    }\n    this.content = content;\n  }\n  ParenthesisNode.prototype = new Node();\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\n  ParenthesisNode.prototype.isParenthesisNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ParenthesisNode.prototype._compile = function (math, argNames) {\n    return this.content._compile(math, argNames);\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} content\n   * @override\n   **/\n\n  ParenthesisNode.prototype.getContent = function () {\n    return this.content.getContent();\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  ParenthesisNode.prototype.forEach = function (callback) {\n    callback(this.content, 'content', this);\n  };\n  /**\n   * Create a new ParenthesisNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ParenthesisNode} Returns a clone of the node\n   */\n\n  ParenthesisNode.prototype.map = function (callback) {\n    var content = callback(this.content, 'content', this);\n    return new ParenthesisNode(content);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ParenthesisNode}\n   */\n\n  ParenthesisNode.prototype.clone = function () {\n    return new ParenthesisNode(this.content);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  ParenthesisNode.prototype._toString = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '(' + this.content.toString(options) + ')';\n    }\n    return this.content.toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  ParenthesisNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ParenthesisNode',\n      content: this.content\n    };\n  };\n  /**\n   * Instantiate an ParenthesisNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ParenthesisNode\", \"content\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ParenthesisNode}\n   */\n\n  ParenthesisNode.fromJSON = function (json) {\n    return new ParenthesisNode(json.content);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  ParenthesisNode.prototype.toHTML = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return this.content.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  ParenthesisNode.prototype._toTex = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return \"\\\\left(\".concat(this.content.toTex(options), \"\\\\right)\");\n    }\n    return this.content.toTex(options);\n  };\n  return ParenthesisNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createParenthesisNode = createParenthesisNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createParenthesisNode","_is","require","_factory","name","dependencies","factory","_ref","Node","ParenthesisNode","content","SyntaxError","isNode","TypeError","prototype","type","isParenthesisNode","_compile","math","argNames","getContent","forEach","callback","map","clone","_toString","options","parenthesis","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","concat","toTex","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/ParenthesisNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParenthesisNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'ParenthesisNode';\nvar dependencies = ['Node'];\nvar createParenthesisNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor ParenthesisNode\n   * @extends {Node}\n   * A parenthesis node describes manual parenthesis from the user input\n   * @param {Node} content\n   * @extends {Node}\n   */\n  function ParenthesisNode(content) {\n    if (!(this instanceof ParenthesisNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (!(0, _is.isNode)(content)) {\n      throw new TypeError('Node expected for parameter \"content\"');\n    }\n\n    this.content = content;\n  }\n\n  ParenthesisNode.prototype = new Node();\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\n  ParenthesisNode.prototype.isParenthesisNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ParenthesisNode.prototype._compile = function (math, argNames) {\n    return this.content._compile(math, argNames);\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} content\n   * @override\n   **/\n\n\n  ParenthesisNode.prototype.getContent = function () {\n    return this.content.getContent();\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ParenthesisNode.prototype.forEach = function (callback) {\n    callback(this.content, 'content', this);\n  };\n  /**\n   * Create a new ParenthesisNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {ParenthesisNode} Returns a clone of the node\n   */\n\n\n  ParenthesisNode.prototype.map = function (callback) {\n    var content = callback(this.content, 'content', this);\n    return new ParenthesisNode(content);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ParenthesisNode}\n   */\n\n\n  ParenthesisNode.prototype.clone = function () {\n    return new ParenthesisNode(this.content);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype._toString = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '(' + this.content.toString(options) + ')';\n    }\n\n    return this.content.toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ParenthesisNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ParenthesisNode',\n      content: this.content\n    };\n  };\n  /**\n   * Instantiate an ParenthesisNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ParenthesisNode\", \"content\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ParenthesisNode}\n   */\n\n\n  ParenthesisNode.fromJSON = function (json) {\n    return new ParenthesisNode(json.content);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype.toHTML = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return this.content.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ParenthesisNode.prototype._toTex = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return \"\\\\left(\".concat(this.content.toTex(options), \"\\\\right)\");\n    }\n\n    return this.content.toTex(options);\n  };\n\n  return ParenthesisNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createParenthesisNode = createParenthesisNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}