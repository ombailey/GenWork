{"ast":null,"code":"'use strict';\n\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst astralRegex = require('astral-regex');\nconst ansiStyles = require('ansi-styles');\nconst ESCAPES = ['\\u001B', '\\u009B'];\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\nconst checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {\n  let output = [];\n  ansiCodes = [...ansiCodes];\n  for (let ansiCode of ansiCodes) {\n    const ansiCodeOrigin = ansiCode;\n    if (ansiCode.includes(';')) {\n      ansiCode = ansiCode.split(';')[0][0] + '0';\n    }\n    const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));\n    if (item) {\n      const indexEscape = ansiCodes.indexOf(item.toString());\n      if (indexEscape === -1) {\n        output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));\n      } else {\n        ansiCodes.splice(indexEscape, 1);\n      }\n    } else if (isEscapes) {\n      output.push(wrapAnsi(0));\n      break;\n    } else {\n      output.push(wrapAnsi(ansiCodeOrigin));\n    }\n  }\n  if (isEscapes) {\n    output = output.filter((element, index) => output.indexOf(element) === index);\n    if (endAnsiCode !== undefined) {\n      const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));\n      output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);\n    }\n  }\n  return output.join('');\n};\nmodule.exports = (string, begin, end) => {\n  const characters = [...string];\n  const ansiCodes = [];\n  let stringEnd = typeof end === 'number' ? end : characters.length;\n  let isInsideEscape = false;\n  let ansiCode;\n  let visible = 0;\n  let output = '';\n  for (const [index, character] of characters.entries()) {\n    let leftEscape = false;\n    if (ESCAPES.includes(character)) {\n      const code = /\\d[^m]*/.exec(string.slice(index, index + 18));\n      ansiCode = code && code.length > 0 ? code[0] : undefined;\n      if (visible < stringEnd) {\n        isInsideEscape = true;\n        if (ansiCode !== undefined) {\n          ansiCodes.push(ansiCode);\n        }\n      }\n    } else if (isInsideEscape && character === 'm') {\n      isInsideEscape = false;\n      leftEscape = true;\n    }\n    if (!isInsideEscape && !leftEscape) {\n      visible++;\n    }\n    if (!astralRegex({\n      exact: true\n    }).test(character) && isFullwidthCodePoint(character.codePointAt())) {\n      visible++;\n      if (typeof end !== 'number') {\n        stringEnd++;\n      }\n    }\n    if (visible > begin && visible <= stringEnd) {\n      output += character;\n    } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {\n      output = checkAnsi(ansiCodes);\n    } else if (visible >= stringEnd) {\n      output += checkAnsi(ansiCodes, true, ansiCode);\n      break;\n    }\n  }\n  return output;\n};","map":{"version":3,"names":["isFullwidthCodePoint","require","astralRegex","ansiStyles","ESCAPES","wrapAnsi","code","checkAnsi","ansiCodes","isEscapes","endAnsiCode","output","ansiCode","ansiCodeOrigin","includes","split","item","codes","get","Number","parseInt","indexEscape","indexOf","toString","push","splice","filter","element","index","undefined","fistEscapeCode","reduce","current","next","join","module","exports","string","begin","end","characters","stringEnd","length","isInsideEscape","visible","character","entries","leftEscape","exec","slice","exact","test","codePointAt"],"sources":["/Users/omarbailey/node_modules/slice-ansi/index.js"],"sourcesContent":["'use strict';\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst astralRegex = require('astral-regex');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = [\n\t'\\u001B',\n\t'\\u009B'\n];\n\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\n\nconst checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {\n\tlet output = [];\n\tansiCodes = [...ansiCodes];\n\n\tfor (let ansiCode of ansiCodes) {\n\t\tconst ansiCodeOrigin = ansiCode;\n\t\tif (ansiCode.includes(';')) {\n\t\t\tansiCode = ansiCode.split(';')[0][0] + '0';\n\t\t}\n\n\t\tconst item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));\n\t\tif (item) {\n\t\t\tconst indexEscape = ansiCodes.indexOf(item.toString());\n\t\t\tif (indexEscape === -1) {\n\t\t\t\toutput.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));\n\t\t\t} else {\n\t\t\t\tansiCodes.splice(indexEscape, 1);\n\t\t\t}\n\t\t} else if (isEscapes) {\n\t\t\toutput.push(wrapAnsi(0));\n\t\t\tbreak;\n\t\t} else {\n\t\t\toutput.push(wrapAnsi(ansiCodeOrigin));\n\t\t}\n\t}\n\n\tif (isEscapes) {\n\t\toutput = output.filter((element, index) => output.indexOf(element) === index);\n\n\t\tif (endAnsiCode !== undefined) {\n\t\t\tconst fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));\n\t\t\toutput = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);\n\t\t}\n\t}\n\n\treturn output.join('');\n};\n\nmodule.exports = (string, begin, end) => {\n\tconst characters = [...string];\n\tconst ansiCodes = [];\n\n\tlet stringEnd = typeof end === 'number' ? end : characters.length;\n\tlet isInsideEscape = false;\n\tlet ansiCode;\n\tlet visible = 0;\n\tlet output = '';\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tlet leftEscape = false;\n\n\t\tif (ESCAPES.includes(character)) {\n\t\t\tconst code = /\\d[^m]*/.exec(string.slice(index, index + 18));\n\t\t\tansiCode = code && code.length > 0 ? code[0] : undefined;\n\n\t\t\tif (visible < stringEnd) {\n\t\t\t\tisInsideEscape = true;\n\n\t\t\t\tif (ansiCode !== undefined) {\n\t\t\t\t\tansiCodes.push(ansiCode);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isInsideEscape && character === 'm') {\n\t\t\tisInsideEscape = false;\n\t\t\tleftEscape = true;\n\t\t}\n\n\t\tif (!isInsideEscape && !leftEscape) {\n\t\t\tvisible++;\n\t\t}\n\n\t\tif (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {\n\t\t\tvisible++;\n\n\t\t\tif (typeof end !== 'number') {\n\t\t\t\tstringEnd++;\n\t\t\t}\n\t\t}\n\n\t\tif (visible > begin && visible <= stringEnd) {\n\t\t\toutput += character;\n\t\t} else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {\n\t\t\toutput = checkAnsi(ansiCodes);\n\t\t} else if (visible >= stringEnd) {\n\t\t\toutput += checkAnsi(ansiCodes, true, ansiCode);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn output;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}