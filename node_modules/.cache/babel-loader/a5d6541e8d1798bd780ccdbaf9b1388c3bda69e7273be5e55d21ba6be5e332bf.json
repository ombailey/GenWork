{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSlu = void 0;\nvar _number = require(\"../../../utils/number.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar _csSqr = require(\"../sparse/csSqr.js\");\nvar _csLu = require(\"../sparse/csLu.js\");\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nvar createSlu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    abs = _ref.abs,\n    add = _ref.add,\n    multiply = _ref.multiply,\n    transpose = _ref.transpose,\n    divideScalar = _ref.divideScalar,\n    subtract = _ref.subtract,\n    larger = _ref.larger,\n    largerEq = _ref.largerEq,\n    SparseMatrix = _ref.SparseMatrix;\n  var csSqr = (0, _csSqr.createCsSqr)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = (0, _csLu.createCsLu)({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!(0, _number.isInteger)(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});\nexports.createSlu = createSlu;","map":{"version":3,"names":["Object","defineProperty","exports","value","createSlu","_number","require","_factory","_csSqr","_csLu","name","dependencies","factory","_ref","typed","abs","add","multiply","transpose","divideScalar","subtract","larger","largerEq","SparseMatrix","csSqr","createCsSqr","csLu","createCsLu","SparseMatrixNumberNumber","a","order","threshold","isInteger","Error","s","f","L","U","p","pinv","q","toString"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/decomposition/slu.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSlu = void 0;\n\nvar _number = require(\"../../../utils/number.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csSqr = require(\"../sparse/csSqr.js\");\n\nvar _csLu = require(\"../sparse/csLu.js\");\n\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nvar createSlu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose,\n      divideScalar = _ref.divideScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSqr = (0, _csSqr.createCsSqr)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = (0, _csLu.createCsLu)({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!(0, _number.isInteger)(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});\nexports.createSlu = createSlu;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}