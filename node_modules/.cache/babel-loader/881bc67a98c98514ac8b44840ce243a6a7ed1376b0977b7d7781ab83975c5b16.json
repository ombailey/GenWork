{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createExpm = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'expm';\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nvar createExpm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    abs = _ref.abs,\n    add = _ref.add,\n    identity = _ref.identity,\n    inv = _ref.inv,\n    multiply = _ref.multiply;\n\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n  return typed(name, {\n    Matrix: function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      var eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      var N = identity(n);\n      var D = identity(n); // Initialization (i=0)\n\n      var factor = 1; // Initialization (i=1)\n\n      var AposToI = Apos; // Cloning not necessary\n\n      var alternate = -1;\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n      var R = multiply(inv(D), N); // Square j times\n\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n      return (0, _is.isSparseMatrix)(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n      infNorm = Math.max(rowSum, infNorm);\n    }\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q: q,\n            j: j\n          };\n        }\n      }\n    }\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n    var twoqfac = qfac;\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});\nexports.createExpm = createExpm;","map":{"version":3,"names":["Object","defineProperty","exports","value","createExpm","_is","require","_string","_factory","name","dependencies","factory","_ref","typed","abs","add","identity","inv","multiply","Matrix","A","size","length","RangeError","format","n","eps","infNorm","infinityNorm","params","findParams","q","j","Apos","Math","pow","N","D","factor","AposToI","alternate","i","R","_i","isSparseMatrix","createSparseMatrix","rowSum","get","max","maxSearchSize","k","errorEstimate","Error","qfac","twoqfac","_i2","twoqp1fac"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/matrix/expm.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createExpm = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'expm';\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nvar createExpm = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      identity = _ref.identity,\n      inv = _ref.inv,\n      multiply = _ref.multiply;\n\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n  return typed(name, {\n    Matrix: function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n\n      var n = size[0]; // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n\n      var eps = 1e-15; // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n\n      var infNorm = infinityNorm(A); // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j; // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n      // Scale A by 1 / 2^j\n\n      var Apos = multiply(A, Math.pow(2, -j)); // The i=0 term is just the identity matrix\n\n      var N = identity(n);\n      var D = identity(n); // Initialization (i=0)\n\n      var factor = 1; // Initialization (i=1)\n\n      var AposToI = Apos; // Cloning not necessary\n\n      var alternate = -1;\n\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n\n      var R = multiply(inv(D), N); // Square j times\n\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n\n      return (0, _is.isSparseMatrix)(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n\n      infNorm = Math.max(rowSum, infNorm);\n    }\n\n    return infNorm;\n  }\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n\n\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q: q,\n            j: j\n          };\n        }\n      }\n    }\n\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n\n\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n\n    var twoqfac = qfac;\n\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});\nexports.createExpm = createExpm;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}