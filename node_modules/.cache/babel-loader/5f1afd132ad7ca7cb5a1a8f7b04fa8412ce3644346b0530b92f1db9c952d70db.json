{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInv = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _string = require(\"../../utils/string.js\");\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nvar createInv = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix,\n    divideScalar = _ref.divideScalar,\n    addScalar = _ref.addScalar,\n    multiply = _ref.multiply,\n    unaryMinus = _ref.unaryMinus,\n    det = _ref.det,\n    identity = _ref.identity,\n    abs = _ref.abs;\n\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if ((0, _is.isMatrix)(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n          }\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              if ((0, _is.isMatrix)(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n          r++;\n        }\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n        r = rBig;\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n        var Ac = A[c];\n        var Bc = B[c];\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n      return B;\n    }\n  }\n});\nexports.createInv = createInv;","map":{"version":3,"names":["Object","defineProperty","exports","value","createInv","_is","require","_array","_factory","_string","name","dependencies","factory","_ref","typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs","ArrayMatrix","x","size","isMatrix","arraySize","length","valueOf","RangeError","format","rows","cols","_inv","storage","any","mat","r","s","f","temp","Error","d","A","concat","B","c","ABig","rBig","Ac","Bc","Ar","Br"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/matrix/inv.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInv = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nvar createInv = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      addScalar = _ref.addScalar,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      det = _ref.det,\n      identity = _ref.identity,\n      abs = _ref.abs;\n\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);\n\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if ((0, _is.isMatrix)(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              if ((0, _is.isMatrix)(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + (0, _string.format)(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + (0, _string.format)(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n\n          r++;\n        }\n\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n\n        r = rBig;\n\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n\n        var Ac = A[c];\n        var Bc = B[c];\n\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n\n      return B;\n    }\n  }\n});\nexports.createInv = createInv;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}