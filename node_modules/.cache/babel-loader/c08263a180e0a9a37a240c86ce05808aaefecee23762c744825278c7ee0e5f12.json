{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csReach = csReach;\nvar _csMarked = require(\"./csMarked.js\");\nvar _csMark = require(\"./csMark.js\");\nvar _csDfs = require(\"./csDfs.js\");\n\n/**\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\n *\n * @param {Matrix}  g               The G matrix\n * @param {Matrix}  b               The B matrix\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector\n *\n * @return {Number}                 The index for the nonzero pattern\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csReach(g, b, k, xi, pinv) {\n  // g arrays\n  var gptr = g._ptr;\n  var gsize = g._size; // b arrays\n\n  var bindex = b._index;\n  var bptr = b._ptr; // columns\n\n  var n = gsize[1]; // vars\n\n  var p, p0, p1; // initialize top\n\n  var top = n; // loop column indeces in B\n\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n    // node i\n    var i = bindex[p]; // check node i is marked\n\n    if (!(0, _csMarked.csMarked)(gptr, i)) {\n      // start a dfs at unmarked node i\n      top = (0, _csDfs.csDfs)(i, g, top, xi, pinv);\n    }\n  } // loop columns from top -> n - 1\n\n  for (p = top; p < n; p++) {\n    // restore G\n    (0, _csMark.csMark)(gptr, xi[p]);\n  }\n  return top;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","csReach","_csMarked","require","_csMark","_csDfs","g","b","k","xi","pinv","gptr","_ptr","gsize","_size","bindex","_index","bptr","n","p","p0","p1","top","i","csMarked","csDfs","csMark"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/sparse/csReach.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csReach = csReach;\n\nvar _csMarked = require(\"./csMarked.js\");\n\nvar _csMark = require(\"./csMark.js\");\n\nvar _csDfs = require(\"./csDfs.js\");\n\n/**\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\n *\n * @param {Matrix}  g               The G matrix\n * @param {Matrix}  b               The B matrix\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector\n *\n * @return {Number}                 The index for the nonzero pattern\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csReach(g, b, k, xi, pinv) {\n  // g arrays\n  var gptr = g._ptr;\n  var gsize = g._size; // b arrays\n\n  var bindex = b._index;\n  var bptr = b._ptr; // columns\n\n  var n = gsize[1]; // vars\n\n  var p, p0, p1; // initialize top\n\n  var top = n; // loop column indeces in B\n\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n    // node i\n    var i = bindex[p]; // check node i is marked\n\n    if (!(0, _csMarked.csMarked)(gptr, i)) {\n      // start a dfs at unmarked node i\n      top = (0, _csDfs.csDfs)(i, g, top, xi, pinv);\n    }\n  } // loop columns from top -> n - 1\n\n\n  for (p = top; p < n; p++) {\n    // restore G\n    (0, _csMark.csMark)(gptr, xi[p]);\n  }\n\n  return top;\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGA,OAAO;AAEzB,IAAIC,SAAS,GAAGC,OAAO,CAAC,eAAe,CAAC;AAExC,IAAIC,OAAO,GAAGD,OAAO,CAAC,aAAa,CAAC;AAEpC,IAAIE,MAAM,GAAGF,OAAO,CAAC,YAAY,CAAC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,OAAO,CAACK,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAEC,IAAI,EAAE;EAClC;EACA,IAAIC,IAAI,GAAGL,CAAC,CAACM,IAAI;EACjB,IAAIC,KAAK,GAAGP,CAAC,CAACQ,KAAK,CAAC,CAAC;;EAErB,IAAIC,MAAM,GAAGR,CAAC,CAACS,MAAM;EACrB,IAAIC,IAAI,GAAGV,CAAC,CAACK,IAAI,CAAC,CAAC;;EAEnB,IAAIM,CAAC,GAAGL,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;EAElB,IAAIM,CAAC,EAAEC,EAAE,EAAEC,EAAE,CAAC,CAAC;;EAEf,IAAIC,GAAG,GAAGJ,CAAC,CAAC,CAAC;;EAEb,KAAKE,EAAE,GAAGH,IAAI,CAACT,CAAC,CAAC,EAAEa,EAAE,GAAGJ,IAAI,CAACT,CAAC,GAAG,CAAC,CAAC,EAAEW,CAAC,GAAGC,EAAE,EAAED,CAAC,GAAGE,EAAE,EAAEF,CAAC,EAAE,EAAE;IACxD;IACA,IAAII,CAAC,GAAGR,MAAM,CAACI,CAAC,CAAC,CAAC,CAAC;;IAEnB,IAAI,CAAC,CAAC,CAAC,EAAEjB,SAAS,CAACsB,QAAQ,EAAEb,IAAI,EAAEY,CAAC,CAAC,EAAE;MACrC;MACAD,GAAG,GAAG,CAAC,CAAC,EAAEjB,MAAM,CAACoB,KAAK,EAAEF,CAAC,EAAEjB,CAAC,EAAEgB,GAAG,EAAEb,EAAE,EAAEC,IAAI,CAAC;IAC9C;EACF,CAAC,CAAC;;EAGF,KAAKS,CAAC,GAAGG,GAAG,EAAEH,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;IACxB;IACA,CAAC,CAAC,EAAEf,OAAO,CAACsB,MAAM,EAAEf,IAAI,EAAEF,EAAE,CAACU,CAAC,CAAC,CAAC;EAClC;EAEA,OAAOG,GAAG;AACZ"},"metadata":{},"sourceType":"script","externalDependencies":[]}