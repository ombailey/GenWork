{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arraySize = arraySize;\nexports.validate = validate;\nexports.validateIndex = validateIndex;\nexports.resize = resize;\nexports.reshape = reshape;\nexports.processSizesWildcard = processSizesWildcard;\nexports.squeeze = squeeze;\nexports.unsqueeze = unsqueeze;\nexports.flatten = flatten;\nexports.map = map;\nexports.forEach = forEach;\nexports.filter = filter;\nexports.filterRegExp = filterRegExp;\nexports.join = join;\nexports.identify = identify;\nexports.generalize = generalize;\nexports.getArrayDataType = getArrayDataType;\nexports.last = last;\nexports.initial = initial;\nexports.contains = contains;\nvar _number = require(\"./number.js\");\nvar _is = require(\"./is.js\");\nvar _string = require(\"./string.js\");\nvar _DimensionError = require(\"../error/DimensionError.js\");\nvar _IndexError = require(\"../error/IndexError.js\");\n\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\nfunction arraySize(x) {\n  var s = [];\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n  if (len !== size[dim]) {\n    throw new _DimensionError.DimensionError(len, size[dim]);\n  }\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n      if (!Array.isArray(child)) {\n        throw new _DimensionError.DimensionError(size.length - 1, size.length, '<');\n      }\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new _DimensionError.DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\nfunction validate(array, size) {\n  var isScalar = size.length === 0;\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new _DimensionError.DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nfunction validateIndex(index, length) {\n  if (!(0, _is.isNumber)(index) || !(0, _number.isInteger)(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new _IndexError.IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nfunction resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n  size.forEach(function (value) {\n    if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, _string.format)(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n  _resize(array, size, 0, _defaultValue);\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\nfunction reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n  if (sizes.length === 0) {\n    throw new _DimensionError.DimensionError(0, currentLength, '!=');\n  }\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n  if (currentLength !== newLength) {\n    throw new _DimensionError.DimensionError(newLength, currentLength, '!=');\n  }\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof _DimensionError.DimensionError) {\n      throw new _DimensionError.DimensionError(newLength, currentLength, '!=');\n    }\n    throw e;\n  }\n}\n/**\n * Replaces the wildcard -1 in the sizes array.\n * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.\n * @param {number} currentLength  Number of elements in the array.\n * @throws {Error}                If more than one wildcard or unable to replace it.\n * @returns {Array.<number>}      The sizes array with wildcard replaced.\n */\n\nfunction processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n  return processedSizes;\n}\n/**\n * Computes the product of all array elements.\n * @param {Array<number>} array Array of factors\n * @returns {number}            Product of all elements\n */\n\nfunction product(array) {\n  return array.reduce(function (prev, curr) {\n    return prev * curr;\n  }, 1);\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n    tmpArray = tmpArray2;\n  }\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\nfunction squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n  var dims = s.length;\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n  if (dim < dims) {\n    var next = dim + 1;\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\nfunction unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n  array = _unsqueeze(array, dims, 0);\n  while (s.length < dims) {\n    s.push(1);\n  }\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\nfunction flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nfunction map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nfunction forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nfunction filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nfunction filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nfunction join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nfunction identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n  if (a.length === 0) {\n    return a;\n  }\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nfunction generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n  if (a.length === 0) {\n    return a;\n  }\n  var b = [];\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return {string}\n */\n\nfunction getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\nfunction initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","arraySize","validate","validateIndex","resize","reshape","processSizesWildcard","squeeze","unsqueeze","flatten","map","forEach","filter","filterRegExp","join","identify","generalize","getArrayDataType","last","initial","contains","_number","require","_is","_string","_DimensionError","_IndexError","x","s","Array","isArray","push","length","_validate","array","size","dim","i","len","DimensionError","dimNext","child","isScalar","index","isNumber","isInteger","TypeError","IndexError","defaultValue","Error","format","_defaultValue","undefined","_resize","elem","oldLen","newLen","minLen","Math","min","sizes","flatArray","currentLength","newLength","product","_reshape","e","processedSizes","slice","WILDCARD","wildCardIndex","indexOf","isMoreThanOneWildcard","hasWildcard","canReplaceWildcard","reduce","prev","curr","tmpArray","tmpArray2","sizeIndex","shift","dims","_squeeze","ii","next","outer","unshift","_unsqueeze","d","flat","callback","prototype","call","regexp","entry","test","separator","a","b","count","identifier","typeOf","type","item","itemType"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/utils/array.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arraySize = arraySize;\nexports.validate = validate;\nexports.validateIndex = validateIndex;\nexports.resize = resize;\nexports.reshape = reshape;\nexports.processSizesWildcard = processSizesWildcard;\nexports.squeeze = squeeze;\nexports.unsqueeze = unsqueeze;\nexports.flatten = flatten;\nexports.map = map;\nexports.forEach = forEach;\nexports.filter = filter;\nexports.filterRegExp = filterRegExp;\nexports.join = join;\nexports.identify = identify;\nexports.generalize = generalize;\nexports.getArrayDataType = getArrayDataType;\nexports.last = last;\nexports.initial = initial;\nexports.contains = contains;\n\nvar _number = require(\"./number.js\");\n\nvar _is = require(\"./is.js\");\n\nvar _string = require(\"./string.js\");\n\nvar _DimensionError = require(\"../error/DimensionError.js\");\n\nvar _IndexError = require(\"../error/IndexError.js\");\n\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\nfunction arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new _DimensionError.DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new _DimensionError.DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new _DimensionError.DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nfunction validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new _DimensionError.DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\n\nfunction validateIndex(index, length) {\n  if (!(0, _is.isNumber)(index) || !(0, _number.isInteger)(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new _IndexError.IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\n\nfunction resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, _string.format)(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nfunction reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new _DimensionError.DimensionError(0, currentLength, '!=');\n  }\n\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n\n  if (currentLength !== newLength) {\n    throw new _DimensionError.DimensionError(newLength, currentLength, '!=');\n  }\n\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof _DimensionError.DimensionError) {\n      throw new _DimensionError.DimensionError(newLength, currentLength, '!=');\n    }\n\n    throw e;\n  }\n}\n/**\n * Replaces the wildcard -1 in the sizes array.\n * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.\n * @param {number} currentLength  Number of elements in the array.\n * @throws {Error}                If more than one wildcard or unable to replace it.\n * @returns {Array.<number>}      The sizes array with wildcard replaced.\n */\n\n\nfunction processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n\n  return processedSizes;\n}\n/**\n * Computes the product of all array elements.\n * @param {Array<number>} array Array of factors\n * @returns {number}            Product of all elements\n */\n\n\nfunction product(array) {\n  return array.reduce(function (prev, curr) {\n    return prev * curr;\n  }, 1);\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nfunction squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nfunction unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nfunction flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\n\nfunction map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\n\nfunction forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\n\nfunction filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\n\nfunction filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\n\nfunction join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\n\nfunction identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\n\nfunction generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return {string}\n */\n\n\nfunction getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\n\nfunction initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\n\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}