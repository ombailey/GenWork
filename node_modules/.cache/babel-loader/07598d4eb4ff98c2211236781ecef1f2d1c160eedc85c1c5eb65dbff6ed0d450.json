{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplify = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _simplifyCore = require(\"./simplify/simplifyCore.js\");\nvar _simplifyConstant = require(\"./simplify/simplifyConstant.js\");\nvar _resolve = require(\"./simplify/resolve.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _map = require(\"../../utils/map.js\");\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n    typed = _ref.typed,\n    parse = _ref.parse,\n    add = _ref.add,\n    subtract = _ref.subtract,\n    multiply = _ref.multiply,\n    divide = _ref.divide,\n    pow = _ref.pow,\n    isZero = _ref.isZero,\n    equal = _ref.equal,\n    fraction = _ref.fraction,\n    bignumber = _ref.bignumber,\n    mathWithTransform = _ref.mathWithTransform,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode,\n    SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var resolve = (0, _resolve.createResolve)({\n    parse: parse,\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    isCommutative = _createUtil.isCommutative,\n    isAssociative = _createUtil.isAssociative,\n    flatten = _createUtil.flatten,\n    unflattenr = _createUtil.unflattenr,\n    unflattenl = _createUtil.unflattenl,\n    createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  There is currently one option available:\n   *  - `exactFractions`: a boolean which is `true` by default.\n   *  - `fractionsLimit`: when `exactFractions` is true, a fraction will be returned\n   *    only when both numerator and denominator are smaller than `fractionsLimit`.\n   *    Default value is 10000.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, (0, _map.createEmptyMap)(), {});\n    },\n    'string, Map | Object': function stringMapObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Map | Object, Object': function stringMapObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, (0, _map.createEmptyMap)(), {});\n    },\n    'string, Array, Map | Object': function stringArrayMapObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Map | Object, Object': function stringArrayMapObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Map | Object': function NodeMapObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Map | Object, Object': function NodeMapObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, (0, _map.createEmptyMap)(), {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, (0, _map.createEmptyMap)(), {});\n    },\n    'Node, Array, Map | Object': function NodeArrayMapObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      return this(expr, rules, (0, _map.createMap)(scope), options);\n    },\n    'Node, Array, Map, Object': function NodeArrayMapObject(expr, rules, scope, options) {\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        for (var i = 0; i < rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore,\n  // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  },\n  // temporary rules\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  },\n  // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: '(-c) * v'\n  },\n  // make non-constant terms positive\n  {\n    l: '-v',\n    r: '(-1) * v'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  },\n  // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  },\n  // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  },\n  // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  },\n  // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'n1*n2 + n2',\n    r: '(n1+1)*n2'\n  }, {\n    l: 'n1*n3 + n2*n3',\n    r: '(n1+n2)*n3'\n  },\n  // remove parenthesis in the case of negating a quantitiy\n  {\n    l: 'n1 + -1 * (n2 + n3)',\n    r: 'n1 + -1 * n2 + -1 * n3'\n  }, simplifyConstant, {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  },\n  // make factors positive (and undo 'make non-constant terms positive')\n  // ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  },\n  // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  },\n  // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  },\n  // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  },\n  // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  },\n  // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = (0, _typeof2[\"default\"])(rule);\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n          if (rule.context) {\n            newRule.evaluate = rule.context;\n          }\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n            var expandsym = _getExpandPlaceholderSymbol();\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n          break;\n        case 'function':\n          newRule = rule;\n          break;\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n      ruleSet.push(newRule);\n    }\n    return ruleSet;\n  }\n  var _lastsym = 0;\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for (var i = 0; i < res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } // Try to match a rule against this node\n\n      var repl = rule.r;\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n    for (var key in match1.placeholders) {\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n    for (var _key in match2.placeholders) {\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n    var merged;\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n          childMatches.push(childMatch);\n        }\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!(0, _is.isConstantNode)(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n    return true;\n  }\n  return simplify;\n});\nexports.createSimplify = createSimplify;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createSimplify","_typeof2","_is","_factory","_util","_simplifyCore","_simplifyConstant","_resolve","_object","_map","name","dependencies","factory","_ref","config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","fraction","bignumber","mathWithTransform","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode","simplifyConstant","createSimplifyConstant","simplifyCore","createSimplifyCore","resolve","createResolve","_createUtil","createUtil","isCommutative","isAssociative","flatten","unflattenr","unflattenl","createMakeNodeFunction","simplify","string","expr","rules","createEmptyMap","stringMapObject","scope","stringMapObjectObject","options","stringArray","stringArrayMapObject","stringArrayMapObjectObject","NodeMapObject","NodeMapObjectObject","Node","NodeArray","NodeArrayMapObject","NodeArrayObjectObject","createMap","_buildRules","res","removeParens","visited","str","toString","parenthesis","_lastsym","i","length","applyRule","node","transform","path","parent","isParenthesisNode","content","SUPPORTED_CONSTANTS","e","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","l","r","context","commutative","ruleSet","rule","newRule","ruleType","lr","split","SyntaxError","evaluate","makeNode","expandsym","_getExpandPlaceholderSymbol","expanded","clone","TypeError","push","NodeObject","args","repl","matches","_ruleMatch","implicit","isSymbolNode","hasOwnProperty","placeholders","getSplits","right","rightArgs","slice","splice","mergeMatch","match1","match2","key","_exactMatch","_key","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","reduce","uniqueSets","unique","s","JSON","stringify","isSplit","op","fn","childMatch","splits","splitMatches","_i","matchSet","concat","Error","substring","isConstantNode","p","q"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/simplify.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplify = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _util = require(\"./simplify/util.js\");\n\nvar _simplifyCore = require(\"./simplify/simplifyCore.js\");\n\nvar _simplifyConstant = require(\"./simplify/simplifyConstant.js\");\n\nvar _resolve = require(\"./simplify/resolve.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _map = require(\"../../utils/map.js\");\n\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      parse = _ref.parse,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var resolve = (0, _resolve.createResolve)({\n    parse: parse,\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    ParenthesisNode: ParenthesisNode\n  });\n\n  var _createUtil = (0, _util.createUtil)({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      flatten = _createUtil.flatten,\n      unflattenr = _createUtil.unflattenr,\n      unflattenl = _createUtil.unflattenl,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  There is currently one option available:\n   *  - `exactFractions`: a boolean which is `true` by default.\n   *  - `fractionsLimit`: when `exactFractions` is true, a fraction will be returned\n   *    only when both numerator and denominator are smaller than `fractionsLimit`.\n   *    Default value is 10000.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, (0, _map.createEmptyMap)(), {});\n    },\n    'string, Map | Object': function stringMapObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Map | Object, Object': function stringMapObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, (0, _map.createEmptyMap)(), {});\n    },\n    'string, Array, Map | Object': function stringArrayMapObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Map | Object, Object': function stringArrayMapObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Map | Object': function NodeMapObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Map | Object, Object': function NodeMapObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, (0, _map.createEmptyMap)(), {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, (0, _map.createEmptyMap)(), {});\n    },\n    'Node, Array, Map | Object': function NodeArrayMapObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      return this(expr, rules, (0, _map.createMap)(scope), options);\n    },\n    'Node, Array, Map, Object': function NodeArrayMapObject(expr, rules, scope, options) {\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        for (var i = 0; i < rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: '(-c) * v'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: '(-1) * v'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'n1*n2 + n2',\n    r: '(n1+1)*n2'\n  }, {\n    l: 'n1*n3 + n2*n3',\n    r: '(n1+n2)*n3'\n  }, // remove parenthesis in the case of negating a quantitiy\n  {\n    l: 'n1 + -1 * (n2 + n3)',\n    r: 'n1 + -1 * n2 + -1 * n3'\n  }, simplifyConstant, {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  // ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = (0, _typeof2[\"default\"])(rule);\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.evaluate = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for (var i = 0; i < res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!(0, _is.isConstantNode)(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});\nexports.createSimplify = createSimplify;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}