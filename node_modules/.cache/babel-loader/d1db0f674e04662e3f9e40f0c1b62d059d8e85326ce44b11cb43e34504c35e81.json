{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importFactory = importFactory;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _ArgumentsError = require(\"../../error/ArgumentsError.js\");\nfunction importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n    if (num !== 1 && num !== 2) {\n      throw new _ArgumentsError.ArgumentsError('import', num, 1, 2);\n    }\n    if (!options) {\n      options = {};\n    }\n    function flattenImports(flatValues, value, name) {\n      if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if ((0, _typeof2[\"default\"])(value) === 'object') {\n        for (var _name in value) {\n          if ((0, _object.hasOwnProperty)(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if ((0, _factory.isFactory)(value) || name !== undefined) {\n        var flatName = (0, _factory.isFactory)(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' :\n        // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if ((0, _object.hasOwnProperty)(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n    for (var name in flatValues) {\n      if ((0, _object.hasOwnProperty)(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n        if ((0, _factory.isFactory)(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, (0, _defineProperty2[\"default\"])({}, value.signature, value));\n    }\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n      math[name] = value;\n      delete importedFactories[name];\n      _importTransform(name, value);\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n      _importTransform(name, value);\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n      return fn.apply(math, args);\n    };\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n    if ((0, _array.contains)(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = (0, _object.hasOwnProperty)(namespace, name) ? namespace[name] : undefined;\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(_factory.stripOptionalNotation).forEach(function (dependency) {\n        if ((0, _array.contains)(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      (0, _object.lazy)(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || (0, _is.isUnit)(object) || (0, _is.isComplex)(object) || (0, _is.isBigNumber)(object) || (0, _is.isFraction)(object) || (0, _is.isMatrix)(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && (0, _typeof2[\"default\"])(fn.signatures) === 'object';\n  }\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n  function allowedInExpressions(name) {\n    return !(0, _object.hasOwnProperty)(unsafe, name);\n  }\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 &&\n    // FIXME: make checking on path redundant, check on meta data instead\n    !(0, _object.hasOwnProperty)(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n  };\n\n  return mathImport;\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","importFactory","_defineProperty2","_typeof2","_is","_factory","_object","_array","_ArgumentsError","typed","load","math","importedFactories","mathImport","functions","options","num","arguments","length","ArgumentsError","flattenImports","flatValues","name","Array","isArray","forEach","item","_name","hasOwnProperty","isFactory","undefined","flatName","isTransformFunctionFactory","fn","silent","Error","TypeError","_importFactory","isSupportedType","_import","wrap","_wrap","hasTypedFunctionSignature","signature","isTypedFunction","override","signatures","_importTransform","emit","resolver","transform","expression","allowedInExpressions","mathWithTransform","_deleteTransform","wrapper","args","i","len","arg","valueOf","apply","factory","contains","JSON","stringify","namespace","existingTransform","existing","dependencies","map","stripOptionalNotation","dependency","classes","instance","meta","lazy","factoryAllowedInExpressions","object","isUnit","isComplex","isBigNumber","isFraction","isMatrix","unsafe","indexOf","isClass","isTransformFunction","type","docs","error","json","chain"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/core/function/import.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importFactory = importFactory;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _ArgumentsError = require(\"../../error/ArgumentsError.js\");\n\nfunction importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new _ArgumentsError.ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if ((0, _typeof2[\"default\"])(value) === 'object') {\n        for (var _name in value) {\n          if ((0, _object.hasOwnProperty)(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if ((0, _factory.isFactory)(value) || name !== undefined) {\n        var flatName = (0, _factory.isFactory)(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if ((0, _object.hasOwnProperty)(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if ((0, _object.hasOwnProperty)(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if ((0, _factory.isFactory)(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, (0, _defineProperty2[\"default\"])({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if ((0, _array.contains)(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = (0, _object.hasOwnProperty)(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(_factory.stripOptionalNotation).forEach(function (dependency) {\n        if ((0, _array.contains)(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      (0, _object.lazy)(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || (0, _is.isUnit)(object) || (0, _is.isComplex)(object) || (0, _is.isBigNumber)(object) || (0, _is.isFraction)(object) || (0, _is.isMatrix)(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && (0, _typeof2[\"default\"])(fn.signatures) === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !(0, _object.hasOwnProperty)(unsafe, name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !(0, _object.hasOwnProperty)(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}