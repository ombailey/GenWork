{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolve = void 0;\nvar _map = require(\"../../../utils/map.js\");\nvar _is = require(\"../../../utils/is.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar name = 'resolve';\nvar dependencies = ['parse', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\nvar createResolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse,\n    FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode;\n\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     simplify.resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.simplify.resolve('x + y', {x:1, y:2})           // Node {1 + 2}\n   *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}\n   *     math.simplify('x+y', {x:2, y:'x+x'}).toString()      // \"6\"\n   *\n   * @param {Node} node\n   *     The expression tree to be simplified\n   * @param {Object} scope with variables to be resolved\n   */\n  function resolve(node, scope) {\n    if (!scope) {\n      return node;\n    }\n    if (!(0, _map.isMap)(scope)) {\n      scope = (0, _map.createMap)(scope);\n    }\n    if ((0, _is.isSymbolNode)(node)) {\n      var value = scope.get(node.name);\n      if ((0, _is.isNode)(value)) {\n        return resolve(value, scope);\n      } else if (typeof value === 'number') {\n        return parse(String(value));\n      }\n    } else if ((0, _is.isOperatorNode)(node)) {\n      var args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if ((0, _is.isParenthesisNode)(node)) {\n      return new ParenthesisNode(resolve(node.content, scope));\n    } else if ((0, _is.isFunctionNode)(node)) {\n      var _args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n      return new FunctionNode(node.name, _args);\n    }\n    return node;\n  }\n  return resolve;\n});\nexports.createResolve = createResolve;","map":{"version":3,"names":["Object","defineProperty","exports","value","createResolve","_map","require","_is","_factory","name","dependencies","factory","_ref","parse","FunctionNode","OperatorNode","ParenthesisNode","resolve","node","scope","isMap","createMap","isSymbolNode","get","isNode","String","isOperatorNode","args","map","arg","op","fn","implicit","isParenthesisNode","content","isFunctionNode","_args"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/simplify/resolve.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolve = void 0;\n\nvar _map = require(\"../../../utils/map.js\");\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'resolve';\nvar dependencies = ['parse', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\nvar createResolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode;\n\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     simplify.resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.simplify.resolve('x + y', {x:1, y:2})           // Node {1 + 2}\n   *     math.simplify.resolve(math.parse('x+y'), {x:1, y:2}) // Node {1 + 2}\n   *     math.simplify('x+y', {x:2, y:'x+x'}).toString()      // \"6\"\n   *\n   * @param {Node} node\n   *     The expression tree to be simplified\n   * @param {Object} scope with variables to be resolved\n   */\n  function resolve(node, scope) {\n    if (!scope) {\n      return node;\n    }\n\n    if (!(0, _map.isMap)(scope)) {\n      scope = (0, _map.createMap)(scope);\n    }\n\n    if ((0, _is.isSymbolNode)(node)) {\n      var value = scope.get(node.name);\n\n      if ((0, _is.isNode)(value)) {\n        return resolve(value, scope);\n      } else if (typeof value === 'number') {\n        return parse(String(value));\n      }\n    } else if ((0, _is.isOperatorNode)(node)) {\n      var args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if ((0, _is.isParenthesisNode)(node)) {\n      return new ParenthesisNode(resolve(node.content, scope));\n    } else if ((0, _is.isFunctionNode)(node)) {\n      var _args = node.args.map(function (arg) {\n        return resolve(arg, scope);\n      });\n\n      return new FunctionNode(node.name, _args);\n    }\n\n    return node;\n  }\n\n  return resolve;\n});\nexports.createResolve = createResolve;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}