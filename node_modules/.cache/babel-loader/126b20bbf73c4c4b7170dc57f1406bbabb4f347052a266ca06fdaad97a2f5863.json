{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUtil = void 0;\nvar _is = require(\"../../../utils/is.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar _object = require(\"../../../utils/object.js\");\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nvar createUtil = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n  function isCommutative(node, context) {\n    if (!(0, _is.isOperatorNode)(node)) {\n      return true;\n    }\n    var name = node.fn.toString();\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n    return commutative[name] || false;\n  }\n  function isAssociative(node, context) {\n    if (!(0, _is.isOperatorNode)(node)) {\n      return false;\n    }\n    var name = node.fn.toString();\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'associative')) {\n      return context[name].associative;\n    }\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node);\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if ((0, _is.isOperatorNode)(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  function createMakeNodeFunction(node) {\n    if ((0, _is.isOperatorNode)(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});\nexports.createUtil = createUtil;","map":{"version":3,"names":["Object","defineProperty","exports","value","createUtil","_is","require","_factory","_object","name","dependencies","factory","_ref","FunctionNode","OperatorNode","SymbolNode","commutative","add","multiply","associative","isCommutative","node","context","isOperatorNode","fn","toString","hasOwnProperty","isAssociative","flatten","args","length","allChildren","i","op","children","findChildren","child","push","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/algebra/simplify/util.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUtil = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _object = require(\"../../../utils/object.js\");\n\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nvar createUtil = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!(0, _is.isOperatorNode)(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!(0, _is.isOperatorNode)(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && (0, _object.hasOwnProperty)(context, name) && (0, _object.hasOwnProperty)(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if ((0, _is.isOperatorNode)(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if ((0, _is.isOperatorNode)(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});\nexports.createUtil = createUtil;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}