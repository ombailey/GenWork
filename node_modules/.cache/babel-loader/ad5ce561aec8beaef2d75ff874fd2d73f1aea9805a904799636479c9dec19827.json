{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../core/frame\"));\nvar mathjs_1 = require(\"mathjs\");\nvar concat_1 = __importDefault(require(\"../transformers/concat\"));\nvar series_1 = __importDefault(require(\"../core/series\"));\n/**\n * The class performs all groupby operation on a dataframe\n * involving all aggregate funciton\n * @param {colDict} colDict Object of unique keys in the group by column\n * @param {keyCol} keyCol Array contains the column names\n * @param {data} Array the dataframe data\n * @param {columnName} Array of all column name in the dataframe.\n * @param {colDtype} Array columns dtype\n */\nvar Groupby = /** @class */function () {\n  function Groupby(keyCol, data, columnName, colDtype, colIndex) {\n    this.colDict = {};\n    this.keyToValue = {};\n    this.keyCol = keyCol;\n    this.data = data;\n    this.columnName = columnName;\n    //this.dataTensors = {}; //store the tensor version of the groupby data\n    this.colDtype = colDtype;\n    this.colIndex = colIndex;\n  }\n  /**\n   * Generate group object data needed for group operations\n   * let data = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 20, 30, 40 ], [ 39, 89, 78 ] ];\n   * let cols = [ \"A\", \"B\", \"C\" ];\n   * let df = new dfd.DataFrame(data, { columns: cols });\n   * let groupDf = df.groupby([ \"A\" ]);\n   * The following internal object is generated and save to this.colDict\n   * {\n   *  '1': { A: [ 1 ], B: [ 2 ], C: [ 3 ] },\n   *  '4': { A: [ 4 ], B: [ 5 ], C: [ 6 ] },\n   *  '20': { A: [ 20 ], B: [ 30 ], C: [ 40 ] },\n   *  '39': { A: [ 39 ], B: [ 89 ], C: [ 78 ] }\n   * }\n   * Since for groupby using more than one columns is index via '-'\n   * e.g for df.groupby(['A','B'])\n   * the result will look like this\n   * {\n   *  '1-2': {A: [ 1 ], B: [ 2 ], C: [ 3 ]},\n   *  '4-5': {A: [ 4 ], B: [ 5 ], C: [ 6 ]}\n   * }\n   * but in doing analysis on a specific column like this\n   * df.groupby(['A','B']).col(['C'])\n   * will have the following set of internal result\n   * {\n   *  '1-2': { C: [ 3 ]},\n   *  '4-5': {C: [ 6 ]}\n   * }\n   * In building our multindex type of DataFrame for this data,\n   * we've somehow loose track of value for column A and B.\n   * This could actually be generated by using split('-') on the object keys\n   * e.g '1-2'.split('-') will give us the value for A and B.\n   * But we might have weird case scenerio where A and B value has '-`\n   * e.g\n   * {\n   *  '1--2-': { C: [ 3 ]},\n   *  '4--5-': {C: [ 6 ]}\n   * }\n   * using `.split('-') might not work well\n   * Hence we create a key-value `keyToValue` object to store index and their\n   * associated value\n   * NOTE: In the previous implementation we made use of Graph representation\n   * for the group by data and Depth First search (DFS). But we decided to use key-value\n   * object in javascript as an hashmap to reduce search time compared to using Grpah and DFS\n   */\n  Groupby.prototype.group = function () {\n    var _a;\n    var self = this;\n    var keyToValue = {};\n    var group = (_a = this.data) === null || _a === void 0 ? void 0 : _a.reduce(function (prev, current) {\n      var indexes = [];\n      for (var i in self.colIndex) {\n        var index_1 = self.colIndex[i];\n        indexes.push(current[index_1]);\n      }\n      var index = indexes.join('-');\n      if (!keyToValue[index]) {\n        keyToValue[index] = indexes;\n      }\n      if (prev[index]) {\n        var data = prev[index];\n        for (var i in self.columnName) {\n          var colName = self.columnName[i];\n          data[colName].push(current[i]);\n        }\n      } else {\n        prev[index] = {};\n        for (var i in self.columnName) {\n          var colName = self.columnName[i];\n          prev[index][colName] = [current[i]];\n        }\n      }\n      return prev;\n    }, {});\n    this.colDict = group;\n    this.keyToValue = keyToValue;\n    return this;\n  };\n  /**\n   * Generate new internal groupby data\n   * group = df.groupby(['A', 'B']).col('C')\n   * This filter the colDict property as generated by `.group()`\n   * it filter each group to contain only column `C` in their internal object\n   * e.g\n   * {\n   *  '1-2': {A: [ 1 ], B: [ 2 ], C: [ 3 ]},\n   *  '4-5': {A: [ 4 ], B: [ 5 ], C: [ 6 ]}\n   * }\n   * to\n   * {\n   *  '1-2': { C: [ 3 ]},\n   *  '4-5': {C: [ 6 ]}\n   * }\n   * @param colNames column names\n   * @return Groupby\n   */\n  Groupby.prototype.col = function (colNames) {\n    var _this = this;\n    if (typeof colNames === \"undefined\") {\n      colNames = this.columnName.filter(function (_, index) {\n        return !_this.colIndex.includes(index);\n      });\n    }\n    var self = this;\n    colNames.forEach(function (val) {\n      if (!self.columnName.includes(val)) throw new Error(\"Column \" + val + \" does not exist in groups\");\n    });\n    var colDict = __assign({}, this.colDict);\n    for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n      var _b = _a[_i],\n        key = _b[0],\n        values = _b[1];\n      var c = {};\n      var keyVal = __assign({}, values);\n      for (var colKey in colNames) {\n        var colName = colNames[colKey];\n        c[colName] = keyVal[colName];\n      }\n      colDict[key] = c;\n    }\n    var gp = new Groupby(this.keyCol, null, this.columnName, this.colDtype, this.colIndex);\n    gp.colDict = colDict;\n    gp.groupColNames = colNames;\n    gp.keyToValue = this.keyToValue;\n    return gp;\n  };\n  /**\n   * Perform all groupby arithmetic operations\n   * In the previous implementation all groups data are\n   * stord as DataFrame, which involve lot of memory usage\n   * Hence each groups are just pure javascrit object\n   * and all arithmetic operation is done directly on javascript\n   * arrays.\n   * e.g\n   * using this internal data\n   * {\n   *  '1-2': {A: [ 1,3 ], B: [ 2,5 ], C: [ 3, 5 ]},\n   *  '4-5': {A: [ 4,1 ], B: [ 5,0 ], C: [ 6, 12 ]}\n   * }\n   * 1) using groupby(['A', 'B']).arithmetic(\"mean\")\n   * result: * {\n   *  '1-2': {A_mean: [ 2 ], B_mean: [ 3.5 ], C_mean: [ 4 ]},\n   *  '4-5': {A_mean: [ 2.5 ], B: [ 2.5 ], C_mean: [ 9 ]}\n   * }\n   * 2) .arithmetic({\n   *    A: 'mean',\n   *    B: 'sum',\n   *    C: 'min'\n   * })\n   * result:\n   * {\n   *  '1-2': {A_mean: [ 2 ], B_sum: [ 7 ], C_min: [ 3 ]},\n   *  '4-5': {A_mean: [ 2.5 ], B_sum: [ 5 ], C_min: [ 6 ]}\n   * }\n   * 3) .arithmetic({\n   *    A: 'mean',\n   *    B: 'sum',\n   *    C: ['min', 'max']\n   * })\n   * result:\n   * {\n   *  '1-2': {A_mean: [ 2 ], B_sum: [ 7 ], C_min: [ 3 ], C_max: [5]},\n   *  '4-5': {A_mean: [ 2.5 ], B_sum: [ 5 ], C_min: [ 6 ], C_max: [12]}\n   * }\n   * @param operation\n   */\n  Groupby.prototype.arithemetic = function (operation) {\n    var opsName = [\"mean\", \"sum\", \"count\", \"mode\", \"std\", \"var\", \"cumsum\", \"cumprod\", \"cummax\", \"cummin\", \"median\", \"min\", \"max\"];\n    if (typeof operation === \"string\") {\n      if (!opsName.includes(operation)) {\n        throw new Error(\"group operation: \" + operation + \" is not valid\");\n      }\n    } else {\n      Object.keys(operation).forEach(function (key) {\n        var ops = operation[key];\n        if (Array.isArray(ops)) {\n          for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n            var op = ops_1[_i];\n            if (!opsName.includes(op)) {\n              throw new Error(\"group operation: \" + op + \" for column \" + key + \" is not valid\");\n            }\n          }\n        } else {\n          if (!opsName.includes(ops)) {\n            throw new Error(\"group operation: \" + ops + \" for column \" + key + \" is not valid\");\n          }\n        }\n      });\n    }\n    var colDict = __assign({}, this.colDict);\n    for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n      var _b = _a[_i],\n        key = _b[0],\n        values = _b[1];\n      var colVal = {};\n      var keyVal = __assign({}, values);\n      var groupColNames = this.groupColNames;\n      for (var colKey = 0; colKey < groupColNames.length; colKey++) {\n        var colName = groupColNames[colKey];\n        var colIndex = this.columnName.indexOf(colName);\n        var colDtype = this.colDtype[colIndex];\n        var operationVal = typeof operation === \"string\" ? operation : operation[colName];\n        if (colDtype === \"string\" && operationVal !== \"count\") throw new Error(\"Can't perform math operation on column \" + colName);\n        if (typeof operation === \"string\") {\n          var colName2 = colName + \"_\" + operation;\n          colVal[colName2] = this.groupMathLog(keyVal[colName], operation);\n        } else {\n          if (Array.isArray(operation[colName])) {\n            for (var _c = 0, _d = operation[colName]; _c < _d.length; _c++) {\n              var ops = _d[_c];\n              var colName2 = colName + \"_\" + ops;\n              colVal[colName2] = this.groupMathLog(keyVal[colName], ops);\n            }\n          } else {\n            var ops = operation[colName];\n            var colName2 = colName + \"_\" + ops;\n            colVal[colName2] = this.groupMathLog(keyVal[colName], ops);\n          }\n        }\n      }\n      colDict[key] = colVal;\n    }\n    return colDict;\n  };\n  /**\n   * Peform all arithmetic logic\n   * @param colVal\n   * @param ops\n   */\n  Groupby.prototype.groupMathLog = function (colVal, ops) {\n    var data = [];\n    switch (ops) {\n      case \"max\":\n        var max = colVal.reduce(function (prev, curr) {\n          if (prev > curr) {\n            return prev;\n          }\n          return curr;\n        });\n        data.push(max);\n        break;\n      case \"min\":\n        var min = colVal.reduce(function (prev, curr) {\n          if (prev < curr) {\n            return prev;\n          }\n          return curr;\n        });\n        data.push(min);\n        break;\n      case \"sum\":\n        var sum = colVal.reduce(function (prev, curr) {\n          return prev + curr;\n        });\n        data.push(sum);\n        break;\n      case \"count\":\n        data.push(colVal.length);\n        break;\n      case \"mean\":\n        var sumMean = colVal.reduce(function (prev, curr) {\n          return prev + curr;\n        });\n        data.push(sumMean / colVal.length);\n        break;\n      case \"std\":\n        data.push((0, mathjs_1.std)(colVal));\n        break;\n      case \"var\":\n        data.push((0, mathjs_1.variance)(colVal));\n        break;\n      case \"median\":\n        data.push((0, mathjs_1.median)(colVal));\n        break;\n      case \"mode\":\n        data.push((0, mathjs_1.mode)(colVal));\n        break;\n      case \"cumsum\":\n        colVal.reduce(function (prev, curr) {\n          var sum = prev + curr;\n          data.push(sum);\n          return sum;\n        }, 0);\n        break;\n      case \"cummin\":\n        data = [colVal[0]];\n        colVal.slice(1).reduce(function (prev, curr) {\n          if (prev < curr) {\n            data.push(prev);\n            return prev;\n          }\n          data.push(curr);\n          return curr;\n        }, data[0]);\n        break;\n      case \"cummax\":\n        data = [colVal[0]];\n        colVal.slice(1).reduce(function (prev, curr) {\n          if (prev > curr) {\n            data.push(prev);\n            return prev;\n          }\n          data.push(curr);\n          return curr;\n        }, data[0]);\n        break;\n      case \"cumprod\":\n        colVal.reduce(function (prev, curr) {\n          var sum = prev * curr;\n          data.push(sum);\n          return sum;\n        }, 1);\n        break;\n    }\n    return data;\n  };\n  /**\n   * Takes in internal groupby internal data and convert\n   * them to a single data frame.\n   * @param colDict\n   */\n  Groupby.prototype.toDataFrame = function (colDict) {\n    var data = {};\n    for (var _i = 0, _a = this.colKeyDict(colDict); _i < _a.length; _i++) {\n      var key = _a[_i];\n      var value = colDict[key];\n      var keyDict = {};\n      var oneValue = Object.values(value)[0];\n      var valueLen = oneValue.length;\n      for (var key1 in this.keyCol) {\n        var keyName = this.keyCol[key1];\n        var keyValue = this.keyToValue[key][key1];\n        keyDict[keyName] = Array(valueLen).fill(keyValue);\n      }\n      var combine = __assign(__assign({}, keyDict), value);\n      if (Object.keys(data).length < 1) {\n        data = combine;\n      } else {\n        for (var _b = 0, _c = Object.keys(data); _b < _c.length; _b++) {\n          var dataKey = _c[_b];\n          var dataValue = combine[dataKey];\n          data[dataKey] = __spreadArray(__spreadArray([], data[dataKey], true), dataValue, true);\n        }\n      }\n    }\n    return new frame_1.default(data);\n  };\n  Groupby.prototype.operations = function (ops) {\n    if (!this.groupColNames) {\n      var colGroup = this.col(undefined);\n      var colDict_1 = colGroup.arithemetic(ops);\n      var df_1 = colGroup.toDataFrame(colDict_1);\n      return df_1;\n    }\n    var colDict = this.arithemetic(ops);\n    var df = this.toDataFrame(colDict);\n    return df;\n  };\n  /**\n   * Obtain the count for each group\n   * @returns DataFrame\n   *\n   */\n  Groupby.prototype.count = function () {\n    return this.operations(\"count\");\n  };\n  /**\n   * Obtain the sum of columns for each group\n   * @returns DataFrame\n   *\n   */\n  Groupby.prototype.sum = function () {\n    return this.operations(\"sum\");\n  };\n  /**\n   * Obtain the standard deviation of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.std = function () {\n    return this.operations(\"std\");\n  };\n  /**\n   * Obtain the variance of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.var = function () {\n    return this.operations(\"var\");\n  };\n  /**\n   * Obtain the mean of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.mean = function () {\n    return this.operations(\"mean\");\n  };\n  /**\n   * Obtain the cumsum of columns for each group\n   * @returns DataFrame\n   *\n   */\n  Groupby.prototype.cumSum = function () {\n    return this.operations(\"cumsum\");\n  };\n  /**\n   * Obtain the cummax of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.cumMax = function () {\n    return this.operations(\"cummax\");\n  };\n  /**\n   * Obtain the cumprod of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.cumProd = function () {\n    return this.operations(\"cumprod\");\n  };\n  /**\n   * Obtain the cummin of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.cumMin = function () {\n    return this.operations(\"cummin\");\n  };\n  /**\n   * Obtain the max value of columns for each group\n   * @returns DataFrame\n   *\n   */\n  Groupby.prototype.max = function () {\n    return this.operations(\"max\");\n  };\n  /**\n   * Obtain the min of columns for each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.min = function () {\n    return this.operations(\"min\");\n  };\n  /**\n   * Obtain a specific group\n   * @param keys Array<string | number>\n   * @returns DataFrame\n   */\n  Groupby.prototype.getGroup = function (keys) {\n    var dictKey = keys.join(\"-\");\n    var colDict = {};\n    colDict[dictKey] = __assign({}, this.colDict[dictKey]);\n    return this.toDataFrame(colDict);\n  };\n  /**\n   * Perform aggregation on all groups\n   * @param ops\n   * @returns DataFrame\n   */\n  Groupby.prototype.agg = function (ops) {\n    var columns = Object.keys(ops);\n    var col_gp = this.col(columns);\n    var data = col_gp.arithemetic(ops);\n    var df = col_gp.toDataFrame(data);\n    return df;\n  };\n  /**\n   * Apply custom aggregator function\n   * to each group\n   * @param callable\n   * @returns DataFrame\n   * @example\n   * let grp = df.groupby(['A'])\n   * grp.apply((x) => x.count())\n   */\n  Groupby.prototype.apply = function (callable) {\n    var colDict = {};\n    for (var _i = 0, _a = this.colKeyDict(this.colDict); _i < _a.length; _i++) {\n      var key = _a[_i];\n      var valDataframe = new frame_1.default(this.colDict[key]);\n      colDict[key] = callable(valDataframe);\n    }\n    return this.concatGroups(colDict);\n  };\n  Groupby.prototype.concatGroups = function (colDict) {\n    var data = [];\n    for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n      var _b = _a[_i],\n        key = _b[0],\n        values = _b[1];\n      var copyDf = void 0;\n      if (values instanceof frame_1.default) {\n        copyDf = values.copy();\n      } else {\n        var columns = values.index;\n        columns = columns.length > 1 ? columns : ['applyOps'];\n        copyDf = new frame_1.default([values.values], {\n          columns: columns\n        });\n      }\n      var len = copyDf.shape[0];\n      var key1 = void 0;\n      for (key1 in this.keyCol) {\n        var keyName = this.keyCol[key1];\n        var keyValue = this.keyToValue[key][key1];\n        var dfValue = Array(len).fill(keyValue);\n        var atIndex = parseInt(key1);\n        if (this.groupColNames) {\n          copyDf.addColumn(keyName, dfValue, {\n            inplace: true,\n            atIndex: atIndex\n          });\n        } else {\n          copyDf.addColumn(keyName + \"_Group\", dfValue, {\n            inplace: true,\n            atIndex: atIndex\n          });\n        }\n      }\n      data.push(copyDf);\n    }\n    return (0, concat_1.default)({\n      dfList: data,\n      axis: 0\n    });\n  };\n  Object.defineProperty(Groupby.prototype, \"ngroups\", {\n    /**\n     * obtain the total number of groups\n     * @returns number\n     */\n    get: function () {\n      var keys = Object.keys(this.colDict);\n      return keys.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Groupby.prototype, \"groups\", {\n    /**\n     * obtaind the internal group data\n     * @returns  {[keys: string]: {}}\n     */\n    get: function () {\n      return this.colDict;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Obtain the first row of each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.first = function () {\n    return this.apply(function (x) {\n      return x.head(1);\n    });\n  };\n  /**\n   * Obtain the last row of each group\n   * @returns DataFrame\n   */\n  Groupby.prototype.last = function () {\n    return this.apply(function (x) {\n      return x.tail(1);\n    });\n  };\n  /**\n   * Obtains the dataframe se of each groups\n   * @returns DataFrame\n   */\n  Groupby.prototype.size = function () {\n    return this.apply(function (x) {\n      return new series_1.default([x.shape[0]]);\n    });\n  };\n  Groupby.prototype.colKeyDict = function (colDict) {\n    var keyDict = {};\n    for (var _i = 0, _a = Object.keys(colDict); _i < _a.length; _i++) {\n      var key = _a[_i];\n      var firstKey = key.split(\"-\")[0];\n      if (firstKey in keyDict) {\n        keyDict[firstKey].push(key);\n      } else {\n        keyDict[firstKey] = [key];\n      }\n    }\n    var keys = [];\n    for (var _b = 0, _c = Object.keys(keyDict); _b < _c.length; _b++) {\n      var key = _c[_b];\n      keys.push.apply(keys, keyDict[key]);\n    }\n    return keys;\n  };\n  return Groupby;\n}();\nexports.default = Groupby;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","__importDefault","mod","__esModule","defineProperty","exports","value","frame_1","require","mathjs_1","concat_1","series_1","Groupby","keyCol","data","columnName","colDtype","colIndex","colDict","keyToValue","group","_a","self","reduce","prev","current","indexes","index_1","push","index","join","colName","col","colNames","_this","filter","_","includes","forEach","val","Error","_i","entries","_b","key","values","c","keyVal","colKey","gp","groupColNames","arithemetic","operation","opsName","keys","ops","isArray","ops_1","op","colVal","indexOf","operationVal","colName2","groupMathLog","_c","_d","max","curr","min","sum","sumMean","std","variance","median","mode","toDataFrame","colKeyDict","keyDict","oneValue","valueLen","key1","keyName","keyValue","fill","combine","dataKey","dataValue","default","operations","colGroup","undefined","colDict_1","df_1","df","count","var","mean","cumSum","cumMax","cumProd","cumMin","getGroup","dictKey","agg","columns","col_gp","callable","valDataframe","concatGroups","copyDf","copy","len","shape","dfValue","atIndex","parseInt","addColumn","inplace","dfList","axis","get","enumerable","configurable","first","x","head","last","tail","size","firstKey","split"],"sources":["/Users/omarbailey/node_modules/danfojs/dist/danfojs-base/aggregators/groupby.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../core/frame\"));\nvar mathjs_1 = require(\"mathjs\");\nvar concat_1 = __importDefault(require(\"../transformers/concat\"));\nvar series_1 = __importDefault(require(\"../core/series\"));\n/**\n * The class performs all groupby operation on a dataframe\n * involving all aggregate funciton\n * @param {colDict} colDict Object of unique keys in the group by column\n * @param {keyCol} keyCol Array contains the column names\n * @param {data} Array the dataframe data\n * @param {columnName} Array of all column name in the dataframe.\n * @param {colDtype} Array columns dtype\n */\nvar Groupby = /** @class */ (function () {\n    function Groupby(keyCol, data, columnName, colDtype, colIndex) {\n        this.colDict = {};\n        this.keyToValue = {};\n        this.keyCol = keyCol;\n        this.data = data;\n        this.columnName = columnName;\n        //this.dataTensors = {}; //store the tensor version of the groupby data\n        this.colDtype = colDtype;\n        this.colIndex = colIndex;\n    }\n    /**\n     * Generate group object data needed for group operations\n     * let data = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 20, 30, 40 ], [ 39, 89, 78 ] ];\n     * let cols = [ \"A\", \"B\", \"C\" ];\n     * let df = new dfd.DataFrame(data, { columns: cols });\n     * let groupDf = df.groupby([ \"A\" ]);\n     * The following internal object is generated and save to this.colDict\n     * {\n     *  '1': { A: [ 1 ], B: [ 2 ], C: [ 3 ] },\n     *  '4': { A: [ 4 ], B: [ 5 ], C: [ 6 ] },\n     *  '20': { A: [ 20 ], B: [ 30 ], C: [ 40 ] },\n     *  '39': { A: [ 39 ], B: [ 89 ], C: [ 78 ] }\n     * }\n     * Since for groupby using more than one columns is index via '-'\n     * e.g for df.groupby(['A','B'])\n     * the result will look like this\n     * {\n     *  '1-2': {A: [ 1 ], B: [ 2 ], C: [ 3 ]},\n     *  '4-5': {A: [ 4 ], B: [ 5 ], C: [ 6 ]}\n     * }\n     * but in doing analysis on a specific column like this\n     * df.groupby(['A','B']).col(['C'])\n     * will have the following set of internal result\n     * {\n     *  '1-2': { C: [ 3 ]},\n     *  '4-5': {C: [ 6 ]}\n     * }\n     * In building our multindex type of DataFrame for this data,\n     * we've somehow loose track of value for column A and B.\n     * This could actually be generated by using split('-') on the object keys\n     * e.g '1-2'.split('-') will give us the value for A and B.\n     * But we might have weird case scenerio where A and B value has '-`\n     * e.g\n     * {\n     *  '1--2-': { C: [ 3 ]},\n     *  '4--5-': {C: [ 6 ]}\n     * }\n     * using `.split('-') might not work well\n     * Hence we create a key-value `keyToValue` object to store index and their\n     * associated value\n     * NOTE: In the previous implementation we made use of Graph representation\n     * for the group by data and Depth First search (DFS). But we decided to use key-value\n     * object in javascript as an hashmap to reduce search time compared to using Grpah and DFS\n     */\n    Groupby.prototype.group = function () {\n        var _a;\n        var self = this;\n        var keyToValue = {};\n        var group = (_a = this.data) === null || _a === void 0 ? void 0 : _a.reduce(function (prev, current) {\n            var indexes = [];\n            for (var i in self.colIndex) {\n                var index_1 = self.colIndex[i];\n                indexes.push(current[index_1]);\n            }\n            var index = indexes.join('-');\n            if (!keyToValue[index]) {\n                keyToValue[index] = indexes;\n            }\n            if (prev[index]) {\n                var data = prev[index];\n                for (var i in self.columnName) {\n                    var colName = self.columnName[i];\n                    data[colName].push(current[i]);\n                }\n            }\n            else {\n                prev[index] = {};\n                for (var i in self.columnName) {\n                    var colName = self.columnName[i];\n                    prev[index][colName] = [current[i]];\n                }\n            }\n            return prev;\n        }, {});\n        this.colDict = group;\n        this.keyToValue = keyToValue;\n        return this;\n    };\n    /**\n     * Generate new internal groupby data\n     * group = df.groupby(['A', 'B']).col('C')\n     * This filter the colDict property as generated by `.group()`\n     * it filter each group to contain only column `C` in their internal object\n     * e.g\n     * {\n     *  '1-2': {A: [ 1 ], B: [ 2 ], C: [ 3 ]},\n     *  '4-5': {A: [ 4 ], B: [ 5 ], C: [ 6 ]}\n     * }\n     * to\n     * {\n     *  '1-2': { C: [ 3 ]},\n     *  '4-5': {C: [ 6 ]}\n     * }\n     * @param colNames column names\n     * @return Groupby\n     */\n    Groupby.prototype.col = function (colNames) {\n        var _this = this;\n        if (typeof colNames === \"undefined\") {\n            colNames = this.columnName.filter(function (_, index) {\n                return !_this.colIndex.includes(index);\n            });\n        }\n        var self = this;\n        colNames.forEach(function (val) {\n            if (!self.columnName.includes(val))\n                throw new Error(\"Column \" + val + \" does not exist in groups\");\n        });\n        var colDict = __assign({}, this.colDict);\n        for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], values = _b[1];\n            var c = {};\n            var keyVal = __assign({}, values);\n            for (var colKey in colNames) {\n                var colName = colNames[colKey];\n                c[colName] = keyVal[colName];\n            }\n            colDict[key] = c;\n        }\n        var gp = new Groupby(this.keyCol, null, this.columnName, this.colDtype, this.colIndex);\n        gp.colDict = colDict;\n        gp.groupColNames = colNames;\n        gp.keyToValue = this.keyToValue;\n        return gp;\n    };\n    /**\n     * Perform all groupby arithmetic operations\n     * In the previous implementation all groups data are\n     * stord as DataFrame, which involve lot of memory usage\n     * Hence each groups are just pure javascrit object\n     * and all arithmetic operation is done directly on javascript\n     * arrays.\n     * e.g\n     * using this internal data\n     * {\n     *  '1-2': {A: [ 1,3 ], B: [ 2,5 ], C: [ 3, 5 ]},\n     *  '4-5': {A: [ 4,1 ], B: [ 5,0 ], C: [ 6, 12 ]}\n     * }\n     * 1) using groupby(['A', 'B']).arithmetic(\"mean\")\n     * result: * {\n     *  '1-2': {A_mean: [ 2 ], B_mean: [ 3.5 ], C_mean: [ 4 ]},\n     *  '4-5': {A_mean: [ 2.5 ], B: [ 2.5 ], C_mean: [ 9 ]}\n     * }\n     * 2) .arithmetic({\n     *    A: 'mean',\n     *    B: 'sum',\n     *    C: 'min'\n     * })\n     * result:\n     * {\n     *  '1-2': {A_mean: [ 2 ], B_sum: [ 7 ], C_min: [ 3 ]},\n     *  '4-5': {A_mean: [ 2.5 ], B_sum: [ 5 ], C_min: [ 6 ]}\n     * }\n     * 3) .arithmetic({\n     *    A: 'mean',\n     *    B: 'sum',\n     *    C: ['min', 'max']\n     * })\n     * result:\n     * {\n     *  '1-2': {A_mean: [ 2 ], B_sum: [ 7 ], C_min: [ 3 ], C_max: [5]},\n     *  '4-5': {A_mean: [ 2.5 ], B_sum: [ 5 ], C_min: [ 6 ], C_max: [12]}\n     * }\n     * @param operation\n     */\n    Groupby.prototype.arithemetic = function (operation) {\n        var opsName = [\"mean\", \"sum\", \"count\", \"mode\", \"std\", \"var\", \"cumsum\", \"cumprod\",\n            \"cummax\", \"cummin\", \"median\", \"min\", \"max\"];\n        if (typeof operation === \"string\") {\n            if (!opsName.includes(operation)) {\n                throw new Error(\"group operation: \" + operation + \" is not valid\");\n            }\n        }\n        else {\n            Object.keys(operation).forEach(function (key) {\n                var ops = operation[key];\n                if (Array.isArray(ops)) {\n                    for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n                        var op = ops_1[_i];\n                        if (!opsName.includes(op)) {\n                            throw new Error(\"group operation: \" + op + \" for column \" + key + \" is not valid\");\n                        }\n                    }\n                }\n                else {\n                    if (!opsName.includes(ops)) {\n                        throw new Error(\"group operation: \" + ops + \" for column \" + key + \" is not valid\");\n                    }\n                }\n            });\n        }\n        var colDict = __assign({}, this.colDict);\n        for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], values = _b[1];\n            var colVal = {};\n            var keyVal = __assign({}, values);\n            var groupColNames = this.groupColNames;\n            for (var colKey = 0; colKey < groupColNames.length; colKey++) {\n                var colName = groupColNames[colKey];\n                var colIndex = this.columnName.indexOf(colName);\n                var colDtype = this.colDtype[colIndex];\n                var operationVal = (typeof operation === \"string\") ? operation : operation[colName];\n                if (colDtype === \"string\" && operationVal !== \"count\")\n                    throw new Error(\"Can't perform math operation on column \" + colName);\n                if (typeof operation === \"string\") {\n                    var colName2 = colName + \"_\" + operation;\n                    colVal[colName2] = this.groupMathLog(keyVal[colName], operation);\n                }\n                else {\n                    if (Array.isArray(operation[colName])) {\n                        for (var _c = 0, _d = operation[colName]; _c < _d.length; _c++) {\n                            var ops = _d[_c];\n                            var colName2 = colName + \"_\" + ops;\n                            colVal[colName2] = this.groupMathLog(keyVal[colName], ops);\n                        }\n                    }\n                    else {\n                        var ops = operation[colName];\n                        var colName2 = colName + \"_\" + ops;\n                        colVal[colName2] = this.groupMathLog(keyVal[colName], ops);\n                    }\n                }\n            }\n            colDict[key] = colVal;\n        }\n        return colDict;\n    };\n    /**\n     * Peform all arithmetic logic\n     * @param colVal\n     * @param ops\n     */\n    Groupby.prototype.groupMathLog = function (colVal, ops) {\n        var data = [];\n        switch (ops) {\n            case \"max\":\n                var max = colVal.reduce(function (prev, curr) {\n                    if (prev > curr) {\n                        return prev;\n                    }\n                    return curr;\n                });\n                data.push(max);\n                break;\n            case \"min\":\n                var min = colVal.reduce(function (prev, curr) {\n                    if (prev < curr) {\n                        return prev;\n                    }\n                    return curr;\n                });\n                data.push(min);\n                break;\n            case \"sum\":\n                var sum = colVal.reduce(function (prev, curr) {\n                    return prev + curr;\n                });\n                data.push(sum);\n                break;\n            case \"count\":\n                data.push(colVal.length);\n                break;\n            case \"mean\":\n                var sumMean = colVal.reduce(function (prev, curr) {\n                    return prev + curr;\n                });\n                data.push(sumMean / colVal.length);\n                break;\n            case \"std\":\n                data.push((0, mathjs_1.std)(colVal));\n                break;\n            case \"var\":\n                data.push((0, mathjs_1.variance)(colVal));\n                break;\n            case \"median\":\n                data.push((0, mathjs_1.median)(colVal));\n                break;\n            case \"mode\":\n                data.push((0, mathjs_1.mode)(colVal));\n                break;\n            case \"cumsum\":\n                colVal.reduce(function (prev, curr) {\n                    var sum = prev + curr;\n                    data.push(sum);\n                    return sum;\n                }, 0);\n                break;\n            case \"cummin\":\n                data = [colVal[0]];\n                colVal.slice(1).reduce(function (prev, curr) {\n                    if (prev < curr) {\n                        data.push(prev);\n                        return prev;\n                    }\n                    data.push(curr);\n                    return curr;\n                }, data[0]);\n                break;\n            case \"cummax\":\n                data = [colVal[0]];\n                colVal.slice(1).reduce(function (prev, curr) {\n                    if (prev > curr) {\n                        data.push(prev);\n                        return prev;\n                    }\n                    data.push(curr);\n                    return curr;\n                }, data[0]);\n                break;\n            case \"cumprod\":\n                colVal.reduce(function (prev, curr) {\n                    var sum = prev * curr;\n                    data.push(sum);\n                    return sum;\n                }, 1);\n                break;\n        }\n        return data;\n    };\n    /**\n     * Takes in internal groupby internal data and convert\n     * them to a single data frame.\n     * @param colDict\n     */\n    Groupby.prototype.toDataFrame = function (colDict) {\n        var data = {};\n        for (var _i = 0, _a = this.colKeyDict(colDict); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var value = colDict[key];\n            var keyDict = {};\n            var oneValue = Object.values(value)[0];\n            var valueLen = oneValue.length;\n            for (var key1 in this.keyCol) {\n                var keyName = this.keyCol[key1];\n                var keyValue = this.keyToValue[key][key1];\n                keyDict[keyName] = Array(valueLen).fill(keyValue);\n            }\n            var combine = __assign(__assign({}, keyDict), value);\n            if (Object.keys(data).length < 1) {\n                data = combine;\n            }\n            else {\n                for (var _b = 0, _c = Object.keys(data); _b < _c.length; _b++) {\n                    var dataKey = _c[_b];\n                    var dataValue = combine[dataKey];\n                    data[dataKey] = __spreadArray(__spreadArray([], data[dataKey], true), dataValue, true);\n                }\n            }\n        }\n        return new frame_1.default(data);\n    };\n    Groupby.prototype.operations = function (ops) {\n        if (!this.groupColNames) {\n            var colGroup = this.col(undefined);\n            var colDict_1 = colGroup.arithemetic(ops);\n            var df_1 = colGroup.toDataFrame(colDict_1);\n            return df_1;\n        }\n        var colDict = this.arithemetic(ops);\n        var df = this.toDataFrame(colDict);\n        return df;\n    };\n    /**\n     * Obtain the count for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.count = function () {\n        return this.operations(\"count\");\n    };\n    /**\n     * Obtain the sum of columns for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.sum = function () {\n        return this.operations(\"sum\");\n    };\n    /**\n     * Obtain the standard deviation of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.std = function () {\n        return this.operations(\"std\");\n    };\n    /**\n     * Obtain the variance of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.var = function () {\n        return this.operations(\"var\");\n    };\n    /**\n     * Obtain the mean of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.mean = function () {\n        return this.operations(\"mean\");\n    };\n    /**\n     * Obtain the cumsum of columns for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.cumSum = function () {\n        return this.operations(\"cumsum\");\n    };\n    /**\n     * Obtain the cummax of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.cumMax = function () {\n        return this.operations(\"cummax\");\n    };\n    /**\n     * Obtain the cumprod of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.cumProd = function () {\n        return this.operations(\"cumprod\");\n    };\n    /**\n     * Obtain the cummin of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.cumMin = function () {\n        return this.operations(\"cummin\");\n    };\n    /**\n     * Obtain the max value of columns for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.max = function () {\n        return this.operations(\"max\");\n    };\n    /**\n     * Obtain the min of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.min = function () {\n        return this.operations(\"min\");\n    };\n    /**\n     * Obtain a specific group\n     * @param keys Array<string | number>\n     * @returns DataFrame\n     */\n    Groupby.prototype.getGroup = function (keys) {\n        var dictKey = keys.join(\"-\");\n        var colDict = {};\n        colDict[dictKey] = __assign({}, this.colDict[dictKey]);\n        return this.toDataFrame(colDict);\n    };\n    /**\n     * Perform aggregation on all groups\n     * @param ops\n     * @returns DataFrame\n     */\n    Groupby.prototype.agg = function (ops) {\n        var columns = Object.keys(ops);\n        var col_gp = this.col(columns);\n        var data = col_gp.arithemetic(ops);\n        var df = col_gp.toDataFrame(data);\n        return df;\n    };\n    /**\n     * Apply custom aggregator function\n     * to each group\n     * @param callable\n     * @returns DataFrame\n     * @example\n     * let grp = df.groupby(['A'])\n     * grp.apply((x) => x.count())\n     */\n    Groupby.prototype.apply = function (callable) {\n        var colDict = {};\n        for (var _i = 0, _a = this.colKeyDict(this.colDict); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var valDataframe = new frame_1.default(this.colDict[key]);\n            colDict[key] = callable(valDataframe);\n        }\n        return this.concatGroups(colDict);\n    };\n    Groupby.prototype.concatGroups = function (colDict) {\n        var data = [];\n        for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], values = _b[1];\n            var copyDf = void 0;\n            if (values instanceof frame_1.default) {\n                copyDf = values.copy();\n            }\n            else {\n                var columns = values.index;\n                columns = columns.length > 1 ? columns : ['applyOps'];\n                copyDf = new frame_1.default([values.values], { columns: columns });\n            }\n            var len = copyDf.shape[0];\n            var key1 = void 0;\n            for (key1 in this.keyCol) {\n                var keyName = this.keyCol[key1];\n                var keyValue = this.keyToValue[key][key1];\n                var dfValue = Array(len).fill(keyValue);\n                var atIndex = parseInt(key1);\n                if (this.groupColNames) {\n                    copyDf.addColumn(keyName, dfValue, { inplace: true, atIndex: atIndex });\n                }\n                else {\n                    copyDf.addColumn(keyName + \"_Group\", dfValue, { inplace: true, atIndex: atIndex });\n                }\n            }\n            data.push(copyDf);\n        }\n        return (0, concat_1.default)({ dfList: data, axis: 0 });\n    };\n    Object.defineProperty(Groupby.prototype, \"ngroups\", {\n        /**\n         * obtain the total number of groups\n         * @returns number\n         */\n        get: function () {\n            var keys = Object.keys(this.colDict);\n            return keys.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Groupby.prototype, \"groups\", {\n        /**\n         * obtaind the internal group data\n         * @returns  {[keys: string]: {}}\n         */\n        get: function () {\n            return this.colDict;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Obtain the first row of each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.first = function () {\n        return this.apply(function (x) {\n            return x.head(1);\n        });\n    };\n    /**\n     * Obtain the last row of each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.last = function () {\n        return this.apply(function (x) {\n            return x.tail(1);\n        });\n    };\n    /**\n     * Obtains the dataframe se of each groups\n     * @returns DataFrame\n     */\n    Groupby.prototype.size = function () {\n        return this.apply(function (x) {\n            return new series_1.default([x.shape[0]]);\n        });\n    };\n    Groupby.prototype.colKeyDict = function (colDict) {\n        var keyDict = {};\n        for (var _i = 0, _a = Object.keys(colDict); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var firstKey = key.split(\"-\")[0];\n            if (firstKey in keyDict) {\n                keyDict[firstKey].push(key);\n            }\n            else {\n                keyDict[firstKey] = [key];\n            }\n        }\n        var keys = [];\n        for (var _b = 0, _c = Object.keys(keyDict); _b < _c.length; _b++) {\n            var key = _c[_b];\n            keys.push.apply(keys, keyDict[key]);\n        }\n        return keys;\n    };\n    return Groupby;\n}());\nexports.default = Groupby;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}