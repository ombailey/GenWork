{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createArrayNode = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nvar createArrayNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n  }\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = (0, _array.map)(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix((0, _array.map)(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return (0, _array.map)(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  ArrayNode.prototype._toTex = function (options) {\n    function itemsToTex(items, nested) {\n      var mixedItems = items.some(_is.isArrayNode) && !items.every(_is.isArrayNode);\n      var itemsFormRow = nested || mixedItems;\n      var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n      var itemsTex = items.map(function (node) {\n        if (node.items) {\n          return itemsToTex(node.items, !nested);\n        } else {\n          return node.toTex(options);\n        }\n      }).join(itemSep);\n      return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n    }\n    return itemsToTex(this.items, false);\n  };\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createArrayNode = createArrayNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createArrayNode","_is","require","_array","_factory","name","dependencies","factory","_ref","Node","ArrayNode","items","SyntaxError","Array","isArray","every","isNode","TypeError","prototype","type","isArrayNode","_compile","math","argNames","evalItems","map","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","itemsToTex","nested","mixedItems","some","itemsFormRow","itemSep","itemsTex","toTex","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/ArrayNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createArrayNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nvar createArrayNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = (0, _array.map)(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix((0, _array.map)(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return (0, _array.map)(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    function itemsToTex(items, nested) {\n      var mixedItems = items.some(_is.isArrayNode) && !items.every(_is.isArrayNode);\n      var itemsFormRow = nested || mixedItems;\n      var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n      var itemsTex = items.map(function (node) {\n        if (node.items) {\n          return itemsToTex(node.items, !nested);\n        } else {\n          return node.toTex(options);\n        }\n      }).join(itemSep);\n      return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n    }\n\n    return itemsToTex(this.items, false);\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createArrayNode = createArrayNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}