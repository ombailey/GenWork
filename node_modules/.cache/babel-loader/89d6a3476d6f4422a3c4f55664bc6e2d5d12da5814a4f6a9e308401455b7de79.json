{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRelationalNode = void 0;\nvar _operators = require(\"../operators.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _customs = require(\"../../utils/customs.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nvar createRelationalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = (0, _customs.getSafeProperty)(math, self.conditionals[i]);\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += _latex.latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n    return ret;\n  };\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createRelationalNode = createRelationalNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createRelationalNode","_operators","require","_string","_customs","_latex","_factory","name","dependencies","factory","_ref","Node","RelationalNode","conditionals","params","SyntaxError","Array","isArray","TypeError","length","prototype","type","isRelationalNode","_compile","math","argNames","self","compiled","map","p","evalRelationalNode","scope","args","context","evalLhs","evalRhs","i","condFn","getSafeProperty","forEach","callback","_this","n","_this2","slice","_ifNode","clone","_toString","options","parenthesis","precedence","getPrecedence","paramStrings","index","paramPrecedence","toString","operatorMap","equal","unequal","smaller","larger","smallerEq","largerEq","ret","toJSON","mathjs","fromJSON","json","toHTML","escape","_toTex","toTex","latexOperators","isClass","isNode"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/RelationalNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRelationalNode = void 0;\n\nvar _operators = require(\"../operators.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nvar createRelationalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = (0, _customs.getSafeProperty)(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += _latex.latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createRelationalNode = createRelationalNode;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,oBAAoB,GAAG,KAAK,CAAC;AAErC,IAAIC,UAAU,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAE3C,IAAIC,OAAO,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAE9C,IAAIE,QAAQ,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AAEhD,IAAIG,MAAM,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAE5C,IAAII,QAAQ,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAEhD,IAAIK,IAAI,GAAG,gBAAgB;AAC3B,IAAIC,YAAY,GAAG,CAAC,MAAM,CAAC;AAC3B,IAAIR,oBAAoB,GAAG,eAAe,CAAC,CAAC,EAAEM,QAAQ,CAACG,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EAClG,IAAIC,IAAI,GAAGD,IAAI,CAACC,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,cAAc,CAACC,YAAY,EAAEC,MAAM,EAAE;IAC5C,IAAI,EAAE,IAAI,YAAYF,cAAc,CAAC,EAAE;MACrC,MAAM,IAAIG,WAAW,CAAC,kDAAkD,CAAC;IAC3E;IAEA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACJ,YAAY,CAAC,EAAE,MAAM,IAAIK,SAAS,CAAC,yCAAyC,CAAC;IAChG,IAAI,CAACF,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE,MAAM,IAAII,SAAS,CAAC,mCAAmC,CAAC;IACpF,IAAIL,YAAY,CAACM,MAAM,KAAKL,MAAM,CAACK,MAAM,GAAG,CAAC,EAAE,MAAM,IAAID,SAAS,CAAC,oFAAoF,CAAC;IACxJ,IAAI,CAACL,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,MAAM,GAAGA,MAAM;EACtB;EAEAF,cAAc,CAACQ,SAAS,GAAG,IAAIT,IAAI,EAAE;EACrCC,cAAc,CAACQ,SAAS,CAACC,IAAI,GAAG,gBAAgB;EAChDT,cAAc,CAACQ,SAAS,CAACE,gBAAgB,GAAG,IAAI;EAChD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEV,cAAc,CAACQ,SAAS,CAACG,QAAQ,GAAG,UAAUC,IAAI,EAAEC,QAAQ,EAAE;IAC5D,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,QAAQ,GAAG,IAAI,CAACb,MAAM,CAACc,GAAG,CAAC,UAAUC,CAAC,EAAE;MAC1C,OAAOA,CAAC,CAACN,QAAQ,CAACC,IAAI,EAAEC,QAAQ,CAAC;IACnC,CAAC,CAAC;IACF,OAAO,SAASK,kBAAkB,CAACC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;MACvD,IAAIC,OAAO;MACX,IAAIC,OAAO,GAAGR,QAAQ,CAAC,CAAC,CAAC,CAACI,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAE/C,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,IAAI,CAACb,YAAY,CAACM,MAAM,EAAEiB,CAAC,EAAE,EAAE;QACjDF,OAAO,GAAGC,OAAO;QACjBA,OAAO,GAAGR,QAAQ,CAACS,CAAC,GAAG,CAAC,CAAC,CAACL,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC;QAC/C,IAAII,MAAM,GAAG,CAAC,CAAC,EAAEjC,QAAQ,CAACkC,eAAe,EAAEd,IAAI,EAAEE,IAAI,CAACb,YAAY,CAACuB,CAAC,CAAC,CAAC;QAEtE,IAAI,CAACC,MAAM,CAACH,OAAO,EAAEC,OAAO,CAAC,EAAE;UAC7B,OAAO,KAAK;QACd;MACF;MAEA,OAAO,IAAI;IACb,CAAC;EACH,CAAC;EACD;AACF;AACA;AACA;;EAGEvB,cAAc,CAACQ,SAAS,CAACmB,OAAO,GAAG,UAAUC,QAAQ,EAAE;IACrD,IAAIC,KAAK,GAAG,IAAI;IAEhB,IAAI,CAAC3B,MAAM,CAACyB,OAAO,CAAC,UAAUG,CAAC,EAAEN,CAAC,EAAE;MAClC,OAAOI,QAAQ,CAACE,CAAC,EAAE,SAAS,GAAGN,CAAC,GAAG,GAAG,EAAEK,KAAK,CAAC;IAChD,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;;EAGE7B,cAAc,CAACQ,SAAS,CAACQ,GAAG,GAAG,UAAUY,QAAQ,EAAE;IACjD,IAAIG,MAAM,GAAG,IAAI;IAEjB,OAAO,IAAI/B,cAAc,CAAC,IAAI,CAACC,YAAY,CAAC+B,KAAK,EAAE,EAAE,IAAI,CAAC9B,MAAM,CAACc,GAAG,CAAC,UAAUc,CAAC,EAAEN,CAAC,EAAE;MACnF,OAAOO,MAAM,CAACE,OAAO,CAACL,QAAQ,CAACE,CAAC,EAAE,SAAS,GAAGN,CAAC,GAAG,GAAG,EAAEO,MAAM,CAAC,CAAC;IACjE,CAAC,EAAE,IAAI,CAAC,CAAC;EACX,CAAC;EACD;AACF;AACA;AACA;;EAGE/B,cAAc,CAACQ,SAAS,CAAC0B,KAAK,GAAG,YAAY;IAC3C,OAAO,IAAIlC,cAAc,CAAC,IAAI,CAACC,YAAY,EAAE,IAAI,CAACC,MAAM,CAAC;EAC3D,CAAC;EACD;AACF;AACA;AACA;AACA;;EAGEF,cAAc,CAACQ,SAAS,CAAC2B,SAAS,GAAG,UAAUC,OAAO,EAAE;IACtD,IAAIC,WAAW,GAAGD,OAAO,IAAIA,OAAO,CAACC,WAAW,GAAGD,OAAO,CAACC,WAAW,GAAG,MAAM;IAC/E,IAAIC,UAAU,GAAG,CAAC,CAAC,EAAEjD,UAAU,CAACkD,aAAa,EAAE,IAAI,EAAEF,WAAW,CAAC;IACjE,IAAIG,YAAY,GAAG,IAAI,CAACtC,MAAM,CAACc,GAAG,CAAC,UAAUC,CAAC,EAAEwB,KAAK,EAAE;MACrD,IAAIC,eAAe,GAAG,CAAC,CAAC,EAAErD,UAAU,CAACkD,aAAa,EAAEtB,CAAC,EAAEoB,WAAW,CAAC;MACnE,OAAOA,WAAW,KAAK,KAAK,IAAIK,eAAe,KAAK,IAAI,IAAIA,eAAe,IAAIJ,UAAU,GAAG,GAAG,GAAGrB,CAAC,CAAC0B,QAAQ,CAACP,OAAO,CAAC,GAAG,GAAG,GAAGnB,CAAC,CAAC0B,QAAQ,CAACP,OAAO,CAAC;IACnJ,CAAC,CAAC;IACF,IAAIQ,WAAW,GAAG;MAChBC,KAAK,EAAE,IAAI;MACXC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE,GAAG;MACZC,MAAM,EAAE,GAAG;MACXC,SAAS,EAAE,IAAI;MACfC,QAAQ,EAAE;IACZ,CAAC;IACD,IAAIC,GAAG,GAAGX,YAAY,CAAC,CAAC,CAAC;IAEzB,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvB,YAAY,CAACM,MAAM,EAAEiB,CAAC,EAAE,EAAE;MACjD2B,GAAG,IAAI,GAAG,GAAGP,WAAW,CAAC,IAAI,CAAC3C,YAAY,CAACuB,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGgB,YAAY,CAAChB,CAAC,GAAG,CAAC,CAAC;IAC5E;IAEA,OAAO2B,GAAG;EACZ,CAAC;EACD;AACF;AACA;AACA;;EAGEnD,cAAc,CAACQ,SAAS,CAAC4C,MAAM,GAAG,YAAY;IAC5C,OAAO;MACLC,MAAM,EAAE,gBAAgB;MACxBpD,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BC,MAAM,EAAE,IAAI,CAACA;IACf,CAAC;EACH,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;EAGEF,cAAc,CAACsD,QAAQ,GAAG,UAAUC,IAAI,EAAE;IACxC,OAAO,IAAIvD,cAAc,CAACuD,IAAI,CAACtD,YAAY,EAAEsD,IAAI,CAACrD,MAAM,CAAC;EAC3D,CAAC;EACD;AACF;AACA;AACA;AACA;;EAGEF,cAAc,CAACQ,SAAS,CAACgD,MAAM,GAAG,UAAUpB,OAAO,EAAE;IACnD,IAAIC,WAAW,GAAGD,OAAO,IAAIA,OAAO,CAACC,WAAW,GAAGD,OAAO,CAACC,WAAW,GAAG,MAAM;IAC/E,IAAIC,UAAU,GAAG,CAAC,CAAC,EAAEjD,UAAU,CAACkD,aAAa,EAAE,IAAI,EAAEF,WAAW,CAAC;IACjE,IAAIG,YAAY,GAAG,IAAI,CAACtC,MAAM,CAACc,GAAG,CAAC,UAAUC,CAAC,EAAEwB,KAAK,EAAE;MACrD,IAAIC,eAAe,GAAG,CAAC,CAAC,EAAErD,UAAU,CAACkD,aAAa,EAAEtB,CAAC,EAAEoB,WAAW,CAAC;MACnE,OAAOA,WAAW,KAAK,KAAK,IAAIK,eAAe,KAAK,IAAI,IAAIA,eAAe,IAAIJ,UAAU,GAAG,gEAAgE,GAAGrB,CAAC,CAACuC,MAAM,CAACpB,OAAO,CAAC,GAAG,gEAAgE,GAAGnB,CAAC,CAACuC,MAAM,CAACpB,OAAO,CAAC;IACzQ,CAAC,CAAC;IACF,IAAIQ,WAAW,GAAG;MAChBC,KAAK,EAAE,IAAI;MACXC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE,GAAG;MACZC,MAAM,EAAE,GAAG;MACXC,SAAS,EAAE,IAAI;MACfC,QAAQ,EAAE;IACZ,CAAC;IACD,IAAIC,GAAG,GAAGX,YAAY,CAAC,CAAC,CAAC;IAEzB,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvB,YAAY,CAACM,MAAM,EAAEiB,CAAC,EAAE,EAAE;MACjD2B,GAAG,IAAI,iFAAiF,GAAG,CAAC,CAAC,EAAE5D,OAAO,CAACkE,MAAM,EAAEb,WAAW,CAAC,IAAI,CAAC3C,YAAY,CAACuB,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,GAAGgB,YAAY,CAAChB,CAAC,GAAG,CAAC,CAAC;IACrL;IAEA,OAAO2B,GAAG;EACZ,CAAC;EACD;AACF;AACA;AACA;AACA;;EAGEnD,cAAc,CAACQ,SAAS,CAACkD,MAAM,GAAG,UAAUtB,OAAO,EAAE;IACnD,IAAIC,WAAW,GAAGD,OAAO,IAAIA,OAAO,CAACC,WAAW,GAAGD,OAAO,CAACC,WAAW,GAAG,MAAM;IAC/E,IAAIC,UAAU,GAAG,CAAC,CAAC,EAAEjD,UAAU,CAACkD,aAAa,EAAE,IAAI,EAAEF,WAAW,CAAC;IACjE,IAAIG,YAAY,GAAG,IAAI,CAACtC,MAAM,CAACc,GAAG,CAAC,UAAUC,CAAC,EAAEwB,KAAK,EAAE;MACrD,IAAIC,eAAe,GAAG,CAAC,CAAC,EAAErD,UAAU,CAACkD,aAAa,EAAEtB,CAAC,EAAEoB,WAAW,CAAC;MACnE,OAAOA,WAAW,KAAK,KAAK,IAAIK,eAAe,KAAK,IAAI,IAAIA,eAAe,IAAIJ,UAAU,GAAG,SAAS,GAAGrB,CAAC,CAAC0C,KAAK,CAACvB,OAAO,CAAC,GAAG,SAAS,GAAGnB,CAAC,CAAC0C,KAAK,CAACvB,OAAO,CAAC;IACzJ,CAAC,CAAC;IACF,IAAIe,GAAG,GAAGX,YAAY,CAAC,CAAC,CAAC;IAEzB,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvB,YAAY,CAACM,MAAM,EAAEiB,CAAC,EAAE,EAAE;MACjD2B,GAAG,IAAI1D,MAAM,CAACmE,cAAc,CAAC,IAAI,CAAC3D,YAAY,CAACuB,CAAC,CAAC,CAAC,GAAGgB,YAAY,CAAChB,CAAC,GAAG,CAAC,CAAC;IAC1E;IAEA,OAAO2B,GAAG;EACZ,CAAC;EAED,OAAOnD,cAAc;AACvB,CAAC,EAAE;EACD6D,OAAO,EAAE,IAAI;EACbC,MAAM,EAAE;AACV,CAAC,CAAC;AACF5E,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB"},"metadata":{},"sourceType":"script","externalDependencies":[]}