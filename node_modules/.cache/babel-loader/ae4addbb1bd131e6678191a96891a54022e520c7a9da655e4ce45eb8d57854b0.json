{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionNode = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _is = require(\"../../utils/is.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _customs = require(\"../../utils/customs.js\");\nvar _scope = require(\"../../utils/scope.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nvar createFunctionNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var math = _ref.math,\n    Node = _ref.Node,\n    SymbolNode = _ref.SymbolNode;\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n    if (!(0, _is.isNode)(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n    var evalArgs = this.args.map(function (arg) {\n      return arg._compile(math, argNames);\n    });\n    if ((0, _is.isSymbolNode)(this.fn)) {\n      // we can statically determine whether the function has an rawArgs property\n      var _name = this.fn.name;\n      var fn = _name in math ? (0, _customs.getSafeProperty)(math, _name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n      var resolveFn = function resolveFn(scope) {\n        if (scope.has(_name)) {\n          return scope.get(_name);\n        }\n        if (_name in math) {\n          return (0, _customs.getSafeProperty)(math, _name);\n        }\n        return FunctionNode.onUndefinedFunction(_name);\n      };\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          var fn = resolveFn(scope);\n          return fn(rawArgs, math, (0, _scope.createSubScope)(scope, args), scope);\n        };\n      } else {\n        // \"regular\" evaluation\n        switch (evalArgs.length) {\n          case 0:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              return fn();\n            };\n          case 1:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              var evalArg0 = evalArgs[0];\n              return fn(evalArg0(scope, args, context));\n            };\n          case 2:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              var evalArg0 = evalArgs[0];\n              var evalArg1 = evalArgs[1];\n              return fn(evalArg0(scope, args, context), evalArg1(scope, args, context));\n            };\n          default:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              var values = evalArgs.map(function (evalArg) {\n                return evalArg(scope, args, context);\n              });\n              return fn.apply(void 0, (0, _toConsumableArray2[\"default\"])(values));\n            };\n        }\n      }\n    } else if ((0, _is.isAccessorNode)(this.fn) && (0, _is.isIndexNode)(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        (0, _customs.validateSafeMethod)(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n        if (isRaw) {\n          return object[prop](_rawArgs, math, (0, _scope.createSubScope)(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(function (evalArg) {\n            return evalArg(scope, args, context);\n          });\n          return object[prop].apply(object, values);\n        }\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n        if (isRaw) {\n          return fn(_rawArgs2, math, (0, _scope.createSubScope)(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(function (evalArg) {\n            return evalArg(scope, args, context);\n          });\n          return fn.apply(fn, values);\n        }\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n    var args = [];\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n  /**\n   * Throws an error 'Undefined function {name}'\n   * @param {string} name\n   */\n\n  FunctionNode.onUndefinedFunction = function (name) {\n    throw new Error('Undefined function ' + name);\n  }; // backup Node's toString function\n  // @private\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n    if (options && (0, _typeof2[\"default\"])(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = (0, _is.isFunctionAssignmentNode)(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = /\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi;\n    var inputPos = 0; // position in the input string\n\n    var match;\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n        if (match[2] === undefined) {\n          // no square brackets\n          switch ((0, _typeof2[\"default\"])(property)) {\n            case 'string':\n              latex += property;\n              break;\n            case 'object':\n              if ((0, _is.isNode)(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if ((0, _is.isNode)(arg)) {\n                    return arg.toTex(options);\n                  }\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n              break;\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if ((0, _is.isNode)(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n    if (options && (0, _typeof2[\"default\"])(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n    if (_latex.latexFunctions[this.name]) {\n      latexConverter = _latex.latexFunctions[this.name];\n    } // toTex property on the function itself\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || (0, _typeof2[\"default\"])(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n    var customToTex;\n    switch ((0, _typeof2[\"default\"])(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch ((0, _typeof2[\"default\"])(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n    }\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n    return expandTemplate(_latex.defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionNode = createFunctionNode;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createFunctionNode","_typeof2","_toConsumableArray2","_is","_string","_object","_customs","_scope","_factory","_latex","name","dependencies","factory","_ref","math","Node","SymbolNode","FunctionNode","fn","args","SyntaxError","isNode","TypeError","Array","isArray","every","get","bind","set","Error","prototype","type","isFunctionNode","_compile","argNames","evalArgs","map","arg","isSymbolNode","_name","getSafeProperty","undefined","isRaw","rawArgs","resolveFn","scope","has","onUndefinedFunction","evalFunctionNode","context","createSubScope","length","evalArg0","evalArg1","values","evalArg","apply","isAccessorNode","isIndexNode","index","isObjectProperty","evalObject","object","prop","getObjectProperty","_rawArgs","validateSafeMethod","evalFn","_rawArgs2","forEach","callback","i","_ifNode","clone","slice","nodeToString","toString","options","customString","handler","hasOwnProperty","call","_toString","isFunctionAssignmentNode","join","toJSON","mathjs","fromJSON","json","toHTML","escape","expandTemplate","template","node","latex","regex","inputPos","match","exec","substring","property","ReferenceError","toTex","nodeToTex","customTex","_toTex","latexConverter","latexFunctions","customToTex","defaultTemplate","getIdentifier","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/FunctionNode.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionNode = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _scope = require(\"../../utils/scope.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nvar createFunctionNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Node = _ref.Node,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!(0, _is.isNode)(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = this.args.map(function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if ((0, _is.isSymbolNode)(this.fn)) {\n      // we can statically determine whether the function has an rawArgs property\n      var _name = this.fn.name;\n      var fn = _name in math ? (0, _customs.getSafeProperty)(math, _name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n      var resolveFn = function resolveFn(scope) {\n        if (scope.has(_name)) {\n          return scope.get(_name);\n        }\n\n        if (_name in math) {\n          return (0, _customs.getSafeProperty)(math, _name);\n        }\n\n        return FunctionNode.onUndefinedFunction(_name);\n      };\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          var fn = resolveFn(scope);\n          return fn(rawArgs, math, (0, _scope.createSubScope)(scope, args), scope);\n        };\n      } else {\n        // \"regular\" evaluation\n        switch (evalArgs.length) {\n          case 0:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              return fn();\n            };\n\n          case 1:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              var evalArg0 = evalArgs[0];\n              return fn(evalArg0(scope, args, context));\n            };\n\n          case 2:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              var evalArg0 = evalArgs[0];\n              var evalArg1 = evalArgs[1];\n              return fn(evalArg0(scope, args, context), evalArg1(scope, args, context));\n            };\n\n          default:\n            return function evalFunctionNode(scope, args, context) {\n              var fn = resolveFn(scope);\n              var values = evalArgs.map(function (evalArg) {\n                return evalArg(scope, args, context);\n              });\n              return fn.apply(void 0, (0, _toConsumableArray2[\"default\"])(values));\n            };\n        }\n      }\n    } else if ((0, _is.isAccessorNode)(this.fn) && (0, _is.isIndexNode)(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        (0, _customs.validateSafeMethod)(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n\n        if (isRaw) {\n          return object[prop](_rawArgs, math, (0, _scope.createSubScope)(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(function (evalArg) {\n            return evalArg(scope, args, context);\n          });\n          return object[prop].apply(object, values);\n        }\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n\n        if (isRaw) {\n          return fn(_rawArgs2, math, (0, _scope.createSubScope)(scope, args), scope); // \"raw\" evaluation\n        } else {\n          // \"regular\" evaluation\n          var values = evalArgs.map(function (evalArg) {\n            return evalArg(scope, args, context);\n          });\n          return fn.apply(fn, values);\n        }\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n  /**\n   * Throws an error 'Undefined function {name}'\n   * @param {string} name\n   */\n\n\n  FunctionNode.onUndefinedFunction = function (name) {\n    throw new Error('Undefined function ' + name);\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && (0, _typeof2[\"default\"])(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = (0, _is.isFunctionAssignmentNode)(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = /\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi;\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch ((0, _typeof2[\"default\"])(property)) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if ((0, _is.isNode)(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if ((0, _is.isNode)(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if ((0, _is.isNode)(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && (0, _typeof2[\"default\"])(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (_latex.latexFunctions[this.name]) {\n      latexConverter = _latex.latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || (0, _typeof2[\"default\"])(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch ((0, _typeof2[\"default\"])(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch ((0, _typeof2[\"default\"])(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(_latex.defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionNode = createFunctionNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}