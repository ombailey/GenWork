{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionAssignmentNode = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _keywords = require(\"../keywords.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _operators = require(\"../operators.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nvar createFunctionAssignmentNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    Node = _ref.Node;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!(0, _is.isNode)(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (_keywords.keywords.has(name)) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    (0, _array.forEach)(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n    var name = this.name;\n    var params = this.params;\n    var signature = (0, _array.join)(this.types, ',');\n    var syntax = name + '(' + (0, _array.join)(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n        return evalExpr(scope, childArgs, context);\n      };\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      scope.set(name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\n    var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + (0, _string.escape)(this.params[i]) + '</span>');\n    }\n    var expr = this.expr.toHTML(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(_latex.toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionAssignmentNode = createFunctionAssignmentNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createFunctionAssignmentNode","_is","require","_keywords","_string","_array","_latex","_operators","_factory","name","dependencies","factory","_ref","typed","Node","FunctionAssignmentNode","params","expr","SyntaxError","TypeError","Array","isArray","isNode","keywords","has","Error","map","param","types","type","prototype","isFunctionAssignmentNode","_compile","math","argNames","childArgNames","create","forEach","evalExpr","signature","join","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","set","callback","_ifNode","slice","clone","needParenthesis","node","parenthesis","precedence","getPrecedence","exprPrecedence","_toString","options","toString","toJSON","mathjs","index","fromJSON","json","toHTML","push","escape","_toTex","toTex","concat","toSymbol","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/expression/node/FunctionAssignmentNode.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionAssignmentNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _keywords = require(\"../keywords.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nvar createFunctionAssignmentNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      Node = _ref.Node;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!(0, _is.isNode)(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (_keywords.keywords.has(name)) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    (0, _array.forEach)(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = (0, _array.join)(this.types, ',');\n    var syntax = name + '(' + (0, _array.join)(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      scope.set(name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\n    var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + (0, _string.escape)(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(_latex.toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionAssignmentNode = createFunctionAssignmentNode;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}