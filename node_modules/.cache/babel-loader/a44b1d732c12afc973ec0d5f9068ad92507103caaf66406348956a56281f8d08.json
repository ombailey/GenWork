{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factory = factory;\nexports.sortFactories = sortFactories;\nexports.create = create;\nexports.isFactory = isFactory;\nexports.assertDependencies = assertDependencies;\nexports.isOptionalDependency = isOptionalDependency;\nexports.stripOptionalNotation = stripOptionalNotation;\nvar _array = require(\"./array.js\");\nvar _object = require(\"./object.js\");\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\nfunction factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = (0, _object.pickShallow)(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nfunction sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if ((0, _array.contains)(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nfunction create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nfunction isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nfunction assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nfunction isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nfunction stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","factory","sortFactories","create","isFactory","assertDependencies","isOptionalDependency","stripOptionalNotation","_array","require","_object","name","dependencies","meta","assertAndCreate","scope","deps","pickShallow","map","fn","slice","sort","factories","factoriesByName","forEach","containsDependency","dependency","contains","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","every","missingDependencies","Error","concat","join"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/utils/factory.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factory = factory;\nexports.sortFactories = sortFactories;\nexports.create = create;\nexports.isFactory = isFactory;\nexports.assertDependencies = assertDependencies;\nexports.isOptionalDependency = isOptionalDependency;\nexports.stripOptionalNotation = stripOptionalNotation;\n\nvar _array = require(\"./array.js\");\n\nvar _object = require(\"./object.js\");\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\nfunction factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = (0, _object.pickShallow)(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\n\nfunction sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if ((0, _array.contains)(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\n\nfunction create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\n\nfunction isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\n\nfunction assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\n\nfunction isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\n\nfunction stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}