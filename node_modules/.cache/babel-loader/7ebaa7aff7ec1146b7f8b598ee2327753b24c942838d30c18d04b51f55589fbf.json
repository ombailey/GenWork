{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComplexEigs = createComplexEigs;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _object = require(\"../../../utils/object.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction createComplexEigs(_ref) {\n  var addScalar = _ref.addScalar,\n    subtract = _ref.subtract,\n    flatten = _ref.flatten,\n    multiply = _ref.multiply,\n    multiplyScalar = _ref.multiplyScalar,\n    divideScalar = _ref.divideScalar,\n    sqrt = _ref.sqrt,\n    abs = _ref.abs,\n    bignumber = _ref.bignumber,\n    diag = _ref.diag,\n    inv = _ref.inv,\n    qr = _ref.qr,\n    usolve = _ref.usolve,\n    usolveAll = _ref.usolveAll,\n    equal = _ref.equal,\n    complex = _ref.complex,\n    larger = _ref.larger,\n    smaller = _ref.smaller,\n    matrixFromColumns = _ref.matrixFromColumns,\n    dot = _ref.dot;\n\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    } // TODO check if any row/col are zero except the diagonal\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n\n    var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix\n    // A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n\n    reduceToHessenberg(arr, N, prec, type, findVectors, R); // find eigenvalues\n\n    var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors),\n      values = _iterateUntilTriangul.values,\n      C = _iterateUntilTriangul.C; // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms the hessenberg\n    // matrix to upper triangular\n    // compose transformations A → hess. and hess. → triang.\n\n    C = multiply(inv(R), C);\n    var vectors;\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, values, prec, type);\n      vectors = matrixFromColumns.apply(void 0, (0, _toConsumableArray2[\"default\"])(vectors));\n    }\n    return {\n      values: values,\n      vectors: vectors\n    };\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // base of the floating-point arithmetic\n\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R\n\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    } // this isn't the only time we loop thru the matrix...\n\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = zero;\n        var rowNorm = zero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]);\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n          var f = one;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          } // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation\n\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            } // keep track of transformations\n\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    } // return the diagonal row transformation matrix\n\n    return diag(Rdiag);\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      } // This col is pivoted, no need to do anything\n\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column\n\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        } // keep track of transformations\n\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      } // Reduce following rows and columns\n\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        } // from j-th row subtract n-times (i+1)th row\n\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        } // to (i+1)th column add n-times j-th column\n\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        } // keep track of transformations\n\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    } // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = (0, _object.clone)(A); // the list of converged eigenvalues\n\n    var lambdas = []; // size of arr, which will get smaller as eigenvalues converge\n\n    var n = N; // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n\n    var Sdiag = []; // N×N matrix describing the overall transformation done during the QR algorithm\n\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // n×n matrix describing the QR transformations done since last convergence\n\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps\n\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      } // TODO do an implicit QR transformation\n\n      var _qr = qr(arr),\n        Q = _qr.Q,\n        R = _qr.R;\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      } // keep track of transformations\n\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      } // The rightmost diagonal element converged to an eigenvalue\n\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        } // reduce the matrix size\n\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        } // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push.apply(lambdas, (0, _toConsumableArray2[\"default\"])(ll)); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        } // reduce the matrix size\n\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    } // standard sorting\n\n    lambdas.sort(function (a, b) {\n      return +subtract(abs(a), abs(b));\n    }); // the algorithm didn't converge\n\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    } // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C: C\n    };\n  }\n  /**\n   * @param {Matrix} A original matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n\n  function findEigenvectors(A, N, C, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n\n    var uniqueValues = [];\n    var multiplicities = [];\n    var _iterator = _createForOfIteratorHelper(values),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _λ = _step.value;\n        var _i4 = indexOf(uniqueValues, _λ, equal);\n        if (_i4 === -1) {\n          uniqueValues.push(_λ);\n          multiplicities.push(1);\n        } else {\n          multiplicities[_i4] += 1;\n        }\n      } // find eigenvectors by solving U − λE = 0\n      // TODO replace with an iterative eigenvector algorithm\n      // (this one might fail for imprecise eigenvalues)\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)\n\n    var failedLambdas = [];\n    for (var i = 0; i < len; i++) {\n      var λ = uniqueValues[i];\n      var _A = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n      var solutions = usolveAll(_A, b);\n      solutions = solutions.map(function (v) {\n        return multiply(C, v);\n      });\n      solutions.shift(); // ignore the null vector\n      // looks like we missed something, try inverse iteration\n\n      while (solutions.length < multiplicities[i]) {\n        var approxVec = inverseIterate(_A, N, solutions, prec, type);\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n        solutions.push(approxVec);\n      }\n      vectors.push.apply(vectors, (0, _toConsumableArray2[\"default\"])(solutions.map(function (v) {\n        return flatten(v);\n      })));\n    }\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n    return vectors;\n  }\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS⁻¹ is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular\n    // return an identity matrix\n\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    } // matrix is diagonalizable\n    // return its eigenvectors as columns\n\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    } // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n  /**\n   * Enlarge the matrix from n×n to N×N, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      var _arr$i;\n      (_arr$i = arr[i]).push.apply(_arr$i, (0, _toConsumableArray2[\"default\"])(Array(N - arr[i].length).fill(0)));\n    } // add rows\n\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    var _iterator2 = _createForOfIteratorHelper(arr),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var n = sub.length;\n        for (var _i6 = 0; _i6 < n; _i6++) {\n          for (var j = 0; j < n; j++) {\n            M[I + _i6][I + j] = sub[_i6][j];\n          }\n        }\n        I += n;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return M;\n  }\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n    // you better choose a random vector before I count to five\n\n    var i = 0;\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n      if (++i >= 5) {\n        return null;\n      }\n    } // you better converge before I count to ten\n\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex'; // generate random vector with the correct type\n\n    var v = Array(N).fill(0).map(function (_) {\n      return 2 * Math.random() - 1;\n    });\n    if (big) {\n      v = v.map(function (n) {\n        return bignumber(n);\n      });\n    }\n    if (cplx) {\n      v = v.map(function (n) {\n        return complex(n);\n      });\n    } // project to orthogonal complement\n\n    v = orthogonalComplement(v, orthog); // normalize\n\n    return normalize(v, type);\n  }\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n\n  function orthogonalComplement(v, orthog) {\n    var _iterator3 = _createForOfIteratorHelper(orthog),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var w = _step3.value;\n        // v := v − (w, v)/∥w∥² w\n        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return v;\n  }\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createComplexEigs","_toConsumableArray2","_object","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","_ref","addScalar","subtract","flatten","multiply","multiplyScalar","divideScalar","sqrt","abs","bignumber","diag","inv","qr","usolve","usolveAll","equal","complex","larger","smaller","matrixFromColumns","dot","complexEigs","N","prec","type","findVectors","undefined","R","balance","reduceToHessenberg","_iterateUntilTriangul","iterateUntilTriangular","values","C","vectors","findEigenvectors","apply","big","cplx","zero","one","radix","radixSq","Rdiag","fill","last","colNorm","rowNorm","j","c","_c","rowDivRadix","rowMulRadix","condition","g","_j","maxIndex","max","el","tmp1","_j2","tmp2","tmp3","_j3","k","_k","_k2","A","clone","lambdas","Sdiag","Qtotal","Qpartial","lastConvergenceBefore","_qr","Q","_i","push","unshift","inflateMatrix","pop","_i2","ll","eigenvalues2x2","jordanBase2x2","_i3","sort","a","b","Error","join","blockDiag","Cinv","U","uniqueValues","multiplicities","_iterator","_step","_λ","_i4","indexOf","E","failedLambdas","λ","_A","solutions","map","v","shift","approxVec","inverseIterate","d","trA","detA","x","y","l1","l2","na","nb","nc","nd","_arr$i","_i5","M","I","_iterator2","_step2","sub","_i6","fn","orthog","largeNum","randomOrthogonalVector","norm","orthogonalComplement","normalize","_","Math","random","_iterator3","_step3","w"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/matrix/eigs/complexEigs.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComplexEigs = createComplexEigs;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _object = require(\"../../../utils/object.js\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction createComplexEigs(_ref) {\n  var addScalar = _ref.addScalar,\n      subtract = _ref.subtract,\n      flatten = _ref.flatten,\n      multiply = _ref.multiply,\n      multiplyScalar = _ref.multiplyScalar,\n      divideScalar = _ref.divideScalar,\n      sqrt = _ref.sqrt,\n      abs = _ref.abs,\n      bignumber = _ref.bignumber,\n      diag = _ref.diag,\n      inv = _ref.inv,\n      qr = _ref.qr,\n      usolve = _ref.usolve,\n      usolveAll = _ref.usolveAll,\n      equal = _ref.equal,\n      complex = _ref.complex,\n      larger = _ref.larger,\n      smaller = _ref.smaller,\n      matrixFromColumns = _ref.matrixFromColumns,\n      dot = _ref.dot;\n\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    } // TODO check if any row/col are zero except the diagonal\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n\n\n    var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix\n    // A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n\n    reduceToHessenberg(arr, N, prec, type, findVectors, R); // find eigenvalues\n\n    var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors),\n        values = _iterateUntilTriangul.values,\n        C = _iterateUntilTriangul.C; // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms the hessenberg\n    // matrix to upper triangular\n    // compose transformations A → hess. and hess. → triang.\n\n\n    C = multiply(inv(R), C);\n    var vectors;\n\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, values, prec, type);\n      vectors = matrixFromColumns.apply(void 0, (0, _toConsumableArray2[\"default\"])(vectors));\n    }\n\n    return {\n      values: values,\n      vectors: vectors\n    };\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n\n\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // base of the floating-point arithmetic\n\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R\n\n    var Rdiag;\n\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    } // this isn't the only time we loop thru the matrix...\n\n\n    var last = false;\n\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = zero;\n        var rowNorm = zero;\n\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]);\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n          var f = one;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          } // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n\n\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation\n\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            } // keep track of transformations\n\n\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    } // return the diagonal row transformation matrix\n\n\n    return diag(Rdiag);\n  }\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n\n\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n      var maxIndex = 0;\n      var max = zero;\n\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      } // This col is pivoted, no need to do anything\n\n\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column\n\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        } // keep track of transformations\n\n\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      } // Reduce following rows and columns\n\n\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n\n        if (n === 0) {\n          continue;\n        } // from j-th row subtract n-times (i+1)th row\n\n\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        } // to (i+1)th column add n-times j-th column\n\n\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        } // keep track of transformations\n\n\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n\n    return R;\n  }\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n\n\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    if (big) {\n      prec = bignumber(prec);\n    } // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n\n    var arr = (0, _object.clone)(A); // the list of converged eigenvalues\n\n    var lambdas = []; // size of arr, which will get smaller as eigenvalues converge\n\n    var n = N; // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n\n    var Sdiag = []; // N×N matrix describing the overall transformation done during the QR algorithm\n\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // n×n matrix describing the QR transformations done since last convergence\n\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps\n\n    var lastConvergenceBefore = 0;\n\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      } // TODO do an implicit QR transformation\n\n\n      var _qr = qr(arr),\n          Q = _qr.Q,\n          R = _qr.R;\n\n      arr = multiply(R, Q);\n\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      } // keep track of transformations\n\n\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      } // The rightmost diagonal element converged to an eigenvalue\n\n\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        } // reduce the matrix size\n\n\n        n -= 1;\n        arr.pop();\n\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        } // The rightmost diagonal 2x2 block converged\n\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push.apply(lambdas, (0, _toConsumableArray2[\"default\"])(ll)); // keep track of transformations\n\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        } // reduce the matrix size\n\n\n        n -= 2;\n        arr.pop();\n        arr.pop();\n\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n\n          arr[_i3].pop();\n        }\n      }\n\n      if (n === 0) {\n        break;\n      }\n    } // standard sorting\n\n\n    lambdas.sort(function (a, b) {\n      return +subtract(abs(a), abs(b));\n    }); // the algorithm didn't converge\n\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    } // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n\n\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C: C\n    };\n  }\n  /**\n   * @param {Matrix} A original matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n\n\n  function findEigenvectors(A, N, C, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n\n    var uniqueValues = [];\n    var multiplicities = [];\n\n    var _iterator = _createForOfIteratorHelper(values),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _λ = _step.value;\n\n        var _i4 = indexOf(uniqueValues, _λ, equal);\n\n        if (_i4 === -1) {\n          uniqueValues.push(_λ);\n          multiplicities.push(1);\n        } else {\n          multiplicities[_i4] += 1;\n        }\n      } // find eigenvectors by solving U − λE = 0\n      // TODO replace with an iterative eigenvector algorithm\n      // (this one might fail for imprecise eigenvalues)\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)\n\n    var failedLambdas = [];\n\n    for (var i = 0; i < len; i++) {\n      var λ = uniqueValues[i];\n\n      var _A = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n\n      var solutions = usolveAll(_A, b);\n      solutions = solutions.map(function (v) {\n        return multiply(C, v);\n      });\n      solutions.shift(); // ignore the null vector\n      // looks like we missed something, try inverse iteration\n\n      while (solutions.length < multiplicities[i]) {\n        var approxVec = inverseIterate(_A, N, solutions, prec, type);\n\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n\n        solutions.push(approxVec);\n      }\n\n      vectors.push.apply(vectors, (0, _toConsumableArray2[\"default\"])(solutions.map(function (v) {\n        return flatten(v);\n      })));\n    }\n\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n\n    return vectors;\n  }\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n\n\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS⁻¹ is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n\n\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular\n    // return an identity matrix\n\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    } // matrix is diagonalizable\n    // return its eigenvectors as columns\n\n\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    } // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n  /**\n   * Enlarge the matrix from n×n to N×N, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n\n\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      var _arr$i;\n\n      (_arr$i = arr[i]).push.apply(_arr$i, (0, _toConsumableArray2[\"default\"])(Array(N - arr[i].length).fill(0)));\n    } // add rows\n\n\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n\n    return arr;\n  }\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n\n\n  function blockDiag(arr, N) {\n    var M = [];\n\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n\n    var I = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(arr),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var n = sub.length;\n\n        for (var _i6 = 0; _i6 < n; _i6++) {\n          for (var j = 0; j < n; j++) {\n            M[I + _i6][I + j] = sub[_i6][j];\n          }\n        }\n\n        I += n;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return M;\n  }\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n\n\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n\n\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n    // you better choose a random vector before I count to five\n\n    var i = 0;\n\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n\n      if (++i >= 5) {\n        return null;\n      }\n    } // you better converge before I count to ten\n\n\n    i = 0;\n\n    while (true) {\n      var c = usolve(A, b);\n\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n\n      if (++i >= 10) {\n        return null;\n      }\n\n      b = normalize(c);\n    }\n\n    return b;\n  }\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n\n\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex'; // generate random vector with the correct type\n\n    var v = Array(N).fill(0).map(function (_) {\n      return 2 * Math.random() - 1;\n    });\n\n    if (big) {\n      v = v.map(function (n) {\n        return bignumber(n);\n      });\n    }\n\n    if (cplx) {\n      v = v.map(function (n) {\n        return complex(n);\n      });\n    } // project to orthogonal complement\n\n\n    v = orthogonalComplement(v, orthog); // normalize\n\n    return normalize(v, type);\n  }\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n\n\n  function orthogonalComplement(v, orthog) {\n    var _iterator3 = _createForOfIteratorHelper(orthog),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var w = _step3.value;\n        // v := v − (w, v)/∥w∥² w\n        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return v;\n  }\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n\n\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n\n\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n\n  return complexEigs;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}