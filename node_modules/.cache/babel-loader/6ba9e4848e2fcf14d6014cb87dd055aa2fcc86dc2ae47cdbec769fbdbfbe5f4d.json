{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQuantileSeq = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare'];\nvar createQuantileSeq = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    add = _ref.add,\n    multiply = _ref.multiply,\n    partitionSelect = _ref.partitionSelect,\n    compare = _ref.compare;\n\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a (multi dimensional) array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n    if ((0, _is.isCollection)(data)) {\n      sorted = sorted || false;\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n        if ((0, _is.isNumber)(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!(0, _number.isInteger)(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n            return probArr;\n          }\n        }\n        if ((0, _is.isBigNumber)(probOrN)) {\n          var BigNumber = probOrN.constructor;\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n          one = new BigNumber(1);\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            } // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n\n            var intN = probOrN.toNumber();\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n            var _nPlusOne = new BigNumber(intN + 1);\n            probArr = new Array(intN);\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n            return probArr;\n          }\n        }\n        if (Array.isArray(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          probArr = new Array(probOrN.length);\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrN[_i2];\n            if ((0, _is.isNumber)(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if ((0, _is.isBigNumber)(currProb)) {\n              one = new currProb.constructor(1);\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n          return probArr;\n        }\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n  function _quantileSeq(array, prob, sorted) {\n    var flat = (0, _array.flatten)(array);\n    var len = flat.length;\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n    if ((0, _is.isNumber)(prob)) {\n      var _index = prob * (len - 1);\n      var _fracPart = _index % 1;\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n      var _integerPart = Math.floor(_index);\n      var _left;\n      var _right;\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\n\n        _left = flat[_integerPart];\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n      validate(_left);\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    } // If prob is a BigNumber\n\n    var index = prob.times(len - 1);\n    if (index.isInteger()) {\n      index = index.toNumber();\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n      validate(_value);\n      return _value;\n    }\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\n\n      left = flat[integerPartNumber];\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n    validate(left);\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return quantileSeq;\n});\nexports.createQuantileSeq = createQuantileSeq;","map":{"version":3,"names":["Object","defineProperty","exports","value","createQuantileSeq","_is","require","_number","_array","_factory","name","dependencies","factory","_ref","typed","add","multiply","partitionSelect","compare","quantileSeq","data","probOrN","sorted","probArr","dataArr","one","arguments","length","SyntaxError","isCollection","valueOf","isNumber","Error","_quantileSeq","isInteger","nPlusOne","Array","i","isBigNumber","BigNumber","constructor","isNegative","lte","gt","intN","toNumber","_nPlusOne","_i","div","isArray","_i2","currProb","TypeError","array","prob","flat","flatten","len","_index","_fracPart","validate","_integerPart","Math","floor","_left","_right","index","times","_value","integerPart","fracPart","minus","integerPartNumber","left","right","_i3","numberBigNumberUnit","x"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/statistics/quantileSeq.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQuantileSeq = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare'];\nvar createQuantileSeq = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      partitionSelect = _ref.partitionSelect,\n      compare = _ref.compare;\n\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a (multi dimensional) array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n\n    if ((0, _is.isCollection)(data)) {\n      sorted = sorted || false;\n\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n\n        if ((0, _is.isNumber)(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!(0, _number.isInteger)(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n\n            return probArr;\n          }\n        }\n\n        if ((0, _is.isBigNumber)(probOrN)) {\n          var BigNumber = probOrN.constructor;\n\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          one = new BigNumber(1);\n\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            } // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n\n\n            var intN = probOrN.toNumber();\n\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n\n            var _nPlusOne = new BigNumber(intN + 1);\n\n            probArr = new Array(intN);\n\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n\n            return probArr;\n          }\n        }\n\n        if (Array.isArray(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          probArr = new Array(probOrN.length);\n\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrN[_i2];\n\n            if ((0, _is.isNumber)(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if ((0, _is.isBigNumber)(currProb)) {\n              one = new currProb.constructor(1);\n\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n\n          return probArr;\n        }\n\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n\n  function _quantileSeq(array, prob, sorted) {\n    var flat = (0, _array.flatten)(array);\n    var len = flat.length;\n\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n\n    if ((0, _is.isNumber)(prob)) {\n      var _index = prob * (len - 1);\n\n      var _fracPart = _index % 1;\n\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n\n      var _integerPart = Math.floor(_index);\n\n      var _left;\n\n      var _right;\n\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\n\n        _left = flat[_integerPart];\n\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n\n      validate(_left);\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    } // If prob is a BigNumber\n\n\n    var index = prob.times(len - 1);\n\n    if (index.isInteger()) {\n      index = index.toNumber();\n\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n\n      validate(_value);\n      return _value;\n    }\n\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\n\n      left = flat[integerPartNumber];\n\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n\n    validate(left);\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n\n\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return quantileSeq;\n});\nexports.createQuantileSeq = createQuantileSeq;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}