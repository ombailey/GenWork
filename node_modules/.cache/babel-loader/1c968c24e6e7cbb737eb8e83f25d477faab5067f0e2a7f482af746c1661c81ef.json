{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSpaClass = void 0;\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'Spa';\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\nvar createSpaClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var addScalar = _ref.addScalar,\n    equalScalar = _ref.equalScalar,\n    FibonacciHeap = _ref.FibonacciHeap;\n\n  /**\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\n   * of the vector elements and an ordered list of non-zero elements.\n   */\n  function Spa() {\n    if (!(this instanceof Spa)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // allocate vector, TODO use typed arrays\n\n    this._values = [];\n    this._heap = new FibonacciHeap();\n  }\n  /**\n   * Attach type information\n   */\n\n  Spa.prototype.type = 'Spa';\n  Spa.prototype.isSpa = true;\n  /**\n   * Set the value for index i.\n   *\n   * @param {number} i                       The index\n   * @param {number | BigNumber | Complex}   The value at index i\n   */\n\n  Spa.prototype.set = function (i, v) {\n    // check we have a value @ i\n    if (!this._values[i]) {\n      // insert in heap\n      var node = this._heap.insert(i, v); // set the value @ i\n\n      this._values[i] = node;\n    } else {\n      // update the value @ i\n      this._values[i].value = v;\n    }\n  };\n  Spa.prototype.get = function (i) {\n    var node = this._values[i];\n    if (node) {\n      return node.value;\n    }\n    return 0;\n  };\n  Spa.prototype.accumulate = function (i, v) {\n    // node @ i\n    var node = this._values[i];\n    if (!node) {\n      // insert in heap\n      node = this._heap.insert(i, v); // initialize value\n\n      this._values[i] = node;\n    } else {\n      // accumulate value\n      node.value = addScalar(node.value, v);\n    }\n  };\n  Spa.prototype.forEach = function (from, to, callback) {\n    // references\n    var heap = this._heap;\n    var values = this._values; // nodes\n\n    var nodes = []; // node with minimum key, save it\n\n    var node = heap.extractMinimum();\n    if (node) {\n      nodes.push(node);\n    } // extract nodes from heap (ordered)\n\n    while (node && node.key <= to) {\n      // check it is in range\n      if (node.key >= from) {\n        // check value is not zero\n        if (!equalScalar(node.value, 0)) {\n          // invoke callback\n          callback(node.key, node.value, this);\n        }\n      } // extract next node, save it\n\n      node = heap.extractMinimum();\n      if (node) {\n        nodes.push(node);\n      }\n    } // reinsert all nodes in heap\n\n    for (var i = 0; i < nodes.length; i++) {\n      // current node\n      var n = nodes[i]; // insert node in heap\n\n      node = heap.insert(n.key, n.value); // update values\n\n      values[node.key] = node;\n    }\n  };\n  Spa.prototype.swap = function (i, j) {\n    // node @ i and j\n    var nodei = this._values[i];\n    var nodej = this._values[j]; // check we need to insert indeces\n\n    if (!nodei && nodej) {\n      // insert in heap\n      nodei = this._heap.insert(i, nodej.value); // remove from heap\n\n      this._heap.remove(nodej); // set values\n\n      this._values[i] = nodei;\n      this._values[j] = undefined;\n    } else if (nodei && !nodej) {\n      // insert in heap\n      nodej = this._heap.insert(j, nodei.value); // remove from heap\n\n      this._heap.remove(nodei); // set values\n\n      this._values[j] = nodej;\n      this._values[i] = undefined;\n    } else if (nodei && nodej) {\n      // swap values\n      var v = nodei.value;\n      nodei.value = nodej.value;\n      nodej.value = v;\n    }\n  };\n  return Spa;\n}, {\n  isClass: true\n});\nexports.createSpaClass = createSpaClass;","map":{"version":3,"names":["Object","defineProperty","exports","value","createSpaClass","_factory","require","name","dependencies","factory","_ref","addScalar","equalScalar","FibonacciHeap","Spa","SyntaxError","_values","_heap","prototype","type","isSpa","set","i","v","node","insert","get","accumulate","forEach","from","to","callback","heap","values","nodes","extractMinimum","push","key","length","n","swap","j","nodei","nodej","remove","undefined","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/type/matrix/Spa.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSpaClass = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Spa';\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\nvar createSpaClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var addScalar = _ref.addScalar,\n      equalScalar = _ref.equalScalar,\n      FibonacciHeap = _ref.FibonacciHeap;\n\n  /**\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\n   * of the vector elements and an ordered list of non-zero elements.\n   */\n  function Spa() {\n    if (!(this instanceof Spa)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // allocate vector, TODO use typed arrays\n\n\n    this._values = [];\n    this._heap = new FibonacciHeap();\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Spa.prototype.type = 'Spa';\n  Spa.prototype.isSpa = true;\n  /**\n   * Set the value for index i.\n   *\n   * @param {number} i                       The index\n   * @param {number | BigNumber | Complex}   The value at index i\n   */\n\n  Spa.prototype.set = function (i, v) {\n    // check we have a value @ i\n    if (!this._values[i]) {\n      // insert in heap\n      var node = this._heap.insert(i, v); // set the value @ i\n\n\n      this._values[i] = node;\n    } else {\n      // update the value @ i\n      this._values[i].value = v;\n    }\n  };\n\n  Spa.prototype.get = function (i) {\n    var node = this._values[i];\n\n    if (node) {\n      return node.value;\n    }\n\n    return 0;\n  };\n\n  Spa.prototype.accumulate = function (i, v) {\n    // node @ i\n    var node = this._values[i];\n\n    if (!node) {\n      // insert in heap\n      node = this._heap.insert(i, v); // initialize value\n\n      this._values[i] = node;\n    } else {\n      // accumulate value\n      node.value = addScalar(node.value, v);\n    }\n  };\n\n  Spa.prototype.forEach = function (from, to, callback) {\n    // references\n    var heap = this._heap;\n    var values = this._values; // nodes\n\n    var nodes = []; // node with minimum key, save it\n\n    var node = heap.extractMinimum();\n\n    if (node) {\n      nodes.push(node);\n    } // extract nodes from heap (ordered)\n\n\n    while (node && node.key <= to) {\n      // check it is in range\n      if (node.key >= from) {\n        // check value is not zero\n        if (!equalScalar(node.value, 0)) {\n          // invoke callback\n          callback(node.key, node.value, this);\n        }\n      } // extract next node, save it\n\n\n      node = heap.extractMinimum();\n\n      if (node) {\n        nodes.push(node);\n      }\n    } // reinsert all nodes in heap\n\n\n    for (var i = 0; i < nodes.length; i++) {\n      // current node\n      var n = nodes[i]; // insert node in heap\n\n      node = heap.insert(n.key, n.value); // update values\n\n      values[node.key] = node;\n    }\n  };\n\n  Spa.prototype.swap = function (i, j) {\n    // node @ i and j\n    var nodei = this._values[i];\n    var nodej = this._values[j]; // check we need to insert indeces\n\n    if (!nodei && nodej) {\n      // insert in heap\n      nodei = this._heap.insert(i, nodej.value); // remove from heap\n\n      this._heap.remove(nodej); // set values\n\n\n      this._values[i] = nodei;\n      this._values[j] = undefined;\n    } else if (nodei && !nodej) {\n      // insert in heap\n      nodej = this._heap.insert(j, nodei.value); // remove from heap\n\n      this._heap.remove(nodei); // set values\n\n\n      this._values[j] = nodej;\n      this._values[i] = undefined;\n    } else if (nodei && nodej) {\n      // swap values\n      var v = nodei.value;\n      nodei.value = nodej.value;\n      nodej.value = v;\n    }\n  };\n\n  return Spa;\n}, {\n  isClass: true\n});\nexports.createSpaClass = createSpaClass;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}