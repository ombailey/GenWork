{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDiag = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nvar createDiag = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix,\n    DenseMatrix = _ref.DenseMatrix,\n    SparseMatrix = _ref.SparseMatrix;\n\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    Array: function Array(x) {\n      return _diag(x, 0, (0, _array.arraySize)(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, (0, _array.arraySize)(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, (0, _array.arraySize)(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, (0, _array.arraySize)(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!(0, _number.isInteger)(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if ((0, _is.isMatrix)(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n        return dm;\n      }\n      return dm.valueOf();\n    } // vector size\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});\nexports.createDiag = createDiag;","map":{"version":3,"names":["Object","defineProperty","exports","value","createDiag","_is","require","_array","_number","_factory","name","dependencies","factory","_ref","typed","matrix","DenseMatrix","SparseMatrix","Array","x","_diag","arraySize","ArrayNumber","k","ArrayBigNumber","toNumber","ArrayString","format","ArrayNumberString","ArrayBigNumberString","Matrix","size","storage","MatrixNumber","MatrixBigNumber","MatrixString","MatrixNumberString","MatrixBigNumberString","isInteger","TypeError","kSuper","kSub","length","_createDiagonalMatrix","_getDiagonal","RangeError","l","ms","concat","m","diagonal","valueOf","s","isMatrix","dm","n","Math","min","vector","i"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/function/matrix/diag.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDiag = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nvar createDiag = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix;\n\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    Array: function Array(x) {\n      return _diag(x, 0, (0, _array.arraySize)(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, (0, _array.arraySize)(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, (0, _array.arraySize)(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, (0, _array.arraySize)(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), (0, _array.arraySize)(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!(0, _number.isInteger)(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if ((0, _is.isMatrix)(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});\nexports.createDiag = createDiag;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}