{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createIndexClass = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'Index';\nvar dependencies = ['ImmutableDenseMatrix'];\nvar createIndexClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var ImmutableDenseMatrix = _ref.ImmutableDenseMatrix;\n\n  /**\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\n   *\n   * Usage:\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\n   *\n   * Where each parameter can be any of:\n   *     A number\n   *     A string (containing a name of an object property)\n   *     An instance of Range\n   *     An Array with the Set values\n   *     A Matrix with the Set values\n   *\n   * The parameters start, end, and step must be integer numbers.\n   *\n   * @class Index\n   * @Constructor Index\n   * @param {...*} ranges\n   */\n  function Index(ranges) {\n    if (!(this instanceof Index)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this._dimensions = [];\n    this._isScalar = true;\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n      if ((0, _is.isRange)(arg)) {\n        this._dimensions.push(arg);\n        this._isScalar = false;\n      } else if (Array.isArray(arg) || (0, _is.isMatrix)(arg)) {\n        // create matrix\n        var m = _createImmutableMatrix(arg.valueOf());\n        this._dimensions.push(m); // size\n\n        var size = m.size(); // scalar\n\n        if (size.length !== 1 || size[0] !== 1) {\n          this._isScalar = false;\n        }\n      } else if (typeof arg === 'number') {\n        this._dimensions.push(_createImmutableMatrix([arg]));\n      } else if (typeof arg === 'string') {\n        // object property (arguments.count should be 1)\n        this._dimensions.push(arg);\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      } // TODO: implement support for wildcard '*'\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n  Index.prototype.type = 'Index';\n  Index.prototype.isIndex = true;\n  function _createImmutableMatrix(arg) {\n    // loop array elements\n    for (var i = 0, l = arg.length; i < l; i++) {\n      if (typeof arg[i] !== 'number' || !(0, _number.isInteger)(arg[i])) {\n        throw new TypeError('Index parameters must be positive integer numbers');\n      }\n    } // create matrix\n\n    return new ImmutableDenseMatrix(arg);\n  }\n  /**\n   * Create a clone of the index\n   * @memberof Index\n   * @return {Index} clone\n   */\n\n  Index.prototype.clone = function () {\n    var index = new Index();\n    index._dimensions = (0, _object.clone)(this._dimensions);\n    index._isScalar = this._isScalar;\n    return index;\n  };\n  /**\n   * Create an index from an array with ranges/numbers\n   * @memberof Index\n   * @param {Array.<Array | number>} ranges\n   * @return {Index} index\n   * @private\n   */\n\n  Index.create = function (ranges) {\n    var index = new Index();\n    Index.apply(index, ranges);\n    return index;\n  };\n  /**\n   * Retrieve the size of the index, the number of elements for each dimension.\n   * @memberof Index\n   * @returns {number[]} size\n   */\n\n  Index.prototype.size = function () {\n    var size = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var d = this._dimensions[i];\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\n    }\n    return size;\n  };\n  /**\n   * Get the maximum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} max\n   */\n\n  Index.prototype.max = function () {\n    var values = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.max();\n    }\n    return values;\n  };\n  /**\n   * Get the minimum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} min\n   */\n\n  Index.prototype.min = function () {\n    var values = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.min();\n    }\n    return values;\n  };\n  /**\n   * Loop over each of the ranges of the index\n   * @memberof Index\n   * @param {Function} callback   Called for each range with a Range as first\n   *                              argument, the dimension as second, and the\n   *                              index object as third.\n   */\n\n  Index.prototype.forEach = function (callback) {\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      callback(this._dimensions[i], i, this);\n    }\n  };\n  /**\n   * Retrieve the dimension for the given index\n   * @memberof Index\n   * @param {Number} dim                  Number of the dimension\n   * @returns {Range | null} range\n   */\n\n  Index.prototype.dimension = function (dim) {\n    return this._dimensions[dim] || null;\n  };\n  /**\n   * Test whether this index contains an object property\n   * @returns {boolean} Returns true if the index is an object property\n   */\n\n  Index.prototype.isObjectProperty = function () {\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\n  };\n  /**\n   * Returns the object property name when the Index holds a single object property,\n   * else returns null\n   * @returns {string | null}\n   */\n\n  Index.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this._dimensions[0] : null;\n  };\n  /**\n   * Test whether this index contains only a single value.\n   *\n   * This is the case when the index is created with only scalar values as ranges,\n   * not for ranges resolving into a single value.\n   * @memberof Index\n   * @return {boolean} isScalar\n   */\n\n  Index.prototype.isScalar = function () {\n    return this._isScalar;\n  };\n  /**\n   * Expand the Index into an array.\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n  Index.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\n    }\n    return array;\n  };\n  /**\n   * Get the primitive value of the Index, a two dimensional array.\n   * Equivalent to Index.toArray().\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n  Index.prototype.valueOf = Index.prototype.toArray;\n  /**\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\n   * @memberof Index\n   * @returns {String} str\n   */\n\n  Index.prototype.toString = function () {\n    var strings = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      if (typeof dimension === 'string') {\n        strings.push(JSON.stringify(dimension));\n      } else {\n        strings.push(dimension.toString());\n      }\n    }\n    return '[' + strings.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the Index\n   * @memberof Index\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   */\n\n  Index.prototype.toJSON = function () {\n    return {\n      mathjs: 'Index',\n      dimensions: this._dimensions\n    };\n  };\n  /**\n   * Instantiate an Index from a JSON object\n   * @memberof Index\n   * @param {Object} json A JSON object structured as:\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   * @return {Index}\n   */\n\n  Index.fromJSON = function (json) {\n    return Index.create(json.dimensions);\n  };\n  return Index;\n}, {\n  isClass: true\n});\nexports.createIndexClass = createIndexClass;","map":{"version":3,"names":["Object","defineProperty","exports","value","createIndexClass","_is","require","_object","_number","_factory","name","dependencies","factory","_ref","ImmutableDenseMatrix","Index","ranges","SyntaxError","_dimensions","_isScalar","i","ii","arguments","length","arg","isRange","push","Array","isArray","isMatrix","m","_createImmutableMatrix","valueOf","size","TypeError","prototype","type","isIndex","l","isInteger","clone","index","create","apply","d","max","values","range","min","forEach","callback","dimension","dim","isObjectProperty","getObjectProperty","isScalar","toArray","array","toString","strings","JSON","stringify","join","toJSON","mathjs","dimensions","fromJSON","json","isClass"],"sources":["/Users/omarbailey/node_modules/mathjs/lib/cjs/type/matrix/MatrixIndex.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createIndexClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Index';\nvar dependencies = ['ImmutableDenseMatrix'];\nvar createIndexClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var ImmutableDenseMatrix = _ref.ImmutableDenseMatrix;\n\n  /**\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\n   *\n   * Usage:\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\n   *\n   * Where each parameter can be any of:\n   *     A number\n   *     A string (containing a name of an object property)\n   *     An instance of Range\n   *     An Array with the Set values\n   *     A Matrix with the Set values\n   *\n   * The parameters start, end, and step must be integer numbers.\n   *\n   * @class Index\n   * @Constructor Index\n   * @param {...*} ranges\n   */\n  function Index(ranges) {\n    if (!(this instanceof Index)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this._dimensions = [];\n    this._isScalar = true;\n\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n\n      if ((0, _is.isRange)(arg)) {\n        this._dimensions.push(arg);\n\n        this._isScalar = false;\n      } else if (Array.isArray(arg) || (0, _is.isMatrix)(arg)) {\n        // create matrix\n        var m = _createImmutableMatrix(arg.valueOf());\n\n        this._dimensions.push(m); // size\n\n\n        var size = m.size(); // scalar\n\n        if (size.length !== 1 || size[0] !== 1) {\n          this._isScalar = false;\n        }\n      } else if (typeof arg === 'number') {\n        this._dimensions.push(_createImmutableMatrix([arg]));\n      } else if (typeof arg === 'string') {\n        // object property (arguments.count should be 1)\n        this._dimensions.push(arg);\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      } // TODO: implement support for wildcard '*'\n\n    }\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Index.prototype.type = 'Index';\n  Index.prototype.isIndex = true;\n\n  function _createImmutableMatrix(arg) {\n    // loop array elements\n    for (var i = 0, l = arg.length; i < l; i++) {\n      if (typeof arg[i] !== 'number' || !(0, _number.isInteger)(arg[i])) {\n        throw new TypeError('Index parameters must be positive integer numbers');\n      }\n    } // create matrix\n\n\n    return new ImmutableDenseMatrix(arg);\n  }\n  /**\n   * Create a clone of the index\n   * @memberof Index\n   * @return {Index} clone\n   */\n\n\n  Index.prototype.clone = function () {\n    var index = new Index();\n    index._dimensions = (0, _object.clone)(this._dimensions);\n    index._isScalar = this._isScalar;\n    return index;\n  };\n  /**\n   * Create an index from an array with ranges/numbers\n   * @memberof Index\n   * @param {Array.<Array | number>} ranges\n   * @return {Index} index\n   * @private\n   */\n\n\n  Index.create = function (ranges) {\n    var index = new Index();\n    Index.apply(index, ranges);\n    return index;\n  };\n  /**\n   * Retrieve the size of the index, the number of elements for each dimension.\n   * @memberof Index\n   * @returns {number[]} size\n   */\n\n\n  Index.prototype.size = function () {\n    var size = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var d = this._dimensions[i];\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\n    }\n\n    return size;\n  };\n  /**\n   * Get the maximum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} max\n   */\n\n\n  Index.prototype.max = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.max();\n    }\n\n    return values;\n  };\n  /**\n   * Get the minimum value for each of the indexes ranges.\n   * @memberof Index\n   * @returns {number[]} min\n   */\n\n\n  Index.prototype.min = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.min();\n    }\n\n    return values;\n  };\n  /**\n   * Loop over each of the ranges of the index\n   * @memberof Index\n   * @param {Function} callback   Called for each range with a Range as first\n   *                              argument, the dimension as second, and the\n   *                              index object as third.\n   */\n\n\n  Index.prototype.forEach = function (callback) {\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      callback(this._dimensions[i], i, this);\n    }\n  };\n  /**\n   * Retrieve the dimension for the given index\n   * @memberof Index\n   * @param {Number} dim                  Number of the dimension\n   * @returns {Range | null} range\n   */\n\n\n  Index.prototype.dimension = function (dim) {\n    return this._dimensions[dim] || null;\n  };\n  /**\n   * Test whether this index contains an object property\n   * @returns {boolean} Returns true if the index is an object property\n   */\n\n\n  Index.prototype.isObjectProperty = function () {\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\n  };\n  /**\n   * Returns the object property name when the Index holds a single object property,\n   * else returns null\n   * @returns {string | null}\n   */\n\n\n  Index.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this._dimensions[0] : null;\n  };\n  /**\n   * Test whether this index contains only a single value.\n   *\n   * This is the case when the index is created with only scalar values as ranges,\n   * not for ranges resolving into a single value.\n   * @memberof Index\n   * @return {boolean} isScalar\n   */\n\n\n  Index.prototype.isScalar = function () {\n    return this._isScalar;\n  };\n  /**\n   * Expand the Index into an array.\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n\n  Index.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\n    }\n\n    return array;\n  };\n  /**\n   * Get the primitive value of the Index, a two dimensional array.\n   * Equivalent to Index.toArray().\n   * @memberof Index\n   * @returns {Array} array\n   */\n\n\n  Index.prototype.valueOf = Index.prototype.toArray;\n  /**\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\n   * @memberof Index\n   * @returns {String} str\n   */\n\n  Index.prototype.toString = function () {\n    var strings = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n\n      if (typeof dimension === 'string') {\n        strings.push(JSON.stringify(dimension));\n      } else {\n        strings.push(dimension.toString());\n      }\n    }\n\n    return '[' + strings.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the Index\n   * @memberof Index\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   */\n\n\n  Index.prototype.toJSON = function () {\n    return {\n      mathjs: 'Index',\n      dimensions: this._dimensions\n    };\n  };\n  /**\n   * Instantiate an Index from a JSON object\n   * @memberof Index\n   * @param {Object} json A JSON object structured as:\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\n   * @return {Index}\n   */\n\n\n  Index.fromJSON = function (json) {\n    return Index.create(json.dimensions);\n  };\n\n  return Index;\n}, {\n  isClass: true\n});\nexports.createIndexClass = createIndexClass;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}